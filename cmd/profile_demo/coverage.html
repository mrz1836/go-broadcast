
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>profile_demo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mrz1836/go-broadcast/cmd/profile_demo/main.go (69.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides a comprehensive demonstration of the profiling capabilities.
// This demo showcases memory profiling, performance benchmarking, and resource monitoring
// across various operations including caching, worker pools, and batch processing.
package main

import (
        "context"
        "crypto/rand"
        "fmt"
        "log"
        "math/big"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/mrz1836/go-broadcast/internal/algorithms"
        "github.com/mrz1836/go-broadcast/internal/cache"
        "github.com/mrz1836/go-broadcast/internal/profiling"
        "github.com/mrz1836/go-broadcast/internal/reporting"
        "github.com/mrz1836/go-broadcast/internal/worker"
)

// secureRandInt generates a cryptographically secure random integer in range [0, maxVal)
func secureRandInt(maxVal int) int <span class="cov8" title="1">{
        if maxVal &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">n, err := rand.Int(rand.Reader, big.NewInt(int64(maxVal)))
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to current time for demo purposes
                return int(time.Now().UnixNano()) % maxVal
        }</span>
        <span class="cov8" title="1">return int(n.Int64())</span>
}

func main() <span class="cov0" title="0">{
        log.Println("Starting comprehensive profiling demonstration...")

        // Initialize profiling suite
        profilesDir := "./profiles/final_demo"
        if err := os.MkdirAll(profilesDir, 0o750); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create profiles directory: %v", err)
        }</span>

        <span class="cov0" title="0">suite := profiling.NewProfileSuite(profilesDir)

        // Configure comprehensive profiling (disable CPU to avoid conflicts)
        config := profiling.ProfileConfig{
                EnableCPU:            false, // Disabled to avoid conflicts
                EnableMemory:         true,
                EnableTrace:          false, // Disabled to reduce overhead
                EnableBlock:          false,
                EnableMutex:          false,
                BlockProfileRate:     1,
                MutexProfileFraction: 1,
                GenerateReports:      true,
                ReportFormat:         "text",
                AutoCleanup:          false,
                MaxSessionsToKeep:    10,
        }
        suite.Configure(config)

        // Start profiling session
        if err := suite.StartProfiling("final_optimization_demo"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start profiling: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Profiling started - running optimization demonstrations...")

        // Create performance metrics collector
        metrics := make(map[string]float64)

        // Demonstrate worker pool optimization
        log.Println("1. Testing Worker Pool optimization...")
        start := time.Now()
        testWorkerPool()
        metrics["worker_pool_duration_ms"] = float64(time.Since(start).Nanoseconds()) / 1e6

        // Demonstrate cache optimization
        log.Println("2. Testing TTL Cache optimization...")
        start = time.Now()
        testTTLCache()
        metrics["cache_duration_ms"] = float64(time.Since(start).Nanoseconds()) / 1e6

        // Demonstrate algorithm optimizations
        log.Println("3. Testing Algorithm optimizations...")
        start = time.Now()
        testAlgorithmOptimizations()
        metrics["algorithms_duration_ms"] = float64(time.Since(start).Nanoseconds()) / 1e6

        // Demonstrate batch processing
        log.Println("4. Testing Batch Processing optimization...")
        start = time.Now()
        testBatchProcessing()
        metrics["batch_processing_duration_ms"] = float64(time.Since(start).Nanoseconds()) / 1e6

        log.Println("Optimization demonstrations completed - stopping profiling...")

        // Stop profiling
        if err := suite.StopProfiling(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to stop profiling: %v", err)
        }</span>

        // Generate performance report
        <span class="cov0" title="0">log.Println("Generating comprehensive performance report...")
        generateFinalReport(metrics, profilesDir)

        log.Println("Final profiling demonstration completed successfully!")
        log.Printf("Results available in: %s\n", profilesDir)</span>
}

func testWorkerPool() <span class="cov8" title="1">{
        // Create worker pool with optimal worker count
        pool := worker.NewPool(8, 100) // 8 workers, 100 queue size

        pool.Start(context.Background())
        defer pool.Shutdown()

        // Submit intensive tasks (reduced for demo)
        var wg sync.WaitGroup
        taskCount := 100

        for i := 0; i &lt; taskCount; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                task := &amp;intensiveTask{
                        id: i,
                        wg: &amp;wg,
                }
                if err := pool.Submit(task); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to submit task: %v", err)
                }</span>
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

func testTTLCache() <span class="cov8" title="1">{
        // Create TTL cache
        ttlCache := cache.NewTTLCache(time.Minute*5, 10000) // 5 min TTL, 10k max size

        // Perform cache operations (reduced for demo)
        operationCount := 1000

        // Mix of sets and gets to simulate realistic usage
        for i := 0; i &lt; operationCount; i++ </span><span class="cov8" title="1">{
                key := fmt.Sprintf("key_%d", secureRandInt(1000))

                if i%3 == 0 </span><span class="cov8" title="1">{
                        // Set operation
                        value := fmt.Sprintf("data_%d_%s", i, generateTestData(100))
                        ttlCache.Set(key, value)
                }</span> else<span class="cov8" title="1"> {
                        // Get operation
                        ttlCache.Get(key)
                }</span>
        }
}

func testAlgorithmOptimizations() <span class="cov8" title="1">{
        // Test binary detection optimization
        testData := [][]byte{
                []byte("This is text content for testing"),
                generateBinaryData(1024),
                generateTextData(2048),
                generateBinaryData(4096),
                generateTextData(8192),
        }

        for _, data := range testData </span><span class="cov8" title="1">{
                algorithms.IsBinaryOptimized(data)
        }</span>

        // Test diff optimization (reduced for demo)
        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                data1 := generateTextData(512)
                data2 := modifyData(data1, 0.1) // 10% modification
                algorithms.DiffOptimized(data1, data2, 1024*1024)
        }</span>
}

func testBatchProcessing() <span class="cov8" title="1">{
        // Create batch processor
        config := algorithms.DefaultBatchProcessorConfig()
        config.BatchSize = 50
        config.FlushInterval = time.Millisecond * 100

        processor := algorithms.NewBatchProcessor(func(items []interface{}) error </span><span class="cov8" title="1">{
                // Simulate processing work
                time.Sleep(time.Microsecond * time.Duration(len(items)*10))
                return nil
        }</span>, config)

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := processor.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to stop processor: %v\n", err)
                }</span>
        }()

        // Submit batch items (reduced for demo)
        <span class="cov8" title="1">itemCount := 100
        for i := 0; i &lt; itemCount; i++ </span><span class="cov8" title="1">{
                item := fmt.Sprintf("item_%d_%s", i, generateTestData(50))
                if err := processor.Add(item); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to add item: %v\n", err)
                }</span>
        }

        // Ensure final flush
        <span class="cov8" title="1">if err := processor.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to flush processor: %v\n", err)
        }</span>
}

func generateFinalReport(metrics map[string]float64, profilesDir string) <span class="cov8" title="1">{
        // Create performance reporter
        reportConfig := reporting.DefaultReportConfig()
        reportConfig.OutputDirectory = profilesDir
        reportConfig.GenerateHTML = true
        reportConfig.GenerateJSON = true
        reportConfig.GenerateMarkdown = true

        reporter := reporting.NewPerformanceReporter(reportConfig)

        // Create mock test results
        testResults := []reporting.TestResult{
                {
                        Name:       "Worker Pool Optimization",
                        Duration:   time.Duration(metrics["worker_pool_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 1000.0 / (metrics["worker_pool_duration_ms"] / 1000.0), // tasks/sec
                        MemoryUsed: 10,                                                     // MB estimate
                },
                {
                        Name:       "TTL Cache Optimization",
                        Duration:   time.Duration(metrics["cache_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 10000.0 / (metrics["cache_duration_ms"] / 1000.0), // ops/sec
                        MemoryUsed: 5,                                                 // MB estimate
                },
                {
                        Name:       "Algorithm Optimizations",
                        Duration:   time.Duration(metrics["algorithms_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 500.0 / (metrics["algorithms_duration_ms"] / 1000.0), // ops/sec
                        MemoryUsed: 3,                                                    // MB estimate
                },
                {
                        Name:       "Batch Processing Optimization",
                        Duration:   time.Duration(metrics["batch_processing_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 1000.0 / (metrics["batch_processing_duration_ms"] / 1000.0), // items/sec
                        MemoryUsed: 2,                                                           // MB estimate
                },
        }

        // Create profile summary
        profileSummary := reporting.ProfileSummary{
                CPUProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      1024 * 1024, // 1MB estimate
                        Path:      filepath.Join(profilesDir, "cpu.prof"),
                },
                MemoryProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      512 * 1024, // 512KB estimate
                        Path:      filepath.Join(profilesDir, "memory.prof"),
                },
                GoroutineProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      256 * 1024, // 256KB estimate
                        Path:      filepath.Join(profilesDir, "goroutine.prof"),
                },
                TotalProfileSize: 1024*1024 + 512*1024 + 256*1024,
        }

        // Generate comprehensive report
        report, err := reporter.GenerateReport(metrics, testResults, profileSummary)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to generate report: %v", err)
                return
        }</span>

        // Save report
        <span class="cov8" title="1">if err := reporter.SaveReport(report); err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to save report: %v", err)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Final performance report generated: %s\n", reportConfig.OutputDirectory)</span>
}

// Helper types and functions

type intensiveTask struct {
        id int
        wg *sync.WaitGroup
}

func (t *intensiveTask) Execute(_ context.Context) error <span class="cov8" title="1">{
        defer t.wg.Done()

        // Simulate CPU work (reduced for demo)
        sum := 0
        for i := 0; i &lt; 1000; i++ </span><span class="cov8" title="1">{
                sum += i * t.id
        }</span>

        // Simulate some memory allocation
        <span class="cov8" title="1">data := make([]byte, 1024)
        for i := range data </span><span class="cov8" title="1">{
                data[i] = byte(sum % 256)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *intensiveTask) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("intensive_task_%d", t.id)
}</span>

func generateTestData(size int) string <span class="cov8" title="1">{
        chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        result := make([]byte, size)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = chars[secureRandInt(len(chars))]
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}

func generateBinaryData(size int) []byte <span class="cov8" title="1">{
        data := make([]byte, size)
        if _, err := rand.Read(data); err != nil </span><span class="cov0" title="0">{
                // Fall back to deterministic data for demo
                for i := range data </span><span class="cov0" title="0">{
                        data[i] = byte(i % 256)
                }</span>
        }
        // Ensure some null bytes to trigger binary detection
        <span class="cov8" title="1">for i := 0; i &lt; size/10; i++ </span><span class="cov8" title="1">{
                data[secureRandInt(size)] = 0
        }</span>
        <span class="cov8" title="1">return data</span>
}

func generateTextData(size int) []byte <span class="cov8" title="1">{
        chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \n\t"
        result := make([]byte, size)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = chars[secureRandInt(len(chars))]
        }</span>
        <span class="cov8" title="1">return result</span>
}

func modifyData(data []byte, ratio float64) []byte <span class="cov8" title="1">{
        result := make([]byte, len(data))
        copy(result, data)

        modifyCount := int(float64(len(data)) * ratio)

        // For small data or high ratios, ensure unique positions
        if modifyCount &gt; 0 &amp;&amp; len(data) &gt; 0 </span><span class="cov8" title="1">{
                if modifyCount &gt;= len(data) </span><span class="cov8" title="1">{
                        // Modify all positions
                        for i := range result </span><span class="cov8" title="1">{
                                result[i] = byte(secureRandInt(256))
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Create a list of all positions and shuffle to get unique positions
                        positions := make([]int, len(data))
                        for i := range positions </span><span class="cov8" title="1">{
                                positions[i] = i
                        }</span>

                        // Fisher-Yates shuffle to randomize positions
                        <span class="cov8" title="1">for i := len(positions) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                                j := secureRandInt(i + 1)
                                positions[i], positions[j] = positions[j], positions[i]
                        }</span>

                        // Modify the first modifyCount positions from the shuffled list
                        <span class="cov8" title="1">for i := 0; i &lt; modifyCount; i++ </span><span class="cov8" title="1">{
                                result[positions[i]] = byte(secureRandInt(256))
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
