// Package dashboard provides interactive analytics dashboard functionality for coverage metrics
package dashboard

import (
	"context"
	"encoding/json"
	"fmt"
	"html/template"
	"sort"
	"strings"
	"time"

	"github.com/mrz1836/go-broadcast/coverage/internal/analytics/charts"
	"github.com/mrz1836/go-broadcast/coverage/internal/analytics/history"
	"github.com/mrz1836/go-broadcast/coverage/internal/analytics/impact"
	"github.com/mrz1836/go-broadcast/coverage/internal/analytics/prediction"
)

// AnalyticsDashboard provides comprehensive coverage analytics visualization
type AnalyticsDashboard struct {
	config         *DashboardConfig
	chartGenerator *charts.SVGChartGenerator
	historyAnalyzer *history.TrendAnalyzer
	predictor      *prediction.CoveragePredictor
	impactAnalyzer *impact.PRImpactAnalyzer
	notifier       *notify.NotificationEngine
}

// DashboardConfig holds configuration for the analytics dashboard
type DashboardConfig struct {
	// Display settings
	Title                string            `json:"title"`
	Theme                DashboardTheme    `json:"theme"`
	RefreshInterval      time.Duration     `json:"refresh_interval"`
	DefaultTimeRange     TimeRange         `json:"default_time_range"`
	
	// Feature toggles
	EnablePredictions    bool              `json:"enable_predictions"`
	EnableImpactAnalysis bool              `json:"enable_impact_analysis"`
	EnableNotifications  bool              `json:"enable_notifications"`
	EnableExports        bool              `json:"enable_exports"`
	EnableTeamAnalytics  bool              `json:"enable_team_analytics"`
	
	// Chart settings
	ChartDefaults        ChartDefaults     `json:"chart_defaults"`
	CustomCharts         []CustomChart     `json:"custom_charts"`
	
	// Data retention
	HistoryRetention     time.Duration     `json:"history_retention"`
	PredictionHorizon    time.Duration     `json:"prediction_horizon"`
	
	// Access control
	RequireAuth          bool              `json:"require_auth"`
	AllowedUsers         []string          `json:"allowed_users"`
	ReadOnlyMode         bool              `json:"read_only_mode"`
}

// DashboardTheme defines visual theme options
type DashboardTheme string

const (
	ThemeLight      DashboardTheme = "light"
	ThemeDark       DashboardTheme = "dark"
	ThemeAuto       DashboardTheme = "auto"
	ThemeGitHub     DashboardTheme = "github"
	ThemeHighContrast DashboardTheme = "high_contrast"
)

// TimeRange represents a time range for dashboard views
type TimeRange struct {
	Start    time.Time     `json:"start"`
	End      time.Time     `json:"end"`
	Preset   TimePreset    `json:"preset"`
	Custom   bool          `json:"custom"`
}

// TimePreset defines common time range presets
type TimePreset string

const (
	PresetLast24Hours TimePreset = "24h"
	PresetLast7Days   TimePreset = "7d"
	PresetLast30Days  TimePreset = "30d"
	PresetLast90Days  TimePreset = "90d"
	PresetLastYear    TimePreset = "1y"
	PresetCustom      TimePreset = "custom"
)

// ChartDefaults provides default settings for charts
type ChartDefaults struct {
	Width            int    `json:"width"`
	Height           int    `json:"height"`
	ShowGrid         bool   `json:"show_grid"`
	ShowLegend       bool   `json:"show_legend"`
	AnimationEnabled bool   `json:"animation_enabled"`
	ColorScheme      string `json:"color_scheme"`
}

// CustomChart defines user-configurable chart settings
type CustomChart struct {
	ID           string                 `json:"id"`
	Title        string                 `json:"title"`
	Type         charts.ChartType       `json:"type"`
	DataSource   string                 `json:"data_source"`
	Filters      map[string]interface{} `json:"filters"`
	Position     ChartPosition          `json:"position"`
	Size         ChartSize              `json:"size"`
	Enabled      bool                   `json:"enabled"`
}

// ChartPosition defines chart placement in the dashboard
type ChartPosition struct {
	Row    int `json:"row"`
	Column int `json:"column"`
	Span   int `json:"span"`
}

// ChartSize defines chart dimensions
type ChartSize struct {
	Width  int `json:"width"`
	Height int `json:"height"`
}

// DashboardData represents all data needed to render the dashboard
type DashboardData struct {
	// Metadata
	GeneratedAt      time.Time         `json:"generated_at"`
	TimeRange        TimeRange         `json:"time_range"`
	RefreshInterval  time.Duration     `json:"refresh_interval"`
	
	// Current metrics
	CurrentMetrics   CurrentMetrics    `json:"current_metrics"`
	
	// Historical data
	TrendAnalysis    *history.TrendReport    `json:"trend_analysis,omitempty"`
	
	// Predictions
	Predictions      []PredictionSummary     `json:"predictions,omitempty"`
	
	// Recent activity
	RecentActivity   []ActivityItem    `json:"recent_activity"`
	
	// Charts data
	Charts           []ChartData       `json:"charts"`
	
	// Notifications
	NotificationStatus *NotificationStatus `json:"notification_status,omitempty"`
	
	// Team analytics
	TeamAnalytics    *TeamAnalytics    `json:"team_analytics,omitempty"`
	
	// Quality gates
	QualityGates     QualityGateStatus `json:"quality_gates"`
}

// CurrentMetrics shows current state metrics
type CurrentMetrics struct {
	Coverage         float64           `json:"coverage"`
	CoverageChange   float64           `json:"coverage_change"`
	TrendDirection   string            `json:"trend_direction"`
	TrendStrength    string            `json:"trend_strength"`
	LastUpdated      time.Time         `json:"last_updated"`
	TotalTests       int               `json:"total_tests"`
	PassingTests     int               `json:"passing_tests"`
	TotalLines       int               `json:"total_lines"`
	CoveredLines     int               `json:"covered_lines"`
	QualityScore     float64           `json:"quality_score"`
}

// PredictionSummary provides summary of coverage predictions
type PredictionSummary struct {
	TimeHorizon      time.Duration     `json:"time_horizon"`
	PredictedCoverage float64          `json:"predicted_coverage"`
	Confidence       float64           `json:"confidence"`
	Scenario         string            `json:"scenario"`
	TrendIndicator   string            `json:"trend_indicator"`
}

// ActivityItem represents a recent activity entry
type ActivityItem struct {
	Timestamp    time.Time         `json:"timestamp"`
	Type         ActivityType      `json:"type"`
	Title        string            `json:"title"`
	Description  string            `json:"description"`
	Impact       string            `json:"impact"`
	Author       string            `json:"author,omitempty"`
	PRNumber     int               `json:"pr_number,omitempty"`
	CoverageChange float64         `json:"coverage_change,omitempty"`
}

// ActivityType defines types of activities tracked
type ActivityType string

const (
	ActivityCoverageUpdate ActivityType = "coverage_update"
	ActivityPRMerged       ActivityType = "pr_merged"
	ActivityPROpened       ActivityType = "pr_opened"
	ActivityThreshold      ActivityType = "threshold_crossed"
	ActivityPrediction     ActivityType = "prediction_alert"
	ActivityQualityGate    ActivityType = "quality_gate"
)

// ChartData represents data for a single chart in the dashboard
type ChartData struct {
	ID           string                 `json:"id"`
	Title        string                 `json:"title"`
	Type         charts.ChartType       `json:"type"`
	SVGContent   string                 `json:"svg_content"`
	DataPoints   int                    `json:"data_points"`
	LastUpdated  time.Time              `json:"last_updated"`
	Metadata     map[string]interface{} `json:"metadata"`
}

// NotificationStatus shows notification system status
type NotificationStatus struct {
	Enabled          bool              `json:"enabled"`
	ActiveChannels   []string          `json:"active_channels"`
	LastNotification time.Time         `json:"last_notification"`
	PendingEvents    int               `json:"pending_events"`
	ChannelHealth    map[string]bool   `json:"channel_health"`
}

// TeamAnalytics provides team-level analytics (placeholder for future implementation)
type TeamAnalytics struct {
	TotalMembers     int               `json:"total_members"`
	ActiveContributors int             `json:"active_contributors"`
	AvgContribution  float64           `json:"avg_contribution"`
	TopContributors  []Contributor     `json:"top_contributors"`
	CoverageByTeam   map[string]float64 `json:"coverage_by_team"`
}

// Contributor represents team member contribution data
type Contributor struct {
	Name             string    `json:"name"`
	CoverageImpact   float64   `json:"coverage_impact"`
	PRsContributed   int       `json:"prs_contributed"`
	QualityScore     float64   `json:"quality_score"`
	LastContribution time.Time `json:"last_contribution"`
}

// QualityGateStatus shows current quality gate status
type QualityGateStatus struct {
	OverallStatus    string                   `json:"overall_status"`
	PassedGates      int                      `json:"passed_gates"`
	TotalGates       int                      `json:"total_gates"`
	FailedGates      []string                 `json:"failed_gates"`
	GateDetails      map[string]GateDetail    `json:"gate_details"`
}

// GateDetail provides detailed information about a quality gate
type GateDetail struct {
	Name         string    `json:"name"`
	Status       string    `json:"status"`
	CurrentValue float64   `json:"current_value"`
	Threshold    float64   `json:"threshold"`
	LastChecked  time.Time `json:"last_checked"`
	Trend        string    `json:"trend"`
}

// DashboardRequest represents a request for dashboard data
type DashboardRequest struct {
	TimeRange    TimeRange              `json:"time_range"`
	Filters      map[string]interface{} `json:"filters"`
	ChartTypes   []charts.ChartType     `json:"chart_types"`
	IncludePredictions bool             `json:"include_predictions"`
	IncludeTeamData    bool             `json:"include_team_data"`
	RefreshCache       bool             `json:"refresh_cache"`
}

// NewAnalyticsDashboard creates a new analytics dashboard
func NewAnalyticsDashboard(config *DashboardConfig) *AnalyticsDashboard {
	if config == nil {
		config = &DashboardConfig{
			Title:               "Coverage Analytics Dashboard",
			Theme:               ThemeAuto,
			RefreshInterval:     5 * time.Minute,
			EnablePredictions:   true,
			EnableImpactAnalysis: true,
			EnableNotifications: true,
			EnableExports:       true,
			EnableTeamAnalytics: true,
			ChartDefaults: ChartDefaults{
				Width:            800,
				Height:           400,
				ShowGrid:         true,
				ShowLegend:       true,
				AnimationEnabled: true,
				ColorScheme:      "default",
			},
			HistoryRetention:    90 * 24 * time.Hour,
			PredictionHorizon:   30 * 24 * time.Hour,
			RequireAuth:         false,
			ReadOnlyMode:        false,
		}
		
		// Set default time range to last 30 days
		config.DefaultTimeRange = TimeRange{
			Start:  time.Now().AddDate(0, 0, -30),
			End:    time.Now(),
			Preset: PresetLast30Days,
			Custom: false,
		}
	}
	
	return &AnalyticsDashboard{
		config: config,
	}
}

// SetComponents configures the dashboard with analytics components
func (d *AnalyticsDashboard) SetComponents(
	chartGen *charts.SVGChartGenerator,
	historyAnalyzer *history.TrendAnalyzer,
	predictor *prediction.CoveragePredictor,
	impactAnalyzer *impact.PRImpactAnalyzer,
	notifier *notify.NotificationEngine,
) {
	d.chartGenerator = chartGen
	d.historyAnalyzer = historyAnalyzer
	d.predictor = predictor
	d.impactAnalyzer = impactAnalyzer
	d.notifier = notifier
}

// GenerateDashboard creates complete dashboard data
func (d *AnalyticsDashboard) GenerateDashboard(ctx context.Context, request *DashboardRequest) (*DashboardData, error) {
	data := &DashboardData{
		GeneratedAt:     time.Now(),
		TimeRange:       request.TimeRange,
		RefreshInterval: d.config.RefreshInterval,
		Charts:          make([]ChartData, 0),
		RecentActivity:  make([]ActivityItem, 0),
		Predictions:     make([]PredictionSummary, 0),
	}
	
	// Generate current metrics
	if err := d.generateCurrentMetrics(ctx, data); err != nil {
		return nil, fmt.Errorf("failed to generate current metrics: %w", err)
	}
	
	// Generate trend analysis
	if d.historyAnalyzer != nil {
		if err := d.generateTrendAnalysis(ctx, data, request); err != nil {
			return nil, fmt.Errorf("failed to generate trend analysis: %w", err)
		}
	}
	
	// Generate predictions
	if d.config.EnablePredictions && d.predictor != nil && request.IncludePredictions {
		if err := d.generatePredictions(ctx, data); err != nil {
			return nil, fmt.Errorf("failed to generate predictions: %w", err)
		}
	}
	
	// Generate charts
	if err := d.generateCharts(ctx, data, request); err != nil {
		return nil, fmt.Errorf("failed to generate charts: %w", err)
	}
	
	// Generate recent activity
	if err := d.generateRecentActivity(ctx, data, request); err != nil {
		return nil, fmt.Errorf("failed to generate recent activity: %w", err)
	}
	
	// Generate notification status
	if d.config.EnableNotifications && d.notifier != nil {
		if err := d.generateNotificationStatus(ctx, data); err != nil {
			return nil, fmt.Errorf("failed to generate notification status: %w", err)
		}
	}
	
	// Generate team analytics
	if d.config.EnableTeamAnalytics && request.IncludeTeamData {
		if err := d.generateTeamAnalytics(ctx, data); err != nil {
			return nil, fmt.Errorf("failed to generate team analytics: %w", err)
		}
	}
	
	// Generate quality gates
	if err := d.generateQualityGates(ctx, data); err != nil {
		return nil, fmt.Errorf("failed to generate quality gates: %w", err)
	}
	
	return data, nil
}

// GenerateHTML renders the dashboard as HTML
func (d *AnalyticsDashboard) GenerateHTML(ctx context.Context, data *DashboardData) (string, error) {
	// TODO: Fix JavaScript template literal syntax issues - template temporarily removed
	return "<html><body><h1>Dashboard temporarily disabled due to template syntax issues</h1></body></html>", nil
}

// Helper methods for generating dashboard data

func (d *AnalyticsDashboard) generateCurrentMetrics(ctx context.Context, data *DashboardData) error {
	// This would typically fetch real data from the coverage system
	data.CurrentMetrics = CurrentMetrics{
		Coverage:       78.5,
		CoverageChange: 2.3,
		TrendDirection: "ðŸ“ˆ Upward",
		TrendStrength:  "Strong",
		LastUpdated:    time.Now(),
	}
	return nil
}

func (d *AnalyticsDashboard) generateTrendAnalysis(ctx context.Context, data *DashboardData, request *DashboardRequest) error {
	// This would typically use the history analyzer
	data.TrendAnalysis = &TrendAnalysis{
		Direction:       "Upward",
		Strength:        "Strong", 
		PredictedChange: 2.1,
		Confidence:      0.85,
		Insights: []string{
			"Coverage has been steadily improving",
			"Strong positive trend in recent commits",
		},
	}
	return nil
}

// Helper methods for generating dashboard data

func (d *AnalyticsDashboard) generatePredictions(ctx context.Context, data *DashboardData) error {
</head>
<body class="theme-{{.Config.Theme}}">
    <div class="dashboard-container">
        <!-- Header -->
        <header class="dashboard-header">
            <div class="header-content">
                <h1 class="dashboard-title">{{.Config.Title}}</h1>
                <div class="header-controls">
                    <div class="time-range-selector">
                        <select id="timeRange" onchange="updateTimeRange()">
                            <option value="24h" {{if eq .Data.TimeRange.Preset "24h"}}selected{{end}}>Last 24 Hours</option>
                            <option value="7d" {{if eq .Data.TimeRange.Preset "7d"}}selected{{end}}>Last 7 Days</option>
                            <option value="30d" {{if eq .Data.TimeRange.Preset "30d"}}selected{{end}}>Last 30 Days</option>
                            <option value="90d" {{if eq .Data.TimeRange.Preset "90d"}}selected{{end}}>Last 90 Days</option>
                            <option value="1y" {{if eq .Data.TimeRange.Preset "1y"}}selected{{end}}>Last Year</option>
                            <option value="custom" {{if eq .Data.TimeRange.Preset "custom"}}selected{{end}}>Custom Range</option>
                        </select>
                    </div>
                    <button class="refresh-btn" onclick="refreshDashboard()">ðŸ”„ Refresh</button>
                    {{if .Config.EnableExports}}
                    <div class="export-controls">
                        <button class="export-btn" onclick="exportData('pdf')">ðŸ“„ PDF</button>
                        <button class="export-btn" onclick="exportData('csv')">ðŸ“Š CSV</button>
                        <button class="export-btn" onclick="exportData('json')">ðŸ”— JSON</button>
                    </div>
                    {{end}}
                </div>
            </div>
        </header>

        <!-- Current Metrics -->
        <section class="metrics-overview">
            <div class="metric-card primary">
                <div class="metric-value">{{printf "%.1f%%" .Data.CurrentMetrics.Coverage}}</div>
                <div class="metric-label">Current Coverage</div>
                <div class="metric-change {{if lt .Data.CurrentMetrics.CoverageChange 0}}negative{{else}}positive{{end}}">
                    {{if gt .Data.CurrentMetrics.CoverageChange 0}}+{{end}}{{printf "%.1f%%" .Data.CurrentMetrics.CoverageChange}}
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{{.Data.CurrentMetrics.TotalTests}}</div>
                <div class="metric-label">Total Tests</div>
                <div class="metric-detail">{{.Data.CurrentMetrics.PassingTests}} passing</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{{printf "%.1f" .Data.CurrentMetrics.QualityScore}}</div>
                <div class="metric-label">Quality Score</div>
                <div class="metric-detail">out of 10</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{{.Data.CurrentMetrics.TrendDirection}}</div>
                <div class="metric-label">Trend</div>
                <div class="metric-detail">{{.Data.CurrentMetrics.TrendStrength}}</div>
            </div>
        </section>

        <!-- Quality Gates -->
        <section class="quality-gates">
            <h2>Quality Gates</h2>
            <div class="gates-overview">
                <div class="gate-status {{.Data.QualityGates.OverallStatus}}">
                    <span class="status-indicator"></span>
                    {{.Data.QualityGates.PassedGates}}/{{.Data.QualityGates.TotalGates}} Gates Passed
                </div>
                {{if .Data.QualityGates.FailedGates}}
                <div class="failed-gates">
                    Failed: {{range $i, $gate := .Data.QualityGates.FailedGates}}{{if $i}}, {{end}}{{$gate}}{{end}}
                </div>
                {{end}}
            </div>
        </section>

        <!-- Charts Grid -->
        <section class="charts-grid">
            {{range .Data.Charts}}
            <div class="chart-container">
                <div class="chart-header">
                    <h3 class="chart-title">{{.Title}}</h3>
                    <div class="chart-meta">
                        <span class="data-points">{{.DataPoints}} points</span>
                        <span class="last-updated">Updated {{.LastUpdated.Format "15:04"}}</span>
                    </div>
                </div>
                <div class="chart-content">
                    {{.SVGContent}}
                </div>
            </div>
            {{end}}
        </section>

        <!-- Predictions -->
        {{if and .Config.EnablePredictions .Data.Predictions}}
        <section class="predictions-section">
            <h2>Coverage Predictions</h2>
            <div class="predictions-grid">
                {{range .Data.Predictions}}
                <div class="prediction-card">
                    <div class="prediction-timeframe">{{.TimeHorizon}}</div>
                    <div class="prediction-value">{{printf "%.1f%%" .PredictedCoverage}}</div>
                    <div class="prediction-confidence">{{printf "%.0f%% confidence" (mul .Confidence 100)}}</div>
                    <div class="prediction-scenario">{{.Scenario}}</div>
                </div>
                {{end}}
            </div>
        </section>
        {{end}}

        <!-- Recent Activity -->
        <section class="recent-activity">
            <h2>Recent Activity</h2>
            <div class="activity-list">
                {{range .Data.RecentActivity}}
                <div class="activity-item {{.Type}}">
                    <div class="activity-timestamp">{{.Timestamp.Format "Jan 02 15:04"}}</div>
                    <div class="activity-content">
                        <div class="activity-title">{{.Title}}</div>
                        <div class="activity-description">{{.Description}}</div>
                        {{if .CoverageChange}}
                        <div class="activity-impact">Coverage change: {{if gt .CoverageChange 0}}+{{end}}{{printf "%.1f%%" .CoverageChange}}</div>
                        {{end}}
                    </div>
                </div>
                {{end}}
            </div>
        </section>

        <!-- Notifications Status -->
        {{if and .Config.EnableNotifications .Data.NotificationStatus}}
        <section class="notifications-status">
            <h2>Notifications</h2>
            <div class="notification-overview">
                <div class="notification-status {{if .Data.NotificationStatus.Enabled}}enabled{{else}}disabled{{end}}">
                    Status: {{if .Data.NotificationStatus.Enabled}}Enabled{{else}}Disabled{{end}}
                </div>
                <div class="active-channels">
                    Channels: {{range $i, $channel := .Data.NotificationStatus.ActiveChannels}}{{if $i}}, {{end}}{{$channel}}{{end}}
                </div>
                {{if .Data.NotificationStatus.PendingEvents}}
                <div class="pending-events">{{.Data.NotificationStatus.PendingEvents}} pending events</div>
                {{end}}
            </div>
        </section>
        {{end}}

        <!-- Team Analytics -->
        {{if and .Config.EnableTeamAnalytics .Data.TeamAnalytics}}
        <section class="team-analytics">
            <h2>Team Analytics</h2>
            <div class="team-overview">
                <div class="team-metric">
                    <span class="metric">{{.Data.TeamAnalytics.TotalMembers}}</span>
                    <span class="label">Total Members</span>
                </div>
                <div class="team-metric">
                    <span class="metric">{{.Data.TeamAnalytics.ActiveContributors}}</span>
                    <span class="label">Active Contributors</span>
                </div>
                <div class="team-metric">
                    <span class="metric">{{printf "%.1f%%" .Data.TeamAnalytics.AvgContribution}}</span>
                    <span class="label">Avg Contribution</span>
                </div>
            </div>
            <div class="top-contributors">
                <h3>Top Contributors</h3>
                {{range .Data.TeamAnalytics.TopContributors}}
                <div class="contributor">
                    <span class="name">{{.Name}}</span>
                    <span class="impact">{{if gt .CoverageImpact 0}}+{{end}}{{printf "%.1f%%" .CoverageImpact}}</span>
                    <span class="prs">{{.PRsContributed}} PRs</span>
                </div>
                {{end}}
            </div>
        </section>
        {{end}}

        <!-- Footer -->
        <footer class="dashboard-footer">
            <div class="footer-content">
                <div class="generated-info">
                    Generated at {{.Data.GeneratedAt.Format "2006-01-02 15:04:05 MST"}}
                    | Auto-refresh every {{.Data.RefreshInterval}}
                </div>
                <div class="footer-links">
                    <a href="#" onclick="showHelp()">Help</a>
                    <a href="#" onclick="showSettings()">Settings</a>
                    <a href="#" onclick="showAPI()">API</a>
                </div>
            </div>
        </footer>
    </div>

    <script>
        {{ template "dashboard-scripts" . }}
    </script>
</body>
</html>

{{ define "dashboard-styles" }}
/* Dashboard Styles */
:root {
    --primary-color: #0366d6;
    --secondary-color: #586069;
    --success-color: #28a745;
    --warning-color: #ffc107;
    --danger-color: #dc3545;
    --info-color: #17a2b8;
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --border-color: #e1e4e8;
    --shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
}

.theme-dark {
    --primary-color: #58a6ff;
    --secondary-color: #8b949e;
    --light-color: #21262d;
    --dark-color: #f0f6fc;
    --border-color: #30363d;
    --shadow: 0 1px 3px rgba(0,0,0,0.24), 0 1px 2px rgba(0,0,0,0.48);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background-color: var(--light-color);
    color: var(--dark-color);
    line-height: 1.5;
}

.dashboard-container {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.dashboard-header {
    background: white;
    border-bottom: 1px solid var(--border-color);
    box-shadow: var(--shadow);
    position: sticky;
    top: 0;
    z-index: 100;
}

.header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.dashboard-title {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--primary-color);
}

.header-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.time-range-selector select,
.refresh-btn,
.export-btn {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: white;
    cursor: pointer;
    font-size: 0.875rem;
}

.refresh-btn:hover,
.export-btn:hover {
    background-color: var(--light-color);
}

.export-controls {
    display: flex;
    gap: 0.5rem;
}

.metrics-overview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
}

.metric-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: var(--shadow);
    text-align: center;
}

.metric-card.primary {
    background: linear-gradient(135deg, var(--primary-color), #4c9aff);
    color: white;
    border: none;
}

.metric-value {
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
}

.metric-label {
    font-size: 0.875rem;
    opacity: 0.8;
    margin-bottom: 0.25rem;
}

.metric-change {
    font-size: 0.75rem;
    font-weight: 600;
}

.metric-change.positive {
    color: var(--success-color);
}

.metric-change.negative {
    color: var(--danger-color);
}

.quality-gates {
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
}

.quality-gates h2 {
    margin-bottom: 1rem;
    color: var(--secondary-color);
}

.gates-overview {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
    box-shadow: var(--shadow);
}

.gate-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
}

.gate-status.passed {
    color: var(--success-color);
}

.gate-status.failed {
    color: var(--danger-color);
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: currentColor;
}

.charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
}

.chart-container {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: var(--shadow);
    overflow: hidden;
}

.chart-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chart-title {
    font-size: 1.1rem;
    font-weight: 600;
}

.chart-meta {
    font-size: 0.75rem;
    color: var(--secondary-color);
}

.chart-content {
    padding: 1rem;
}

.predictions-section,
.recent-activity,
.notifications-status,
.team-analytics {
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
}

.predictions-section h2,
.recent-activity h2,
.notifications-status h2,
.team-analytics h2 {
    margin-bottom: 1rem;
    color: var(--secondary-color);
}

.predictions-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}

.prediction-card {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
    box-shadow: var(--shadow);
    text-align: center;
}

.prediction-timeframe {
    font-size: 0.875rem;
    color: var(--secondary-color);
    margin-bottom: 0.5rem;
}

.prediction-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--primary-color);
    margin-bottom: 0.25rem;
}

.prediction-confidence {
    font-size: 0.75rem;
    color: var(--secondary-color);
}

.activity-list {
    background: white;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: var(--shadow);
    overflow: hidden;
}

.activity-item {
    display: flex;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.activity-item:last-child {
    border-bottom: none;
}

.activity-timestamp {
    font-size: 0.75rem;
    color: var(--secondary-color);
    min-width: 80px;
}

.activity-content {
    flex: 1;
}

.activity-title {
    font-weight: 600;
    margin-bottom: 0.25rem;
}

.activity-description {
    font-size: 0.875rem;
    color: var(--secondary-color);
}

.activity-impact {
    font-size: 0.75rem;
    font-weight: 600;
    margin-top: 0.25rem;
    color: var(--primary-color);
}

.dashboard-footer {
    background: white;
    border-top: 1px solid var(--border-color);
    margin-top: auto;
    padding: 1rem 2rem;
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.875rem;
    color: var(--secondary-color);
}

.footer-links {
    display: flex;
    gap: 1rem;
}

.footer-links a {
    color: var(--primary-color);
    text-decoration: none;
}

.footer-links a:hover {
    text-decoration: underline;
}

@media (max-width: 768px) {
    .header-content {
        flex-direction: column;
        gap: 1rem;
    }
    
    .charts-grid {
        grid-template-columns: 1fr;
    }
    
    .footer-content {
        flex-direction: column;
        gap: 0.5rem;
    }
}
{{ end }}

{{ define "dashboard-scripts" }}
// Dashboard JavaScript
let dashboardData = {{.Data | json}};
let refreshTimer;

function updateTimeRange() {
    const select = document.getElementById('timeRange');
    const selectedRange = select.value;
    
    // Update URL parameters
    const url = new URL(window.location);
    url.searchParams.set('range', selectedRange);
    window.history.pushState({}, '', url);
    
    // Reload dashboard data
    loadDashboard({
        time_range: {
            preset: selectedRange,
            custom: selectedRange === 'custom'
        }
    });
}

function refreshDashboard() {
    const btn = document.querySelector('.refresh-btn');
    btn.disabled = true;
    btn.innerHTML = 'â³ Refreshing...';
    
    loadDashboard({refresh_cache: true}).finally(() => {
        btn.disabled = false;
        btn.innerHTML = 'ðŸ”„ Refresh';
    });
}

function exportData(format) {
    const url = '/api/export?format=' + format + '&' + new URLSearchParams(window.location.search);
    window.open(url, '_blank');
}

function loadDashboard(params = {}) {
    const queryParams = new URLSearchParams({
        ...Object.fromEntries(new URLSearchParams(window.location.search)),
        ...params
    });
    
    return fetch('/api/dashboard?' + queryParams)
        .then(response => response.json())
        .then(data => {
            dashboardData = data;
            updateDashboardContent(data);
        })
        .catch(error => {
            console.error('Failed to load dashboard:', error);
            showError('Failed to load dashboard data');
        });
}

function updateDashboardContent(data) {
    // Update metrics
    updateMetrics(data.current_metrics);
    
    // Update charts
    updateCharts(data.charts);
    
    // Update activity
    updateActivity(data.recent_activity);
    
    // Update timestamp
    document.querySelector('.generated-info').textContent = 
        'Generated at ' + new Date(data.generated_at).toLocaleString() + ' | Auto-refresh every ' + formatDuration(data.refresh_interval);
}

function updateMetrics(metrics) {
    if (!metrics) return;
    
    const coverageValue = document.querySelector('.metric-card.primary .metric-value');
    const coverageChange = document.querySelector('.metric-card.primary .metric-change');
    
    if (coverageValue) {
        coverageValue.textContent = metrics.coverage.toFixed(1) + '%';
    }
    
    if (coverageChange) {
        const change = metrics.coverage_change;
        coverageChange.textContent = (change > 0 ? '+' : '') + change.toFixed(1) + '%';
        coverageChange.className = 'metric-change ' + (change < 0 ? 'negative' : 'positive');
    }
}

function updateCharts(charts) {
    if (!charts) return;
    
    charts.forEach(chart => {
        const container = document.querySelector('[data-chart-id="' + chart.id + '"] .chart-content');
        if (container) {
            container.innerHTML = chart.svg_content;
        }
    });
}

function updateActivity(activities) {
    if (!activities) return;
    
    const activityList = document.querySelector('.activity-list');
    if (activityList) {
        activityList.innerHTML = activities.map(activity => 
            '<div class="activity-item ' + activity.type + '">' +
                '<div class="activity-timestamp">' + new Date(activity.timestamp).toLocaleDateString() + '</div>' +
                '<div class="activity-content">' +
                    '<div class="activity-title">' + activity.title + '</div>' +
                    '<div class="activity-description">' + activity.description + '</div>' +
                    (activity.coverage_change ? '<div class="activity-impact">Coverage change: ' + (activity.coverage_change > 0 ? '+' : '') + activity.coverage_change.toFixed(1) + '%</div>' : '') +
                '</div>' +
            '</div>'
        ).join('');
    }
}

function formatDuration(seconds) {
    if (seconds < 60) return seconds + 's';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
    return Math.floor(seconds / 3600) + 'h';
}

function showError(message) {
    // Create and show error notification
    const notification = document.createElement('div');
    notification.className = 'error-notification';
    notification.textContent = message;
    notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--danger-color); color: white; padding: 1rem; border-radius: 4px; box-shadow: var(--shadow); z-index: 1000;';
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 5000);
}

function showHelp() {
    alert('Dashboard Help:\n\n' +
          'â€¢ Use time range selector to change data period\n' +
          'â€¢ Click refresh to update data manually\n' +
          'â€¢ Export buttons download data in different formats\n' +
          'â€¢ Charts are interactive - hover for details');
}

function showSettings() {
    alert('Settings panel coming soon!');
}

function showAPI() {
    window.open('/api/docs', '_blank');
}

// Auto-refresh functionality
function startAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    
    const interval = dashboardData.refresh_interval * 1000; // Convert to milliseconds
    refreshTimer = setInterval(() => {
        loadDashboard();
    }, interval);
}

// Initialize dashboard
document.addEventListener('DOMContentLoaded', function() {
    // Start auto-refresh
    startAutoRefresh();
    
    // Handle visibility change (pause refresh when tab is hidden)
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            if (refreshTimer) clearInterval(refreshTimer);
        } else {
            startAutoRefresh();
        }
    });
    
    // Load initial data if URL has parameters
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('range') || urlParams.has('refresh')) {
        loadDashboard();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (refreshTimer) clearInterval(refreshTimer);
});
{{ end }}
`
	
	t, err := template.New("dashboard").Funcs(template.FuncMap{
		"json": func(v interface{}) string {
			b, _ := json.Marshal(v)
			return string(b)
		},
		"mul": func(a, b float64) float64 {
			return a * b
		},
	}).Parse(tmpl)
	
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}
	
	var buf strings.Builder
	err = t.Execute(&buf, map[string]interface{}{
		"Config": d.config,
		"Data":   data,
	})
	
	if err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}
	
	return buf.String(), nil
	*/
}

// Helper methods for generating dashboard data

func (d *AnalyticsDashboard) generateCurrentMetrics(ctx context.Context, data *DashboardData) error {
	// This would typically fetch real data from the coverage system
	data.CurrentMetrics = CurrentMetrics{
		Coverage:       78.5,
		CoverageChange: 2.3,
		TrendDirection: "ðŸ“ˆ Upward",
		TrendStrength:  "Strong",
		LastUpdated:    time.Now().Add(-5 * time.Minute),
		TotalTests:     1247,
		PassingTests:   1247,
		TotalLines:     15420,
		CoveredLines:   12105,
		QualityScore:   8.7,
	}
	
	return nil
}

func (d *AnalyticsDashboard) generateTrendAnalysis(ctx context.Context, data *DashboardData, request *DashboardRequest) error {
	if d.historyAnalyzer == nil {
		return nil
	}
	
	// Generate trend analysis using the history analyzer
	trendReport, err := d.historyAnalyzer.AnalyzeTrends(ctx)
	if err != nil {
		return fmt.Errorf("failed to analyze trends: %w", err)
	}
	
	data.TrendAnalysis = trendReport
	return nil
}

func (d *AnalyticsDashboard) generatePredictions(ctx context.Context, data *DashboardData) error {
	if d.predictor == nil {
		return nil
	}
	
	// Generate predictions using the prediction engine
	prediction, err := d.predictor.PredictCoverage(ctx)
	if err != nil {
		return fmt.Errorf("failed to generate predictions: %w", err)
	}
	
	data.Predictions = append(data.Predictions, PredictionSummary{
		TimeHorizon:       24 * time.Hour,
		PredictedCoverage: prediction.PredictedCoverage,
		Confidence:        prediction.Confidence,
		Scenario:          "current_trend",
		TrendIndicator:    "ðŸ“ˆ",
	})
	
	// Add longer-term predictions
	data.Predictions = append(data.Predictions, PredictionSummary{
		TimeHorizon:       7 * 24 * time.Hour,
		PredictedCoverage: prediction.PredictedCoverage + 1.2,
		Confidence:        prediction.Confidence * 0.85,
		Scenario:          "optimistic",
		TrendIndicator:    "ðŸ“ˆ",
	})
	
	return nil
}

func (d *AnalyticsDashboard) generateCharts(ctx context.Context, data *DashboardData, request *DashboardRequest) error {
	if d.chartGenerator == nil {
		return nil
	}
	
	// Generate coverage trend chart
	if d.historyAnalyzer != nil {
		chartData := &charts.ChartData{
			Title:      "Coverage Trend",
			XAxisLabel: "Time",
			YAxisLabel: "Coverage %",
			Points:     make([]charts.DataPoint, 0),
		}
		
		// Generate sample data points for the chart
		now := time.Now()
		for i := 30; i >= 0; i-- {
			chartData.Points = append(chartData.Points, charts.DataPoint{
				Timestamp: now.AddDate(0, 0, -i),
				Value:     75.0 + float64(i%10)*1.5 + (float64(30-i) * 0.1),
				Label:     fmt.Sprintf("Day %d", 30-i),
			})
		}
		
		svgContent, err := d.chartGenerator.GenerateTrendChart(ctx, chartData)
		if err == nil {
			data.Charts = append(data.Charts, ChartData{
				ID:          "coverage-trend",
				Title:       "Coverage Trend (30 Days)",
				Type:        charts.ChartTrendLine,
				SVGContent:  svgContent,
				DataPoints:  len(chartData.Points),
				LastUpdated: time.Now(),
			})
		}
	}
	
	// Generate test count chart
	testChartData := &charts.ChartData{
		Title:      "Test Count Trend",
		XAxisLabel: "Time",
		YAxisLabel: "Number of Tests",
		Points:     make([]charts.DataPoint, 0),
	}
	
	now := time.Now()
	for i := 14; i >= 0; i-- {
		testChartData.Points = append(testChartData.Points, charts.DataPoint{
			Timestamp: now.AddDate(0, 0, -i),
			Value:     1200 + float64(i%5)*20 + (float64(14-i) * 2),
			Label:     fmt.Sprintf("Day %d", 14-i),
		})
	}
	
	svgContent, err := d.chartGenerator.GenerateAreaChart(ctx, testChartData)
	if err == nil {
		data.Charts = append(data.Charts, ChartData{
			ID:          "test-count",
			Title:       "Test Count Growth",
			Type:        charts.ChartAreaChart,
			SVGContent:  svgContent,
			DataPoints:  len(testChartData.Points),
			LastUpdated: time.Now(),
		})
	}
	
	return nil
}

func (d *AnalyticsDashboard) generateRecentActivity(ctx context.Context, data *DashboardData, request *DashboardRequest) error {
	// Generate sample recent activity
	activities := []ActivityItem{
		{
			Timestamp:      time.Now().Add(-30 * time.Minute),
			Type:           ActivityPRMerged,
			Title:          "PR #123 merged",
			Description:    "Add comprehensive unit tests for user authentication",
			Impact:         "positive",
			Author:         "alice",
			PRNumber:       123,
			CoverageChange: 2.3,
		},
		{
			Timestamp:      time.Now().Add(-2 * time.Hour),
			Type:           ActivityCoverageUpdate,
			Title:          "Coverage milestone reached",
			Description:    "Project coverage exceeded 75% for the first time",
			Impact:         "milestone",
			CoverageChange: 0.8,
		},
		{
			Timestamp:      time.Now().Add(-4 * time.Hour),
			Type:           ActivityPROpened,
			Title:          "PR #124 opened",
			Description:    "Refactor payment processing module",
			Impact:         "neutral",
			Author:         "bob",
			PRNumber:       124,
		},
		{
			Timestamp:      time.Now().Add(-6 * time.Hour),
			Type:           ActivityQualityGate,
			Title:          "Quality gate passed",
			Description:    "All quality gates passed for main branch",
			Impact:         "positive",
		},
	}
	
	// Sort by timestamp (most recent first)
	sort.Slice(activities, func(i, j int) bool {
		return activities[i].Timestamp.After(activities[j].Timestamp)
	})
	
	data.RecentActivity = activities
	return nil
}

func (d *AnalyticsDashboard) generateNotificationStatus(ctx context.Context, data *DashboardData) error {
	if d.notifier == nil {
		return nil
	}
	
	// Get notification system status
	channelStatus := d.notifier.GetChannelStatus()
	activeChannels := make([]string, 0)
	channelHealth := make(map[string]bool)
	
	for channelType, healthy := range channelStatus {
		channelName := string(channelType)
		channelHealth[channelName] = healthy
		if healthy {
			activeChannels = append(activeChannels, channelName)
		}
	}
	
	data.NotificationStatus = &NotificationStatus{
		Enabled:          true,
		ActiveChannels:   activeChannels,
		LastNotification: time.Now().Add(-15 * time.Minute),
		PendingEvents:    2,
		ChannelHealth:    channelHealth,
	}
	
	return nil
}

func (d *AnalyticsDashboard) generateTeamAnalytics(ctx context.Context, data *DashboardData) error {
	// Generate sample team analytics
	data.TeamAnalytics = &TeamAnalytics{
		TotalMembers:      8,
		ActiveContributors: 6,
		AvgContribution:   12.5,
		TopContributors: []Contributor{
			{
				Name:             "alice",
				CoverageImpact:   8.2,
				PRsContributed:   15,
				QualityScore:     9.1,
				LastContribution: time.Now().Add(-30 * time.Minute),
			},
			{
				Name:             "bob",
				CoverageImpact:   5.7,
				PRsContributed:   12,
				QualityScore:     8.5,
				LastContribution: time.Now().Add(-2 * time.Hour),
			},
			{
				Name:             "charlie",
				CoverageImpact:   4.1,
				PRsContributed:   8,
				QualityScore:     8.2,
				LastContribution: time.Now().Add(-4 * time.Hour),
			},
		},
		CoverageByTeam: map[string]float64{
			"backend":  82.1,
			"frontend": 74.3,
			"mobile":   69.8,
			"infra":    91.2,
		},
	}
	
	return nil
}

func (d *AnalyticsDashboard) generateQualityGates(ctx context.Context, data *DashboardData) error {
	// Generate sample quality gate status
	gateDetails := map[string]GateDetail{
		"minimum_coverage": {
			Name:         "Minimum Coverage",
			Status:       "passed",
			CurrentValue: 78.5,
			Threshold:    70.0,
			LastChecked:  time.Now().Add(-5 * time.Minute),
			Trend:        "improving",
		},
		"coverage_regression": {
			Name:         "Coverage Regression",
			Status:       "passed",
			CurrentValue: 2.3,
			Threshold:    -5.0,
			LastChecked:  time.Now().Add(-5 * time.Minute),
			Trend:        "stable",
		},
		"test_success_rate": {
			Name:         "Test Success Rate",
			Status:       "passed",
			CurrentValue: 100.0,
			Threshold:    95.0,
			LastChecked:  time.Now().Add(-5 * time.Minute),
			Trend:        "stable",
		},
	}
	
	passedGates := 0
	totalGates := len(gateDetails)
	failedGates := make([]string, 0)
	
	for name, gate := range gateDetails {
		if gate.Status == "passed" {
			passedGates++
		} else {
			failedGates = append(failedGates, name)
		}
	}
	
	overallStatus := "passed"
	if len(failedGates) > 0 {
		overallStatus = "failed"
	}
	
	data.QualityGates = QualityGateStatus{
		OverallStatus: overallStatus,
		PassedGates:   passedGates,
		TotalGates:    totalGates,
		FailedGates:   failedGates,
		GateDetails:   gateDetails,
	}
	
	return nil
}

// GetDashboardSummary returns a concise summary of dashboard status
func (d *AnalyticsDashboard) GetDashboardSummary(ctx context.Context) (map[string]interface{}, error) {
	request := &DashboardRequest{
		TimeRange: d.config.DefaultTimeRange,
		IncludePredictions: d.config.EnablePredictions,
		IncludeTeamData:    false, // Skip team data for summary
	}
	
	data, err := d.GenerateDashboard(ctx, request)
	if err != nil {
		return nil, err
	}
	
	summary := map[string]interface{}{
		"current_coverage":    data.CurrentMetrics.Coverage,
		"coverage_change":     data.CurrentMetrics.CoverageChange,
		"trend_direction":     data.CurrentMetrics.TrendDirection,
		"quality_gates_passed": data.QualityGates.PassedGates,
		"total_quality_gates":  data.QualityGates.TotalGates,
		"last_updated":        data.GeneratedAt,
	}
	
	if len(data.Predictions) > 0 {
		summary["predicted_coverage"] = data.Predictions[0].PredictedCoverage
		summary["prediction_confidence"] = data.Predictions[0].Confidence
	}
	
	if data.NotificationStatus != nil {
		summary["notifications_enabled"] = data.NotificationStatus.Enabled
		summary["active_channels"] = len(data.NotificationStatus.ActiveChannels)
	}
	
	return summary, nil
}