// Package pages provides GitHub Pages deployment functionality for coverage reports.
package pages

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// Static errors
var (
	// ErrBranchExists indicates the branch already exists
	ErrBranchExists = errors.New("branch already exists")
	// ErrInvalidBranchName indicates the branch name is invalid
	ErrInvalidBranchName = errors.New("invalid branch name")
	// ErrUnsupportedURLFormat indicates an unsupported remote URL format
	ErrUnsupportedURLFormat = errors.New("unsupported remote URL format")
)

// GitHubPagesDeployer handles deployment to GitHub Pages
type GitHubPagesDeployer struct {
	repoPath    string
	pagesBranch string
	verbose     bool
}

// NewGitHubPagesDeployer creates a new GitHub Pages deployer
func NewGitHubPagesDeployer(repoPath, pagesBranch string, verbose bool) *GitHubPagesDeployer {
	if pagesBranch == "" {
		pagesBranch = "gh-pages"
	}
	return &GitHubPagesDeployer{
		repoPath:    repoPath,
		pagesBranch: pagesBranch,
		verbose:     verbose,
	}
}

// Setup initializes the GitHub Pages branch with proper structure
func (d *GitHubPagesDeployer) Setup(ctx context.Context, force bool) error {
	// Check if gh-pages branch exists
	exists, err := d.branchExists(ctx)
	if err != nil {
		return fmt.Errorf("checking branch existence: %w", err)
	}

	if exists && !force {
		return fmt.Errorf("%w: %q (use --force to override)", ErrBranchExists, d.pagesBranch)
	}

	// Create orphan branch
	if err := d.createOrphanBranch(ctx); err != nil {
		return fmt.Errorf("creating orphan branch: %w", err)
	}

	// Configure git identity for commits
	if err := d.configureGitIdentity(ctx); err != nil {
		return fmt.Errorf("configuring git identity: %w", err)
	}

	// Create directory structure
	dirs := []string{
		"badges",
		"badges/pr",
		"reports",
		"reports/pr",
		"reports/branch",
		"coverage",
		"assets",
		"assets/css",
		"assets/js",
		"assets/fonts",
		"api",
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o750); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}

		// Create .gitkeep to preserve empty directories
		gitkeepPath := filepath.Join(dir, ".gitkeep")
		if err := os.WriteFile(gitkeepPath, []byte(""), 0o600); err != nil {
			return fmt.Errorf("creating .gitkeep in %s: %w", dir, err)
		}
	}

	// Create initial dashboard
	if err := d.createInitialDashboard(); err != nil {
		return fmt.Errorf("creating initial dashboard: %w", err)
	}

	// Create README for gh-pages
	readme := `# Coverage Dashboard

This branch hosts the coverage dashboard and reports for this repository.

- **Dashboard**: https://{owner}.github.io/{repo}/
- **Coverage Badge**: https://{owner}.github.io/{repo}/badges/main.svg
- **Reports**: https://{owner}.github.io/{repo}/reports/

Generated by GoFortress Coverage System.
`
	if err := os.WriteFile("README.md", []byte(readme), 0o600); err != nil {
		return fmt.Errorf("creating README: %w", err)
	}

	// Commit and push
	if err := d.commitAndPush(ctx, "üöÄ Initialize GitHub Pages structure"); err != nil {
		return fmt.Errorf("committing initial structure: %w", err)
	}

	return nil
}

// Deploy deploys coverage artifacts to GitHub Pages
func (d *GitHubPagesDeployer) Deploy(ctx context.Context, opts DeployOptions) error {
	// Create temporary directory for git operations
	tempDir, err := os.MkdirTemp("", "coverage-deploy-*")
	if err != nil {
		return fmt.Errorf("creating temp directory: %w", err)
	}
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()

	// Clone gh-pages branch
	if cloneErr := d.clonePagesBranch(ctx, tempDir); cloneErr != nil {
		return fmt.Errorf("cloning pages branch: %w", cloneErr)
	}

	// Change to cloned directory
	originalDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getting current directory: %w", err)
	}

	if chdirErr := os.Chdir(tempDir); chdirErr != nil {
		return fmt.Errorf("changing to temp directory: %w", chdirErr)
	}
	defer func() {
		_ = os.Chdir(originalDir)
	}()

	// Configure git identity for commits
	if err := d.configureGitIdentity(ctx); err != nil {
		return fmt.Errorf("configuring git identity: %w", err)
	}

	// Copy artifacts based on type (PR or branch)
	if opts.PRNumber != "" {
		if err := d.deployPRArtifacts(opts); err != nil {
			return fmt.Errorf("deploying PR artifacts: %w", err)
		}
	} else {
		if err := d.deployBranchArtifacts(opts); err != nil {
			return fmt.Errorf("deploying branch artifacts: %w", err)
		}
	}

	// Update main dashboard if this is main/master branch
	if opts.Branch == "main" || opts.Branch == "master" {
		if err := d.updateMainDashboard(opts); err != nil {
			return fmt.Errorf("updating main dashboard: %w", err)
		}
	}

	// Commit and push changes
	message := opts.Message
	if message == "" {
		if opts.PRNumber != "" {
			message = fmt.Sprintf("üìä Update coverage for PR #%s", opts.PRNumber)
		} else {
			message = fmt.Sprintf("üìä Update coverage for %s branch", opts.Branch)
		}
	}

	if err := d.commitAndPush(ctx, message); err != nil {
		return fmt.Errorf("committing changes: %w", err)
	}

	return nil
}

// Clean removes old PR data and expired content
func (d *GitHubPagesDeployer) Clean(ctx context.Context, opts CleanOptions) error {
	// Clone gh-pages branch
	tempDir, err := os.MkdirTemp("", "coverage-clean-*")
	if err != nil {
		return fmt.Errorf("creating temp directory: %w", err)
	}
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()

	if cloneErr := d.clonePagesBranch(ctx, tempDir); cloneErr != nil {
		return fmt.Errorf("cloning pages branch: %w", cloneErr)
	}

	// Change to cloned directory
	originalDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getting current directory: %w", err)
	}

	if chdirErr := os.Chdir(tempDir); chdirErr != nil {
		return fmt.Errorf("changing to temp directory: %w", chdirErr)
	}
	defer func() {
		_ = os.Chdir(originalDir)
	}()

	// Configure git identity for commits
	if identityErr := d.configureGitIdentity(ctx); identityErr != nil {
		return fmt.Errorf("configuring git identity: %w", identityErr)
	}

	// Find and remove expired PR directories
	prDirs, err := filepath.Glob("*/pr/*")
	if err != nil {
		return fmt.Errorf("finding PR directories: %w", err)
	}

	removed := []string{}
	cutoffTime := time.Now().AddDate(0, 0, -opts.MaxAgeDays)

	for _, dir := range prDirs {
		info, err := os.Stat(dir)
		if err != nil {
			continue
		}

		if info.ModTime().Before(cutoffTime) {
			if !opts.DryRun {
				if err := os.RemoveAll(dir); err != nil {
					return fmt.Errorf("removing %s: %w", dir, err)
				}
			}
			removed = append(removed, dir)
		}
	}

	if len(removed) > 0 && !opts.DryRun {
		message := fmt.Sprintf("üßπ Clean up %d expired PR directories", len(removed))
		if err := d.commitAndPush(ctx, message); err != nil {
			return fmt.Errorf("committing cleanup: %w", err)
		}
	}

	return nil
}

// Helper methods

func (d *GitHubPagesDeployer) branchExists(ctx context.Context) (bool, error) {
	// Validate branch name to prevent command injection
	if d.pagesBranch == "" || strings.ContainsAny(d.pagesBranch, ";&|<>$`") {
		return false, fmt.Errorf("%w: %q", ErrInvalidBranchName, d.pagesBranch)
	}

	cmd := exec.CommandContext(ctx, "git", "ls-remote", "--heads", "origin", d.pagesBranch) //nolint:gosec // branch name validated
	output, err := cmd.Output()
	if err != nil {
		return false, err
	}
	return len(output) > 0, nil
}

func (d *GitHubPagesDeployer) createOrphanBranch(ctx context.Context) error {
	// Create orphan branch (branch name already validated in branchExists)
	cmd := exec.CommandContext(ctx, "git", "checkout", "--orphan", d.pagesBranch) //nolint:gosec // branch validated
	if err := d.runCommand(cmd); err != nil {
		return err
	}

	// Remove all files from index
	cmd = exec.CommandContext(ctx, "git", "rm", "-rf", ".")
	_ = d.runCommand(cmd) // Ignore error if no files to remove

	return nil
}

func (d *GitHubPagesDeployer) clonePagesBranch(ctx context.Context, destDir string) error {
	// Get remote URL
	cmd := exec.CommandContext(ctx, "git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("getting remote URL: %w", err)
	}
	remoteURL := strings.TrimSpace(string(output))

	// Get GitHub token with fallback mechanism (GH_PAT_TOKEN || GITHUB_TOKEN)
	token := d.getGitHubToken()
	if token != "" {
		// Convert HTTPS URL to authenticated URL
		if authenticatedURL, authErr := d.addTokenToURL(remoteURL, token); authErr == nil {
			remoteURL = authenticatedURL
			if d.verbose {
				fmt.Printf("üîê Using authenticated URL for git operations\n") //nolint:forbidigo // CLI output
			}
		} else if d.verbose {
			fmt.Printf("‚ö†Ô∏è Could not add token to URL, using original: %v\n", authErr) //nolint:forbidigo // CLI output
		}
	} else if d.verbose {
		fmt.Printf("‚ö†Ô∏è No GitHub token found, using unauthenticated URL\n") //nolint:forbidigo // CLI output
	}

	// Clone only gh-pages branch
	cmd = exec.CommandContext(ctx, "git", "clone", //nolint:gosec // inputs validated
		"--single-branch",
		"--branch", d.pagesBranch,
		"--depth", "1",
		remoteURL, destDir)

	return d.runCommand(cmd)
}

func (d *GitHubPagesDeployer) deployPRArtifacts(opts DeployOptions) error {
	prDir := filepath.Join("pr", opts.PRNumber)

	// Create PR directory structure
	dirs := []string{
		filepath.Join("badges", prDir),
		filepath.Join("reports", prDir),
		filepath.Join("coverage", prDir),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o750); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}
	}

	// Copy artifacts from input directory
	return d.copyArtifacts(opts.InputDir, prDir)
}

func (d *GitHubPagesDeployer) deployBranchArtifacts(opts DeployOptions) error {
	// Sanitize branch name for filesystem
	safeBranch := strings.ReplaceAll(opts.Branch, "/", "-")

	// Copy main artifacts
	if err := d.copyArtifacts(opts.InputDir, ""); err != nil {
		return err
	}

	// Also copy to branch-specific location
	branchDir := filepath.Join("reports", "branch", safeBranch)
	if err := os.MkdirAll(branchDir, 0o750); err != nil {
		return fmt.Errorf("creating branch directory: %w", err)
	}

	return d.copyArtifacts(opts.InputDir, branchDir)
}

func (d *GitHubPagesDeployer) copyArtifacts(srcDir, destPrefix string) error {
	// Copy coverage.svg to badges directory
	srcBadge := filepath.Join(srcDir, "coverage.svg")
	if _, err := os.Stat(srcBadge); err == nil {
		destBadge := "badges/coverage.svg"
		if destPrefix != "" {
			destBadge = filepath.Join("badges", destPrefix, "coverage.svg")
		}
		if err := d.copyFile(srcBadge, destBadge); err != nil {
			return fmt.Errorf("copying badge: %w", err)
		}
	}

	// Copy HTML report
	srcReport := filepath.Join(srcDir, "coverage.html")
	if _, err := os.Stat(srcReport); err == nil {
		destReport := "reports/coverage.html"
		if destPrefix != "" {
			destReport = filepath.Join("reports", destPrefix, "coverage.html")
		}
		if err := d.copyFile(srcReport, destReport); err != nil {
			return fmt.Errorf("copying report: %w", err)
		}
	}

	// Copy any dashboard files
	srcDashboard := filepath.Join(srcDir, "dashboard.html")
	if _, err := os.Stat(srcDashboard); err == nil {
		destDashboard := "coverage/index.html"
		if destPrefix != "" {
			destDashboard = filepath.Join("coverage", destPrefix, "index.html")
		}
		if err := d.copyFile(srcDashboard, destDashboard); err != nil {
			return fmt.Errorf("copying dashboard: %w", err)
		}
	}

	return nil
}

func (d *GitHubPagesDeployer) updateMainDashboard(opts DeployOptions) error {
	// Copy the dashboard.html to root index.html for main branch
	srcDashboard := filepath.Join(opts.InputDir, "dashboard.html")
	if _, err := os.Stat(srcDashboard); err == nil {
		if err := d.copyFile(srcDashboard, "index.html"); err != nil {
			return fmt.Errorf("copying dashboard to index.html: %w", err)
		}
	}

	// Also update the coverage subdirectory
	if err := d.copyFile(srcDashboard, "coverage/index.html"); err != nil {
		return fmt.Errorf("copying dashboard to coverage/index.html: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) createInitialDashboard() error {
	dashboardHTML := d.generateInitialDashboardHTML()

	// Write to index.html
	if err := os.WriteFile("index.html", []byte(dashboardHTML), 0o600); err != nil {
		return fmt.Errorf("writing index.html: %w", err)
	}

	// Also write to coverage/index.html
	if err := os.MkdirAll("coverage", 0o750); err != nil {
		return fmt.Errorf("creating coverage directory: %w", err)
	}

	if err := os.WriteFile("coverage/index.html", []byte(dashboardHTML), 0o600); err != nil {
		return fmt.Errorf("writing coverage/index.html: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) generateInitialDashboardHTML() string {
	return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè∞ GoFortress Coverage Dashboard</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --text-accent: #58a6ff;
            --border-color: #30363d;
            --success-color: #238636;
            --warning-color: #d29922;
            --danger-color: #da3633;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            font-size: 3rem;
            color: var(--text-accent);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .header .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .metric-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }
        
        .metric-card h3 {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .status-message {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .status-message h2 {
            color: var(--text-accent);
            margin-bottom: 1rem;
        }
        
        .footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            border-top: 1px solid var(--border-color);
            margin-top: 3rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üè∞ GoFortress Coverage Dashboard</h1>
            <p class="subtitle">Coverage tracking and reporting for your Go projects</p>
        </header>
        
        <main>
            <div class="status-message">
                <h2>üöÄ Welcome to GoFortress Coverage!</h2>
                <p>Your coverage dashboard is ready. Coverage data will appear here after your first CI run.</p>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <h3>üìä Coverage Reports</h3>
                    <p>Detailed HTML coverage reports will be available at <code>/reports/</code> after your first build.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üè∑Ô∏è Coverage Badges</h3>
                    <p>Dynamic SVG badges for your README will be available at <code>/badges/main.svg</code>.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üîÄ PR Analysis</h3>
                    <p>Pull request coverage analysis will be stored at <code>/pr/{number}/</code>.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üìà Trend Analysis</h3>
                    <p>Historical coverage trends and analytics will be displayed here.</p>
                </div>
            </div>
        </main>
        
        <footer class="footer">
            <p>üìä Generated by <strong>GoFortress Coverage System</strong></p>
            <p>Self-contained, Go-native coverage tracking with zero external dependencies</p>
        </footer>
    </div>
</body>
</html>`
}

// configureGitIdentity sets up git user identity for commits
func (d *GitHubPagesDeployer) configureGitIdentity(ctx context.Context) error {
	var userName, userEmail string

	// Detect environment and set appropriate identity
	if os.Getenv("GITHUB_ACTIONS") == "true" {
		// GitHub Actions environment - use GitHub Actions bot
		userName = "github-actions[bot]"
		userEmail = "41898282+github-actions[bot]@users.noreply.github.com"
		if d.verbose {
			fmt.Println("ü§ñ Detected GitHub Actions environment, using bot identity") //nolint:forbidigo // CLI output
		}
	} else if os.Getenv("CI") == "true" {
		// Generic CI environment
		userName = "CI Bot"
		userEmail = "ci-bot@users.noreply.github.com"
		if d.verbose {
			fmt.Println("ü§ñ Detected CI environment, using generic bot identity") //nolint:forbidigo // CLI output
		}
	} else {
		// Local development - check if git config exists
		cmd := exec.CommandContext(ctx, "git", "config", "--get", "user.name")
		if output, err := cmd.Output(); err == nil && len(output) > 0 {
			// User already has git config, skip configuration
			if d.verbose {
				fmt.Println("‚úÖ Git identity already configured") //nolint:forbidigo // CLI output
			}
			return nil
		}
		// Use default values for local development
		userName = "GoFortress Coverage"
		userEmail = "coverage@gofortress.local"
		if d.verbose {
			fmt.Println("üíª Local environment, using default identity") //nolint:forbidigo // CLI output
		}
	}

	// Configure git user name
	cmd := exec.CommandContext(ctx, "git", "config", "user.name", userName) //nolint:gosec // userName is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("setting git user name: %w", err)
	}

	// Configure git user email
	cmd = exec.CommandContext(ctx, "git", "config", "user.email", userEmail) //nolint:gosec // userEmail is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("setting git user email: %w", err)
	}

	if d.verbose {
		fmt.Printf("‚úÖ Git identity configured: %s <%s>\n", userName, userEmail) //nolint:forbidigo // CLI output
	}

	return nil
}

func (d *GitHubPagesDeployer) commitAndPush(ctx context.Context, message string) error {
	// Add all changes
	cmd := exec.CommandContext(ctx, "git", "add", "-A")
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git add: %w", err)
	}

	// Check if there are changes to commit
	cmd = exec.CommandContext(ctx, "git", "diff", "--cached", "--quiet")
	if err := cmd.Run(); err == nil {
		// No changes to commit
		if d.verbose {
			fmt.Println("No changes to commit") //nolint:forbidigo // CLI output
		}
		return nil
	}

	// Commit changes
	cmd = exec.CommandContext(ctx, "git", "commit", "-m", message)
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git commit: %w", err)
	}

	// Ensure origin remote is set with authentication for push
	if err := d.ensureAuthenticatedRemote(ctx); err != nil {
		return fmt.Errorf("setting up authenticated remote: %w", err)
	}

	// Push changes
	cmd = exec.CommandContext(ctx, "git", "push", "origin", d.pagesBranch) //nolint:gosec // branch validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git push: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) copyFile(src, dst string) error {
	// Ensure destination directory exists
	dstDir := filepath.Dir(dst)
	if err := os.MkdirAll(dstDir, 0o750); err != nil {
		return fmt.Errorf("creating destination directory: %w", err)
	}

	// Open source file
	srcFile, err := os.Open(src) //nolint:gosec // caller validates paths
	if err != nil {
		return fmt.Errorf("opening source file: %w", err)
	}
	defer func() {
		_ = srcFile.Close()
	}()

	// Create destination file
	dstFile, err := os.Create(dst) //nolint:gosec // caller validates paths
	if err != nil {
		return fmt.Errorf("creating destination file: %w", err)
	}
	defer func() {
		_ = dstFile.Close()
	}()

	// Copy content
	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return fmt.Errorf("copying file content: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) runCommand(cmd *exec.Cmd) error {
	if d.verbose {
		fmt.Printf("üîß Running: %s\n", strings.Join(cmd.Args, " ")) //nolint:forbidigo // CLI output
	}

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("%w: %s", err, stderr.String())
	}

	return nil
}

// getGitHubToken retrieves GitHub token with fallback mechanism (GH_PAT_TOKEN || GITHUB_TOKEN)
func (d *GitHubPagesDeployer) getGitHubToken() string {
	// Try GH_PAT_TOKEN first (personal access token with broader permissions)
	if token := os.Getenv("GH_PAT_TOKEN"); token != "" {
		if d.verbose {
			fmt.Printf("üîë Using GH_PAT_TOKEN for authentication\n") //nolint:forbidigo // CLI output
		}
		return token
	}

	// Fall back to GITHUB_TOKEN (standard GitHub Actions token)
	if token := os.Getenv("GITHUB_TOKEN"); token != "" {
		if d.verbose {
			fmt.Printf("üîë Using GITHUB_TOKEN for authentication\n") //nolint:forbidigo // CLI output
		}
		return token
	}

	return ""
}

// addTokenToURL converts a Git URL to an authenticated HTTPS URL with the provided token
func (d *GitHubPagesDeployer) addTokenToURL(remoteURL, token string) (string, error) {
	// Handle different URL formats
	if strings.HasPrefix(remoteURL, "git@github.com:") {
		// Convert SSH URL to HTTPS: git@github.com:owner/repo.git -> https://github.com/owner/repo.git
		parts := strings.TrimPrefix(remoteURL, "git@github.com:")
		return fmt.Sprintf("https://x-access-token:%s@github.com/%s", token, parts), nil
	}

	if strings.HasPrefix(remoteURL, "https://github.com/") {
		// Add token to existing HTTPS URL: https://github.com/owner/repo.git -> https://x-access-token:TOKEN@github.com/owner/repo.git
		parts := strings.TrimPrefix(remoteURL, "https://github.com/")
		return fmt.Sprintf("https://x-access-token:%s@github.com/%s", token, parts), nil
	}

	// Return error for unsupported URL formats
	return "", fmt.Errorf("%w: %s", ErrUnsupportedURLFormat, remoteURL)
}

// ensureAuthenticatedRemote ensures the origin remote is set with authentication
func (d *GitHubPagesDeployer) ensureAuthenticatedRemote(ctx context.Context) error {
	// Get GitHub token
	token := d.getGitHubToken()
	if token == "" {
		// No token available, skip authentication setup
		if d.verbose {
			fmt.Printf("‚ö†Ô∏è No GitHub token available for push authentication\n") //nolint:forbidigo // CLI output
		}
		return nil
	}

	// Get current origin URL
	cmd := exec.CommandContext(ctx, "git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("getting origin URL: %w", err)
	}
	currentURL := strings.TrimSpace(string(output))

	// Convert to authenticated URL
	authenticatedURL, err := d.addTokenToURL(currentURL, token)
	if err != nil {
		return fmt.Errorf("converting URL to authenticated: %w", err)
	}

	// Set the authenticated URL as origin
	cmd = exec.CommandContext(ctx, "git", "remote", "set-url", "origin", authenticatedURL) //nolint:gosec // authenticatedURL is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("setting authenticated origin URL: %w", err)
	}

	if d.verbose {
		fmt.Printf("üîê Updated origin remote with authentication\n") //nolint:forbidigo // CLI output
	}

	return nil
}

// DeployOptions contains options for deployment
type DeployOptions struct {
	Branch    string
	CommitSha string
	PRNumber  string
	InputDir  string
	Message   string
	Verbose   bool
}

// CleanOptions contains options for cleanup
type CleanOptions struct {
	MaxAgeDays int
	DryRun     bool
	Verbose    bool
}
