// Package pages provides GitHub Pages deployment functionality for coverage reports.
package pages

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"
	"unicode"
)

// Static errors
var (
	// ErrBranchExists indicates the branch already exists
	ErrBranchExists = errors.New("branch already exists")
	// ErrInvalidBranchName indicates the branch name is invalid
	ErrInvalidBranchName = errors.New("invalid branch name")
	// ErrUnsupportedURLFormat indicates an unsupported remote URL format
	ErrUnsupportedURLFormat = errors.New("unsupported remote URL format")
)

// GitHubPagesDeployer handles deployment to GitHub Pages
type GitHubPagesDeployer struct {
	repoPath    string
	pagesBranch string
	verbose     bool
}

// NewGitHubPagesDeployer creates a new GitHub Pages deployer
func NewGitHubPagesDeployer(repoPath, pagesBranch string, verbose bool) *GitHubPagesDeployer {
	if pagesBranch == "" {
		pagesBranch = "gh-pages"
	}
	return &GitHubPagesDeployer{
		repoPath:    repoPath,
		pagesBranch: pagesBranch,
		verbose:     verbose,
	}
}

// Setup initializes the GitHub Pages branch with proper structure
func (d *GitHubPagesDeployer) Setup(ctx context.Context, force bool) error {
	// Check if gh-pages branch exists
	exists, err := d.branchExists(ctx)
	if err != nil {
		return fmt.Errorf("checking branch existence: %w", err)
	}

	if exists && !force {
		return fmt.Errorf("%w: %q (use --force to override)", ErrBranchExists, d.pagesBranch)
	}

	// Create orphan branch
	if err := d.createOrphanBranch(ctx); err != nil {
		return fmt.Errorf("creating orphan branch: %w", err)
	}

	// Configure git identity for commits
	if err := d.configureGitIdentity(ctx); err != nil {
		return fmt.Errorf("configuring git identity: %w", err)
	}

	// Create directory structure
	dirs := []string{
		"badges",
		"badges/pr",
		"reports",
		"reports/pr",
		"reports/branch",
		"coverage",
		"assets",
		"assets/css",
		"assets/js",
		"assets/fonts",
		"api",
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o750); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}

		// Create .gitkeep to preserve empty directories
		gitkeepPath := filepath.Join(dir, ".gitkeep")
		if err := os.WriteFile(gitkeepPath, []byte(""), 0o600); err != nil {
			return fmt.Errorf("creating .gitkeep in %s: %w", dir, err)
		}
	}

	// Create initial dashboard
	if err := d.createInitialDashboard(); err != nil {
		return fmt.Errorf("creating initial dashboard: %w", err)
	}

	// Create README for gh-pages
	readme := `# Coverage Dashboard

This branch hosts the coverage dashboard and reports for this repository.

- **Dashboard**: https://{owner}.github.io/{repo}/
- **Coverage Badge**: https://{owner}.github.io/{repo}/badges/main.svg
- **Reports**: https://{owner}.github.io/{repo}/reports/

Generated by GoFortress Coverage System.
`
	if err := os.WriteFile("README.md", []byte(readme), 0o600); err != nil {
		return fmt.Errorf("creating README: %w", err)
	}

	// Commit and push
	if err := d.commitAndPush(ctx, "üöÄ Initialize GitHub Pages structure"); err != nil {
		return fmt.Errorf("committing initial structure: %w", err)
	}

	return nil
}

// Deploy deploys coverage artifacts to GitHub Pages
func (d *GitHubPagesDeployer) Deploy(ctx context.Context, opts DeployOptions) error {
	// Create temporary directory for git operations
	tempDir, err := os.MkdirTemp("", "coverage-deploy-*")
	if err != nil {
		return fmt.Errorf("creating temp directory: %w", err)
	}
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()

	// Clone gh-pages branch
	if cloneErr := d.clonePagesBranch(ctx, tempDir); cloneErr != nil {
		return fmt.Errorf("cloning pages branch: %w", cloneErr)
	}

	// Change to cloned directory
	originalDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getting current directory: %w", err)
	}

	if chdirErr := os.Chdir(tempDir); chdirErr != nil {
		return fmt.Errorf("changing to temp directory: %w", chdirErr)
	}
	defer func() {
		_ = os.Chdir(originalDir)
	}()

	// Configure git identity for commits
	if err := d.configureGitIdentity(ctx); err != nil {
		return fmt.Errorf("configuring git identity: %w", err)
	}

	// Copy artifacts based on type (PR or branch)
	if opts.PRNumber != "" {
		if err := d.deployPRArtifacts(opts); err != nil {
			return fmt.Errorf("deploying PR artifacts: %w", err)
		}
	} else {
		if err := d.deployBranchArtifacts(opts); err != nil {
			return fmt.Errorf("deploying branch artifacts: %w", err)
		}
	}

	// Update main dashboard if this is main/master branch
	if opts.Branch == "main" || opts.Branch == "master" {
		if err := d.updateMainDashboard(opts); err != nil {
			return fmt.Errorf("updating main dashboard: %w", err)
		}
	}

	// Commit and push changes
	message := opts.Message
	if message == "" {
		if opts.PRNumber != "" {
			message = fmt.Sprintf("üìä Update coverage for PR #%s", opts.PRNumber)
		} else {
			message = fmt.Sprintf("üìä Update coverage for %s branch", opts.Branch)
		}
	}

	if err := d.commitAndPush(ctx, message); err != nil {
		return fmt.Errorf("committing changes: %w", err)
	}

	return nil
}

// Clean removes old PR data and expired content
func (d *GitHubPagesDeployer) Clean(ctx context.Context, opts CleanOptions) error {
	// Clone gh-pages branch
	tempDir, err := os.MkdirTemp("", "coverage-clean-*")
	if err != nil {
		return fmt.Errorf("creating temp directory: %w", err)
	}
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()

	if cloneErr := d.clonePagesBranch(ctx, tempDir); cloneErr != nil {
		return fmt.Errorf("cloning pages branch: %w", cloneErr)
	}

	// Change to cloned directory
	originalDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getting current directory: %w", err)
	}

	if chdirErr := os.Chdir(tempDir); chdirErr != nil {
		return fmt.Errorf("changing to temp directory: %w", chdirErr)
	}
	defer func() {
		_ = os.Chdir(originalDir)
	}()

	// Configure git identity for commits
	if identityErr := d.configureGitIdentity(ctx); identityErr != nil {
		return fmt.Errorf("configuring git identity: %w", identityErr)
	}

	// Find and remove expired PR directories
	prDirs, err := filepath.Glob("*/pr/*")
	if err != nil {
		return fmt.Errorf("finding PR directories: %w", err)
	}

	removed := []string{}
	cutoffTime := time.Now().AddDate(0, 0, -opts.MaxAgeDays)

	for _, dir := range prDirs {
		info, err := os.Stat(dir)
		if err != nil {
			continue
		}

		if info.ModTime().Before(cutoffTime) {
			if !opts.DryRun {
				if err := os.RemoveAll(dir); err != nil {
					return fmt.Errorf("removing %s: %w", dir, err)
				}
			}
			removed = append(removed, dir)
		}
	}

	if len(removed) > 0 && !opts.DryRun {
		message := fmt.Sprintf("üßπ Clean up %d expired PR directories", len(removed))
		if err := d.commitAndPush(ctx, message); err != nil {
			return fmt.Errorf("committing cleanup: %w", err)
		}
	}

	return nil
}

// Helper methods

func (d *GitHubPagesDeployer) branchExists(ctx context.Context) (bool, error) {
	// Validate branch name to prevent command injection
	if d.pagesBranch == "" || strings.ContainsAny(d.pagesBranch, ";&|<>$`") {
		return false, fmt.Errorf("%w: %q", ErrInvalidBranchName, d.pagesBranch)
	}

	cmd := exec.CommandContext(ctx, "git", "ls-remote", "--heads", "origin", d.pagesBranch) //nolint:gosec // branch name validated
	output, err := cmd.Output()
	if err != nil {
		return false, err
	}
	return len(output) > 0, nil
}

func (d *GitHubPagesDeployer) createOrphanBranch(ctx context.Context) error {
	// Create orphan branch (branch name already validated in branchExists)
	cmd := exec.CommandContext(ctx, "git", "checkout", "--orphan", d.pagesBranch) //nolint:gosec // branch validated
	if err := d.runCommand(cmd); err != nil {
		return err
	}

	// Remove all files from index
	cmd = exec.CommandContext(ctx, "git", "rm", "-rf", ".")
	_ = d.runCommand(cmd) // Ignore error if no files to remove

	return nil
}

func (d *GitHubPagesDeployer) clonePagesBranch(ctx context.Context, destDir string) error {
	if d.verbose {
		fmt.Printf("üîß Starting clonePagesBranch process\n")    //nolint:forbidigo // CLI output
		fmt.Printf("  üìÇ Destination directory: %s\n", destDir) //nolint:forbidigo // CLI output
	}

	// Get remote URL
	cmd := exec.CommandContext(ctx, "git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("getting remote URL: %w", err)
	}
	remoteURL := strings.TrimSpace(string(output))

	if d.verbose {
		fmt.Printf("üîç Retrieved remote URL: %q (raw length: %d)\n", remoteURL, len(remoteURL)) //nolint:forbidigo // CLI output
	}

	// Get GitHub token with fallback mechanism (GH_PAT_TOKEN || GITHUB_TOKEN)
	token := d.getGitHubToken()
	if token != "" {
		if d.verbose {
			fmt.Printf("üîë Token available, attempting URL authentication\n") //nolint:forbidigo // CLI output
		}
		// Convert HTTPS URL to authenticated URL
		if authenticatedURL, authErr := d.addTokenToURL(remoteURL, token); authErr == nil {
			if d.verbose {
				fmt.Printf("‚úÖ Successfully converted to authenticated URL\n") //nolint:forbidigo // CLI output
				fmt.Printf("üîê Original URL: %q\n", remoteURL)                 //nolint:forbidigo // CLI output
				// Don't log the full authenticated URL as it contains the token
				fmt.Printf("üîê Authenticated URL format: https://x-access-token:***@github.com/...\n") //nolint:forbidigo // CLI output
			}
			remoteURL = authenticatedURL
		} else {
			if d.verbose {
				fmt.Printf("‚ùå Failed to convert URL to authenticated format: %v\n", authErr) //nolint:forbidigo // CLI output
				fmt.Printf("‚ö†Ô∏è Will attempt clone with original URL: %q\n", remoteURL)       //nolint:forbidigo // CLI output
			}
		}
	} else if d.verbose {
		fmt.Printf("‚ö†Ô∏è No GitHub token found, using unauthenticated URL\n") //nolint:forbidigo // CLI output
	}

	// Clone only gh-pages branch
	if d.verbose {
		fmt.Printf("üîß Executing git clone command\n") //nolint:forbidigo // CLI output
		fmt.Printf("  üì¶ Branch: %s\n", d.pagesBranch) //nolint:forbidigo // CLI output
		fmt.Printf("  üìÇ Target: %s\n", destDir)       //nolint:forbidigo // CLI output
	}

	cmd = exec.CommandContext(ctx, "git", "clone", //nolint:gosec // inputs validated
		"--single-branch",
		"--branch", d.pagesBranch,
		"--depth", "1",
		remoteURL, destDir)

	return d.runCommand(cmd)
}

func (d *GitHubPagesDeployer) deployPRArtifacts(opts DeployOptions) error {
	prDir := filepath.Join("pr", opts.PRNumber)

	// Create PR directory structure
	dirs := []string{
		filepath.Join("badges", prDir),
		filepath.Join("reports", prDir),
		filepath.Join("coverage", prDir),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o750); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}
	}

	// Copy artifacts from input directory
	return d.copyArtifacts(opts.InputDir, prDir)
}

func (d *GitHubPagesDeployer) deployBranchArtifacts(opts DeployOptions) error {
	// Sanitize branch name for filesystem
	safeBranch := strings.ReplaceAll(opts.Branch, "/", "-")

	// Copy main artifacts
	if err := d.copyArtifacts(opts.InputDir, ""); err != nil {
		return err
	}

	// Also copy to branch-specific location
	branchDir := filepath.Join("reports", "branch", safeBranch)
	if err := os.MkdirAll(branchDir, 0o750); err != nil {
		return fmt.Errorf("creating branch directory: %w", err)
	}

	return d.copyArtifacts(opts.InputDir, branchDir)
}

func (d *GitHubPagesDeployer) copyArtifacts(srcDir, destPrefix string) error {
	// Copy coverage.svg to badges directory
	srcBadge := filepath.Join(srcDir, "coverage.svg")
	if _, err := os.Stat(srcBadge); err == nil {
		destBadge := "badges/coverage.svg"
		if destPrefix != "" {
			destBadge = filepath.Join("badges", destPrefix, "coverage.svg")
		}
		if err := d.copyFile(srcBadge, destBadge); err != nil {
			return fmt.Errorf("copying badge: %w", err)
		}
	}

	// Copy HTML report
	srcReport := filepath.Join(srcDir, "coverage.html")
	if _, err := os.Stat(srcReport); err == nil {
		destReport := "reports/coverage.html"
		if destPrefix != "" {
			destReport = filepath.Join("reports", destPrefix, "coverage.html")
		}
		if err := d.copyFile(srcReport, destReport); err != nil {
			return fmt.Errorf("copying report: %w", err)
		}
	}

	// Copy any dashboard files
	srcDashboard := filepath.Join(srcDir, "dashboard.html")
	if _, err := os.Stat(srcDashboard); err == nil {
		destDashboard := "coverage/index.html"
		if destPrefix != "" {
			destDashboard = filepath.Join("coverage", destPrefix, "index.html")
		}
		if err := d.copyFile(srcDashboard, destDashboard); err != nil {
			return fmt.Errorf("copying dashboard: %w", err)
		}
	}

	return nil
}

func (d *GitHubPagesDeployer) updateMainDashboard(opts DeployOptions) error {
	// Copy the dashboard.html to root index.html for main branch
	srcDashboard := filepath.Join(opts.InputDir, "dashboard.html")
	if _, err := os.Stat(srcDashboard); err == nil {
		if err := d.copyFile(srcDashboard, "index.html"); err != nil {
			return fmt.Errorf("copying dashboard to index.html: %w", err)
		}
	}

	// Also update the coverage subdirectory
	if err := d.copyFile(srcDashboard, "coverage/index.html"); err != nil {
		return fmt.Errorf("copying dashboard to coverage/index.html: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) createInitialDashboard() error {
	dashboardHTML := d.generateInitialDashboardHTML()

	// Write to index.html
	if err := os.WriteFile("index.html", []byte(dashboardHTML), 0o600); err != nil {
		return fmt.Errorf("writing index.html: %w", err)
	}

	// Also write to coverage/index.html
	if err := os.MkdirAll("coverage", 0o750); err != nil {
		return fmt.Errorf("creating coverage directory: %w", err)
	}

	if err := os.WriteFile("coverage/index.html", []byte(dashboardHTML), 0o600); err != nil {
		return fmt.Errorf("writing coverage/index.html: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) generateInitialDashboardHTML() string {
	return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè∞ GoFortress Coverage Dashboard</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --text-accent: #58a6ff;
            --border-color: #30363d;
            --success-color: #238636;
            --warning-color: #d29922;
            --danger-color: #da3633;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            font-size: 3rem;
            color: var(--text-accent);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .header .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .metric-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }
        
        .metric-card h3 {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .status-message {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .status-message h2 {
            color: var(--text-accent);
            margin-bottom: 1rem;
        }
        
        .footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            border-top: 1px solid var(--border-color);
            margin-top: 3rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üè∞ GoFortress Coverage Dashboard</h1>
            <p class="subtitle">Coverage tracking and reporting for your Go projects</p>
        </header>
        
        <main>
            <div class="status-message">
                <h2>üöÄ Welcome to GoFortress Coverage!</h2>
                <p>Your coverage dashboard is ready. Coverage data will appear here after your first CI run.</p>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <h3>üìä Coverage Reports</h3>
                    <p>Detailed HTML coverage reports will be available at <code>/reports/</code> after your first build.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üè∑Ô∏è Coverage Badges</h3>
                    <p>Dynamic SVG badges for your README will be available at <code>/badges/main.svg</code>.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üîÄ PR Analysis</h3>
                    <p>Pull request coverage analysis will be stored at <code>/pr/{number}/</code>.</p>
                </div>
                
                <div class="metric-card">
                    <h3>üìà Trend Analysis</h3>
                    <p>Historical coverage trends and analytics will be displayed here.</p>
                </div>
            </div>
        </main>
        
        <footer class="footer">
            <p>üìä Generated by <strong>GoFortress Coverage System</strong></p>
            <p>Self-contained, Go-native coverage tracking with zero external dependencies</p>
        </footer>
    </div>
</body>
</html>`
}

// configureGitIdentity sets up git user identity for commits
func (d *GitHubPagesDeployer) configureGitIdentity(ctx context.Context) error {
	var userName, userEmail string

	// Detect environment and set appropriate identity
	if os.Getenv("GITHUB_ACTIONS") == "true" {
		// GitHub Actions environment - use GitHub Actions bot
		userName = "github-actions[bot]"
		userEmail = "41898282+github-actions[bot]@users.noreply.github.com"
		if d.verbose {
			fmt.Println("ü§ñ Detected GitHub Actions environment, using bot identity") //nolint:forbidigo // CLI output
		}
	} else if os.Getenv("CI") == "true" {
		// Generic CI environment
		userName = "CI Bot"
		userEmail = "ci-bot@users.noreply.github.com"
		if d.verbose {
			fmt.Println("ü§ñ Detected CI environment, using generic bot identity") //nolint:forbidigo // CLI output
		}
	} else {
		// Local development - check if git config exists
		cmd := exec.CommandContext(ctx, "git", "config", "--get", "user.name")
		if output, err := cmd.Output(); err == nil && len(output) > 0 {
			// User already has git config, skip configuration
			if d.verbose {
				fmt.Println("‚úÖ Git identity already configured") //nolint:forbidigo // CLI output
			}
			return nil
		}
		// Use default values for local development
		userName = "GoFortress Coverage"
		userEmail = "coverage@gofortress.local"
		if d.verbose {
			fmt.Println("üíª Local environment, using default identity") //nolint:forbidigo // CLI output
		}
	}

	// Configure git user name
	cmd := exec.CommandContext(ctx, "git", "config", "user.name", userName) //nolint:gosec // userName is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("setting git user name: %w", err)
	}

	// Configure git user email
	cmd = exec.CommandContext(ctx, "git", "config", "user.email", userEmail) //nolint:gosec // userEmail is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("setting git user email: %w", err)
	}

	if d.verbose {
		fmt.Printf("‚úÖ Git identity configured: %s <%s>\n", userName, userEmail) //nolint:forbidigo // CLI output
	}

	return nil
}

func (d *GitHubPagesDeployer) commitAndPush(ctx context.Context, message string) error {
	// Add all changes
	cmd := exec.CommandContext(ctx, "git", "add", "-A")
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git add: %w", err)
	}

	// Check if there are changes to commit
	cmd = exec.CommandContext(ctx, "git", "diff", "--cached", "--quiet")
	if err := cmd.Run(); err == nil {
		// No changes to commit
		if d.verbose {
			fmt.Println("No changes to commit") //nolint:forbidigo // CLI output
		}
		return nil
	}

	// Commit changes
	cmd = exec.CommandContext(ctx, "git", "commit", "-m", message)
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git commit: %w", err)
	}

	// Ensure origin remote is set with authentication for push
	if err := d.ensureAuthenticatedRemote(ctx); err != nil {
		return fmt.Errorf("setting up authenticated remote: %w", err)
	}

	// Push changes
	cmd = exec.CommandContext(ctx, "git", "push", "origin", d.pagesBranch) //nolint:gosec // branch validated
	if err := d.runCommand(cmd); err != nil {
		return fmt.Errorf("git push: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) copyFile(src, dst string) error {
	// Ensure destination directory exists
	dstDir := filepath.Dir(dst)
	if err := os.MkdirAll(dstDir, 0o750); err != nil {
		return fmt.Errorf("creating destination directory: %w", err)
	}

	// Open source file
	srcFile, err := os.Open(src) //nolint:gosec // caller validates paths
	if err != nil {
		return fmt.Errorf("opening source file: %w", err)
	}
	defer func() {
		_ = srcFile.Close()
	}()

	// Create destination file
	dstFile, err := os.Create(dst) //nolint:gosec // caller validates paths
	if err != nil {
		return fmt.Errorf("creating destination file: %w", err)
	}
	defer func() {
		_ = dstFile.Close()
	}()

	// Copy content
	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return fmt.Errorf("copying file content: %w", err)
	}

	return nil
}

func (d *GitHubPagesDeployer) runCommand(cmd *exec.Cmd) error {
	if d.verbose {
		fmt.Printf("üîß Running: %s\n", strings.Join(cmd.Args, " ")) //nolint:forbidigo // CLI output
		fmt.Printf("  üìÇ Working directory: %s\n", cmd.Dir)         //nolint:forbidigo // CLI output
		if len(cmd.Env) > 0 {
			fmt.Printf("  üåç Environment variables: %d set\n", len(cmd.Env)) //nolint:forbidigo // CLI output
		}
	}

	var stderr bytes.Buffer
	var stdout bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Stdout = &stdout

	if err := cmd.Run(); err != nil {
		if d.verbose {
			fmt.Printf("‚ùå Command failed: %s\n", err) //nolint:forbidigo // CLI output
			if stdout.Len() > 0 {
				fmt.Printf("üì§ STDOUT: %s\n", stdout.String()) //nolint:forbidigo // CLI output
			}
			if stderr.Len() > 0 {
				fmt.Printf("üì• STDERR: %s\n", stderr.String()) //nolint:forbidigo // CLI output
			}
		}
		return fmt.Errorf("%w: stderr=%s stdout=%s", err, stderr.String(), stdout.String())
	}

	if d.verbose {
		fmt.Printf("‚úÖ Command completed successfully\n") //nolint:forbidigo // CLI output
		if stdout.Len() > 0 {
			fmt.Printf("üì§ STDOUT: %s\n", stdout.String()) //nolint:forbidigo // CLI output
		}
		if stderr.Len() > 0 {
			fmt.Printf("üì• STDERR (info): %s\n", stderr.String()) //nolint:forbidigo // CLI output
		}
	}

	return nil
}

// getGitHubToken retrieves GitHub token with fallback mechanism (GH_PAT_TOKEN || GITHUB_TOKEN)
func (d *GitHubPagesDeployer) getGitHubToken() string {
	// Try GH_PAT_TOKEN first (personal access token with broader permissions)
	if token := os.Getenv("GH_PAT_TOKEN"); token != "" {
		if d.verbose {
			fmt.Printf("üîë Using GH_PAT_TOKEN for authentication\n") //nolint:forbidigo // CLI output
		}
		return token
	}

	// Fall back to GITHUB_TOKEN (standard GitHub Actions token)
	if token := os.Getenv("GITHUB_TOKEN"); token != "" {
		if d.verbose {
			fmt.Printf("üîë Using GITHUB_TOKEN for authentication\n") //nolint:forbidigo // CLI output
		}
		return token
	}

	return ""
}

// addTokenToURL converts a Git URL to an authenticated HTTPS URL with the provided token
func (d *GitHubPagesDeployer) addTokenToURL(remoteURL, token string) (string, error) {
	// Sanitize the URL by cleaning control characters and GitHub Actions masking
	sanitizedURL := d.sanitizeURL(remoteURL)

	// Add debug logging to help troubleshoot URL issues
	if d.verbose {
		fmt.Printf("üîç Converting URL to authenticated format: %q\n", sanitizedURL) //nolint:forbidigo // CLI output
		if len(remoteURL) != len(sanitizedURL) {
			fmt.Printf("üßπ URL sanitization removed %d characters\n", len(remoteURL)-len(sanitizedURL)) //nolint:forbidigo // CLI output
		}
	}

	// Handle empty URL
	if sanitizedURL == "" {
		return "", fmt.Errorf("%w: empty URL after sanitization", ErrUnsupportedURLFormat)
	}

	// Try to extract GitHub repository path using multiple approaches
	repoPath := d.extractGitHubRepoPath(sanitizedURL)
	if repoPath == "" {
		// Show detailed debugging information if extraction fails
		if d.verbose {
			d.debugURLFormat(remoteURL, sanitizedURL)
		}
		return "", fmt.Errorf("%w: %s", ErrUnsupportedURLFormat, sanitizedURL)
	}

	// Ensure .git suffix for proper repository access
	if !strings.HasSuffix(repoPath, ".git") {
		repoPath += ".git"
	}

	// Create authenticated URL
	authenticatedURL := fmt.Sprintf("https://x-access-token:%s@github.com/%s", token, repoPath)
	if d.verbose {
		fmt.Printf("‚úÖ Converted to authenticated format: %s\n", authenticatedURL) //nolint:forbidigo // CLI output
	}

	return authenticatedURL, nil
}

// sanitizeURL removes ANSI escape codes, control characters, and GitHub Actions masking artifacts
func (d *GitHubPagesDeployer) sanitizeURL(url string) string {
	// Remove leading/trailing whitespace
	cleaned := strings.TrimSpace(url)

	// Remove ANSI escape codes (e.g., \x1b[31m for colors)
	ansiRegex := regexp.MustCompile(`\x1b\[[0-9;]*[a-zA-Z]`)
	cleaned = ansiRegex.ReplaceAllString(cleaned, "")

	// Remove other control characters but preserve printable ASCII
	cleaned = strings.Map(func(r rune) rune {
		if unicode.IsPrint(r) || r == '\t' || r == '\n' || r == '\r' {
			return r
		}
		return -1 // Remove the character
	}, cleaned)

	// Clean up any remaining whitespace
	cleaned = strings.TrimSpace(cleaned)

	return cleaned
}

// extractGitHubRepoPath extracts the owner/repo path from various GitHub URL formats
func (d *GitHubPagesDeployer) extractGitHubRepoPath(url string) string {
	// Handle standard SSH format: git@github.com:owner/repo.git
	if strings.HasPrefix(url, "git@github.com:") {
		return strings.TrimPrefix(url, "git@github.com:")
	}

	// Handle standard HTTPS format: https://github.com/owner/repo.git
	if strings.HasPrefix(url, "https://github.com/") {
		return strings.TrimPrefix(url, "https://github.com/")
	}

	// Handle GitHub Actions masked format: ***github.com/owner/repo
	if strings.Contains(url, "github.com/") {
		// Use regex to extract owner/repo from any format containing github.com/
		githubRegex := regexp.MustCompile(`github\.com/([^/\s]+/[^/\s]+)`)
		matches := githubRegex.FindStringSubmatch(url)
		if len(matches) >= 2 {
			return matches[1]
		}
	}

	return ""
}

// debugURLFormat provides detailed debugging information for unsupported URL formats
func (d *GitHubPagesDeployer) debugURLFormat(originalURL, sanitizedURL string) {
	fmt.Printf("‚ùå Unsupported URL format debugging:\n")                               //nolint:forbidigo // CLI output
	fmt.Printf("  Original URL: %q (length: %d)\n", originalURL, len(originalURL))    //nolint:forbidigo // CLI output
	fmt.Printf("  Sanitized URL: %q (length: %d)\n", sanitizedURL, len(sanitizedURL)) //nolint:forbidigo // CLI output

	// Show hex dump for the first 50 characters to identify hidden characters
	hexDump := func(s string, label string) {
		fmt.Printf("  %s hex dump: ", label) //nolint:forbidigo // CLI output
		maxLen := len(s)
		if maxLen > 50 {
			maxLen = 50
		}
		for i := 0; i < maxLen; i++ {
			fmt.Printf("%02x ", s[i]) //nolint:forbidigo // CLI output
		}
		if len(s) > 50 {
			fmt.Printf("... (+%d more)", len(s)-50) //nolint:forbidigo // CLI output
		}
		fmt.Printf("\n") //nolint:forbidigo // CLI output
	}

	hexDump(originalURL, "Original")
	if originalURL != sanitizedURL {
		hexDump(sanitizedURL, "Sanitized")
	}

	// Show pattern matching results
	fmt.Printf("  Pattern matching results:\n")                                                                         //nolint:forbidigo // CLI output
	fmt.Printf("    - Starts with 'git@github.com:': %v\n", strings.HasPrefix(sanitizedURL, "git@github.com:"))         //nolint:forbidigo // CLI output
	fmt.Printf("    - Starts with 'https://github.com/': %v\n", strings.HasPrefix(sanitizedURL, "https://github.com/")) //nolint:forbidigo // CLI output
	fmt.Printf("    - Contains 'github.com/': %v\n", strings.Contains(sanitizedURL, "github.com/"))                     //nolint:forbidigo // CLI output

	// Try regex extraction
	githubRegex := regexp.MustCompile(`github\.com/([^/\s]+/[^/\s]+)`)
	matches := githubRegex.FindStringSubmatch(sanitizedURL)
	fmt.Printf("    - Regex extraction result: %v\n", matches) //nolint:forbidigo // CLI output
}

// ensureAuthenticatedRemote ensures the origin remote is set with authentication
func (d *GitHubPagesDeployer) ensureAuthenticatedRemote(ctx context.Context) error {
	if d.verbose {
		fmt.Printf("üîß Starting ensureAuthenticatedRemote process\n") //nolint:forbidigo // CLI output
	}

	// Get GitHub token
	token := d.getGitHubToken()
	if token == "" {
		// No token available, skip authentication setup
		if d.verbose {
			fmt.Printf("‚ö†Ô∏è No GitHub token available for push authentication\n") //nolint:forbidigo // CLI output
		}
		return nil
	}

	if d.verbose {
		fmt.Printf("üîë GitHub token found, proceeding with authentication setup\n") //nolint:forbidigo // CLI output
	}

	// Get current origin URL
	if d.verbose {
		fmt.Printf("üîç Retrieving current origin URL from git config\n") //nolint:forbidigo // CLI output
	}
	cmd := exec.CommandContext(ctx, "git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		if d.verbose {
			fmt.Printf("‚ùå Failed to get origin URL: %v\n", err) //nolint:forbidigo // CLI output
		}
		return fmt.Errorf("getting origin URL: %w", err)
	}
	currentURL := strings.TrimSpace(string(output))

	if d.verbose {
		fmt.Printf("üîç Current origin URL: %q (raw length: %d)\n", currentURL, len(currentURL)) //nolint:forbidigo // CLI output
	}

	// Convert to authenticated URL
	if d.verbose {
		fmt.Printf("üîÑ Converting URL to authenticated format\n") //nolint:forbidigo // CLI output
	}
	authenticatedURL, err := d.addTokenToURL(currentURL, token)
	if err != nil {
		if d.verbose {
			fmt.Printf("‚ùå Failed to convert URL to authenticated format: %v\n", err) //nolint:forbidigo // CLI output
		}
		return fmt.Errorf("converting URL to authenticated: %w", err)
	}

	if d.verbose {
		fmt.Printf("‚úÖ Successfully created authenticated URL\n") //nolint:forbidigo // CLI output
		fmt.Printf("üîÑ Setting new origin URL in git config\n")   //nolint:forbidigo // CLI output
	}

	// Set the authenticated URL as origin
	cmd = exec.CommandContext(ctx, "git", "remote", "set-url", "origin", authenticatedURL) //nolint:gosec // authenticatedURL is controlled and validated
	if err := d.runCommand(cmd); err != nil {
		if d.verbose {
			fmt.Printf("‚ùå Failed to set authenticated origin URL: %v\n", err) //nolint:forbidigo // CLI output
		}
		return fmt.Errorf("setting authenticated origin URL: %w", err)
	}

	if d.verbose {
		fmt.Printf("üîê Successfully updated origin remote with authentication\n") //nolint:forbidigo // CLI output
	}

	return nil
}

// DeployOptions contains options for deployment
type DeployOptions struct {
	Branch    string
	CommitSha string
	PRNumber  string
	InputDir  string
	Message   string
	Verbose   bool
}

// CleanOptions contains options for cleanup
type CleanOptions struct {
	MaxAgeDays int
	DryRun     bool
	Verbose    bool
}
