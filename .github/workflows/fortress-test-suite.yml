# ------------------------------------------------------------------------------------
#  Test Suite (Reusable Workflow) (GoFortress)
#
#  Purpose: Run the main Go test suite across multiple Go versions and operating
#  systems, including unit tests, race detection, coverage, and fuzz tests.
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Go Test Suite)

on:
  workflow_call:
    inputs:
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
      test-matrix:
        description: "Test matrix JSON"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
      go-primary-version:
        description: "Primary Go version"
        required: true
        type: string
      go-secondary-version:
        description: "Secondary Go version"
        required: true
        type: string
      code-coverage-enabled:
        description: "Whether code coverage is enabled"
        required: true
        type: string
      coverage-provider:
        description: "Coverage service provider (internal or codecov)"
        required: false
        type: string
        default: "internal"
      race-detection-enabled:
        description: "Whether race detection is enabled"
        required: true
        type: string
      fuzz-testing-enabled:
        description: "Whether fuzz testing is enabled"
        required: true
        type: string
    secrets:
      github-token:
        description: "GitHub token for API access"
        required: true
      CODECOV_TOKEN:
        description: "Codecov token for uploading coverage (required when coverage-provider is codecov)"
        required: false

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read

jobs:
  # ----------------------------------------------------------------------------------
  # Testing Matrix for Go (Parallel)
  # ----------------------------------------------------------------------------------
  test-go:
    name: üß™ Test (${{ matrix.name }})
    timeout-minutes: 30 # Prevent hung tests
    permissions:
      contents: write # Read repository content for testing
    strategy:
      fail-fast: true
      matrix: ${{ fromJSON(inputs.test-matrix) }}
    runs-on: ${{ matrix.os }}

    steps:
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Parse environment variables
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "üìã Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Checkout code and set up Go environment
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì• Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup Go with caching and version management
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üèóÔ∏è Setup Go with Cache
        id: setup-go-test
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ matrix.go-version }}
          matrix-os: ${{ matrix.os }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup MAGE-X (required for magex test commands)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ matrix.os }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Start test timer
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: ‚è±Ô∏è Start test timer
        id: test-timer
        run: |
          echo "test-start=$(date +%s)" >> $GITHUB_OUTPUT

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Detect test output mode
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîç Detect test output mode
        id: detect-mode
        run: |
          # Count tests to determine appropriate output mode
          TEST_COUNT=$(find . -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Test[A-Z0-9_]' {} + | wc -l | xargs)
          TEST_COUNT=${TEST_COUNT:-0}

          OUTPUT_MODE="${TEST_OUTPUT_MODE:-SMART}"
          THRESHOLD="${TEST_OUTPUT_SMART_THRESHOLD:-500}"

          echo "üìä Found $TEST_COUNT tests"
          echo "üéõÔ∏è Configured mode: $OUTPUT_MODE"
          echo "üéØ Smart threshold: $THRESHOLD tests"

          if [[ "$OUTPUT_MODE" == "SMART" ]]; then
            if [[ "$TEST_COUNT" -gt "$THRESHOLD" ]]; then
              DETECTED_MODE="FAILURES_ONLY"
              echo "üéØ Using FAILURES_ONLY mode for $TEST_COUNT tests"
            else
              DETECTED_MODE="FULL"
              echo "üìù Using FULL mode for $TEST_COUNT tests"
            fi
          else
            DETECTED_MODE="$OUTPUT_MODE"
            echo "üîß Using configured mode: $DETECTED_MODE"
          fi

          echo "detected-mode=$DETECTED_MODE" >> $GITHUB_OUTPUT
          echo "test-count=$TEST_COUNT" >> $GITHUB_OUTPUT
          echo "DETECTED_OUTPUT_MODE=$DETECTED_MODE" >> $GITHUB_ENV
          echo "TEST_COUNT=$TEST_COUNT" >> $GITHUB_ENV

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Define robust failure detection functions
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Define failure detection functions
        run: |
          # Define reusable function for robust test failure detection
          cat > test-failure-functions.sh << 'DETECTION_FUNCTIONS_EOF'
          #!/bin/bash

          # Robust test failure detection function
          detect_test_failures() {
            local output_file="$1"
            local exit_code="${2:-0}"
            local mode="${3:-text}"
            local failures_file="${4:-test-failures.txt}"

            echo "üîç Detecting test failures with exit code: $exit_code, mode: $mode"

            # Primary check: exit code indicates failure
            if [[ "$exit_code" -ne 0 ]]; then
              echo "‚ùå Exit code $exit_code indicates test failure"

              if [[ -f "$output_file" ]]; then
                case "$mode" in
                  "json")
                    # Enhanced JSON-based detection
                    detect_failures_from_json "$output_file" "$failures_file"
                    ;;
                  "text"|*)
                    # Enhanced text-based detection
                    detect_failures_from_text "$output_file" "$failures_file"
                    ;;
                esac

                # Count detected failures
                if [[ -f "$failures_file" ]]; then
                  DETECTED_FAILURES=$(wc -l < "$failures_file" 2>/dev/null || echo "0")
                  echo "üìä Detected $DETECTED_FAILURES specific failures"
                  return $DETECTED_FAILURES
                fi
              else
                echo "‚ö†Ô∏è Output file '$output_file' not found, relying on exit code"
                echo "Exit code indicates failure but no output file found" > "$failures_file"
                return 1
              fi
            else
              echo "‚úÖ Exit code 0 indicates success"
              touch "$failures_file"  # Create empty failures file
              return 0
            fi
          }

          # Smart and efficient JSON failure detection
          detect_failures_from_json() {
            local json_file="$1"
            local failures_file="$2"

            echo "üîç Using smart JSON-based failure detection on $json_file"

            # Quick JSON validation (< 0.1s) - check if file contains JSON test output
            if ! grep -q '^{.*"Action"' "$json_file" 2>/dev/null; then
              echo "‚ö†Ô∏è No JSON content detected, using text fallback"
              detect_failures_from_text "$json_file" "$failures_file"
              return
            fi

            echo "‚úÖ JSON content detected, processing efficiently..."

            # Fast single-pass JSON extraction (< 1s for 10K lines)
            # Filter JSON lines and parse in one pass - eliminates 2-minute hang
            grep '^{' "$json_file" 2>/dev/null | \
              jq -r 'select(.Action == "fail") | "--- FAIL: \(.Test) (\(.Package))"' \
              2>/dev/null > "$failures_file"

            local failure_count
            failure_count=$(wc -l < "$failures_file" 2>/dev/null | tr -d '\n\r' | xargs)
            [[ "$failure_count" =~ ^[0-9]+$ ]] || failure_count=0

            if [[ "$failure_count" -gt 0 ]]; then
              echo "‚úÖ Found $failure_count test failures in JSON output"
              return 0
            else
              echo "‚ÑπÔ∏è No failures detected in JSON output"
              return 0
            fi
          }

          # Enhanced text-based failure detection
          detect_failures_from_text() {
            local text_file="$1"
            local failures_file="$2"

            echo "üîç Using text-based failure detection on $text_file"

            # Enhanced pattern matching for various failure formats
            # Patterns handle: FAIL, --- FAIL, --FAIL, [FAIL], FAIL:, etc.
            local patterns=(
              '^FAIL[[:space:]:]'
              '^---[[:space:]]*FAIL'
              '^--[[:space:]]*FAIL'
              '^\[?FAIL\]?[[:space:]:.]'
              '--- FAIL:'
              'FAIL[[:space:]]*:'
              '^[[:space:]]*FAIL[[:space:]]'
            )

            local temp_failures=$(mktemp)
            local found_any=false

            for pattern in "${patterns[@]}"; do
              if grep -E "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null; then
                found_any=true
              fi
            done

            if [[ "$found_any" == "true" ]]; then
              # Remove duplicates and sort
              sort -u "$temp_failures" > "$failures_file"
              echo "‚úÖ Text parsing found $(wc -l < "$failures_file") unique failures"
              rm -f "$temp_failures"
              return 0
            fi

            # Fallback: look for any error indicators
            echo "‚ö†Ô∏è Standard failure patterns not found, checking for error indicators"
            local error_patterns=(
              'panic:'
              'fatal error:'
              'build failed'
              'compilation error'
              'timeout'
              'killed'
              'error:'
            )

            for pattern in "${error_patterns[@]}"; do
              if grep -i "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null; then
                found_any=true
              fi
            done

            if [[ "$found_any" == "true" ]]; then
              sort -u "$temp_failures" > "$failures_file"
              echo "‚ö†Ô∏è Found $(wc -l < "$failures_file") error indicators (not standard test failures)"
              rm -f "$temp_failures"
              return 0
            fi

            rm -f "$temp_failures"

            # If exit code indicated failure but no patterns found, create generic entry
            if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
              echo "Generic test failure (exit code ${TEST_EXIT_CODE:-0}) - pattern detection failed" > "$failures_file"
              echo "‚ö†Ô∏è Exit code indicates failure but no recognizable patterns found"
              return 1
            else
              touch "$failures_file"  # Create empty failures file
              echo "‚úÖ No failures detected and exit code is 0"
              return 0
            fi
          }

          # Utility function for safe numeric validation
          sanitize_numeric() {
            local value="$1"
            value=$(echo "$value" | tr -d '\n\r' | xargs)
            if [[ "$value" =~ ^[0-9]+$ ]]; then
              echo "$value"
            else
              echo "0"
            fi
          }

          # Export functions for use in other steps
          export -f detect_test_failures
          export -f detect_failures_from_json
          export -f detect_failures_from_text
          export -f sanitize_numeric
          DETECTION_FUNCTIONS_EOF

          # Source the functions to make them available
          source test-failure-functions.sh
          echo "‚úÖ Failure detection functions defined and loaded"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Run tests and coverage
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üß™ Run tests
        id: run-tests
        continue-on-error: true
        run: |
          # Sanitize inherited environment variables first
          TEST_COUNT=${TEST_COUNT:-0}
          TEST_COUNT=$(echo "$TEST_COUNT" | xargs)
          if ! [[ "$TEST_COUNT" =~ ^[0-9]+$ ]]; then
            TEST_COUNT=0
          fi
          export TEST_COUNT

          # Safely assign values to shell vars with defaults
          RACE="${{ inputs.race-detection-enabled || 'false' }}"
          COVER="${{ inputs.code-coverage-enabled || 'false' }}"
          MODE="${{ steps.detect-mode.outputs.detected-mode || 'FULL' }}"

          echo "üîç Race Detection Enabled: $RACE"
          echo "üîç Code Coverage Enabled: $COVER"
          echo "üéõÔ∏è Output Mode: $MODE"

          # Initialize test exit code
          TEST_EXIT_CODE=0

          # Build unified magex command with timeout and appropriate test type
          if [[ "$RACE" == "true" && "$COVER" == "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT_RACE_COVER:-30m}"
            TEST_TYPE="coverrace"
            echo "üèÅ Running tests with race detection and coverage analysis (timeout: $TEST_TIMEOUT)..."
          elif [[ "$RACE" != "true" && "$COVER" == "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT_RACE_COVER:-30m}"
            TEST_TYPE="cover"
            echo "üèÅ Running tests with coverage analysis (timeout: $TEST_TIMEOUT)..."
          elif [[ "$RACE" == "true" && "$COVER" != "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT:-30m}"
            TEST_TYPE="race"
            echo "üèÅ Running tests with race detection (timeout: $TEST_TIMEOUT)..."
          else
            TEST_TIMEOUT="${TEST_TIMEOUT_UNIT:-20m}"
            TEST_TYPE="unit"
            echo "üèÅ Running tests without coverage or race detection (timeout: $TEST_TIMEOUT)..."
          fi

          # Build command with JSON flag for FAILURES_ONLY mode
          MAGEX_CMD="magex test:${TEST_TYPE} -timeout $TEST_TIMEOUT"
          if [[ "$MODE" == "FAILURES_ONLY" ]]; then
            MAGEX_CMD="$MAGEX_CMD -json"
          fi

          echo "üîß Running: $MAGEX_CMD (timeout: $TEST_TIMEOUT)"

          # Pre-execution diagnostic info for better visibility
          PACKAGE_COUNT=$(find . -name '*.go' -not -path './vendor/*' -not -path './third_party/*' | xargs dirname | sort -u | wc -l | xargs)
          PACKAGE_COUNT=${PACKAGE_COUNT:-0}
          echo "üöÄ Starting test execution:"
          echo "   ‚Ä¢ Total tests: $TEST_COUNT"
          echo "   ‚Ä¢ Test packages: $PACKAGE_COUNT"
          echo "   ‚Ä¢ Test mode: $TEST_TYPE"
          echo "   ‚Ä¢ Output mode: $MODE"
          ESTIMATED_TIME=$(( ($TEST_COUNT + 49) / 50 ))
          echo "   ‚Ä¢ Estimated time: $ESTIMATED_TIME minutes (based on ~50 tests/minute)"
          echo "   ‚Ä¢ Timeout: $TEST_TIMEOUT"
          echo ""

          START_TIME=$(date +%s)
          export START_TIME

          # Execute based on detected mode with simplified processing
          set +e  # Don't exit on error to capture exit code properly
          if [[ "$MODE" == "FULL" ]]; then
            echo "üìù Using FULL output mode - showing all test output"
            echo "üîç Executing: $MAGEX_CMD"
            $MAGEX_CMD 2>&1 | tee test-output.log
            TEST_EXIT_CODE=${PIPESTATUS[0]}
            echo "üîç Magex command exit code: $TEST_EXIT_CODE"

            # Extract failures for summary (even in full mode) using robust detection
            if [[ $TEST_EXIT_CODE -ne 0 ]]; then
              source test-failure-functions.sh 2>/dev/null || true
              detect_failures_from_text "test-output.log" "test-failures.txt" || true
            fi

          else
            echo "üéØ Using FAILURES_ONLY mode with optimized JSON processing"
            echo "‚è≥ Tests starting... (this may take several minutes)"
            echo "üìù Output will show failures and key events only"
            echo ""

            # Start background progress monitor
            (
              MONITOR_PID=$$
              PACKAGES_PROCESSED=0
              while sleep 30; do
                if ! kill -0 $MONITOR_PID 2>/dev/null; then break; fi
                ELAPSED=$(($(date +%s) - START_TIME))
                MINUTES=$((ELAPSED / 60))
                SECONDS=$((ELAPSED % 60))

                # Count completed tests by checking for individual test passes
                if [[ -f test-raw-output.log ]]; then
                  # Count unique test pass completions (not all pass events)
                  CURRENT_TESTS=$(grep -c '{"Time".*"Action":"pass".*"Test":"Test.*"Package"' test-raw-output.log 2>/dev/null || echo "0")
                  # Fix: Ensure numeric value by trimming whitespace and validating
                  CURRENT_TESTS=$(echo "$CURRENT_TESTS" | tr -d '\n\r' | xargs)
                  # Ensure it's numeric, default to 0 if not
                  if ! [[ "$CURRENT_TESTS" =~ ^[0-9]+$ ]]; then
                    CURRENT_TESTS=0
                  fi
                  # Ensure PACKAGES_PROCESSED is numeric
                  if ! [[ "$PACKAGES_PROCESSED" =~ ^[0-9]+$ ]]; then
                    PACKAGES_PROCESSED=0
                  fi

                  if [[ $CURRENT_TESTS -gt $PACKAGES_PROCESSED ]]; then
                    PACKAGES_PROCESSED=$CURRENT_TESTS
                    echo "‚è≥ Progress update: ${MINUTES}m${SECONDS}s elapsed, ~${PACKAGES_PROCESSED}/${TEST_COUNT} tests completed"
                  else
                    echo "‚è≥ Still running: ${MINUTES}m${SECONDS}s elapsed, processing tests..."
                  fi
                fi
              done
            ) &
            MONITOR_PID=$!

            # Optimized single-pass JSON processing with real-time progress
            # Run magex with real-time display and correct exit code capture
            echo "üîç Executing: $MAGEX_CMD"

            # Separate JSON output from error messages for efficient processing
            # Save all output first, then separate JSON from messages
            $MAGEX_CMD 2> >(tee test-stderr.log >&2) | \
              tee test-raw-output-all.log | \
              tee >(grep '^{' > test-raw-output.log 2>/dev/null || true) | \
              tee >(grep -v '^{' > test-messages.log 2>/dev/null || true) |
              (jq -r --unbuffered '
                # Efficiently process each JSON line with progress indicators
                if .Action == "run" then
                  # Package started - show progress
                  "üì¶ Testing: \(.Package | split("/") | .[-1] // .[-2] // .)"
                elif .Action == "output" and .Test == null then
                  # Package-level output (build messages, etc.)
                  .Output // ""
                elif .Action == "fail" then
                  # Failed test - immediate visibility
                  "‚ùå FAIL: \(.Test) (\(.Package | split("/") | .[-1] // .[-2] // .))"
                elif .Action == "pass" and (.Test | test("^Test")) then
                  # Only show individual test passes occasionally to avoid spam
                  if (now | floor) % 5 == 0 then
                    "‚úÖ PASS: \(.Test)"
                  else
                    empty
                  end
                else
                  # Skip other JSON events for cleaner output
                  empty
                end
              ' 2>/dev/null || {
                echo "‚ö†Ô∏è JSON processing failed, showing messages and errors:"
                # Show separated non-JSON messages when jq fails
                [[ -f test-messages.log ]] && cat test-messages.log || cat test-raw-output-all.log
              }) | tee test-output.log > test-output-tail.log

            # Capture magex exit code (PIPESTATUS[0] = magex, not jq)
            TEST_EXIT_CODE=${PIPESTATUS[0]}
            echo "üîç Magex command exit code: $TEST_EXIT_CODE"

            # Kill the progress monitor
            kill $MONITOR_PID 2>/dev/null || true

            echo ""
            echo "‚úÖ Test execution completed"

            # Extract failures with enhanced JSON processing and robust fallback
            if [[ $TEST_EXIT_CODE -ne 0 ]]; then
              echo "üîç Extracting failure information using robust detection..."

              # Source failure detection functions
              source test-failure-functions.sh 2>/dev/null || true

              # Use robust JSON-based detection
              detect_failures_from_json "test-raw-output.log" "test-failures.txt" || {
                echo "‚ö†Ô∏è JSON detection failed, using exit code indicator"
                echo "Test failure detected (exit code $TEST_EXIT_CODE) - JSON parsing failed" > test-failures.txt
              }

              # Create enhanced failure summary with efficient single-pass processing
              echo "üîç Creating failure summary..."

              # Extract all failure records in one optimized pass
              if grep -q '^{.*"Action"' test-raw-output.log 2>/dev/null; then
                # Process JSON output efficiently
                grep '^{' test-raw-output.log 2>/dev/null | \
                  jq -c 'select(.Action == "fail")' 2>/dev/null | \
                  jq -s 'group_by(.Package) |
                    map({
                      package: .[0].Package,
                      failures: map({test: .Test, elapsed: .Elapsed})
                    })' > test-failures-summary.json 2>/dev/null && \
                  echo "‚úÖ Enhanced JSON failure summary created" || {
                    echo "‚ö†Ô∏è JSON summary failed, using basic format"
                    echo "[]" > test-failures-summary.json
                  }
              else
                # Create summary from text failures if no JSON
                if [[ -s test-failures.txt ]]; then
                  echo "üìã Creating summary from text failures"
                  echo '[{"package": "unknown", "failures": [' > test-failures-summary.json
                  awk '{print "{\"test\": \"" $0 "\", \"elapsed\": null}"}' test-failures.txt | \
                    paste -sd ',' - >> test-failures-summary.json 2>/dev/null || true
                  echo ']}]' >> test-failures-summary.json
                  echo "‚úÖ Basic failure summary created"
                else
                  echo "[]" > test-failures-summary.json
                fi
              fi
            else
              echo "‚ÑπÔ∏è No test failures detected (exit code 0)"
              touch test-failures.txt
              echo "[]" > test-failures-summary.json
            fi
          fi
          set -e  # Re-enable exit on error

          # Final execution summary with timing
          END_TIME=$(date +%s)
          TOTAL_DURATION=$((END_TIME - START_TIME))
          MINUTES=$((TOTAL_DURATION / 60))
          SECONDS=$((TOTAL_DURATION % 60))

          # Validate test success based on actual results vs exit code
          echo "üîç Validating test results..."
          ACTUAL_FAILURES=0
          if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
            ACTUAL_FAILURES=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
            ACTUAL_FAILURES=$(echo "$ACTUAL_FAILURES" | tr -d '\n\r' | xargs)
            [[ "$ACTUAL_FAILURES" =~ ^[0-9]+$ ]] || ACTUAL_FAILURES=0
          fi

          echo "üìä Test validation results:"
          echo "   ‚Ä¢ Original exit code: $TEST_EXIT_CODE"
          echo "   ‚Ä¢ Detected failures: $ACTUAL_FAILURES"

          # If exit code indicates failure but no actual failures found, correct it
          if [[ $TEST_EXIT_CODE -ne 0 ]] && [[ $ACTUAL_FAILURES -eq 0 ]]; then
            echo "‚ö†Ô∏è Exit code indicates failure but no test failures detected - correcting exit code"
            echo "üîß This suggests the exit code issue was from JSON processing, not actual test failures"
            TEST_EXIT_CODE=0
            echo "   ‚Ä¢ Corrected exit code: $TEST_EXIT_CODE"
          elif [[ $TEST_EXIT_CODE -eq 0 ]] && [[ $ACTUAL_FAILURES -gt 0 ]]; then
            echo "‚ö†Ô∏è Exit code indicates success but test failures were detected - correcting exit code"
            TEST_EXIT_CODE=1
            echo "   ‚Ä¢ Corrected exit code: $TEST_EXIT_CODE"
          else
            echo "‚úÖ Exit code and test results are consistent"
          fi

          # Store the validated exit code and mode for later steps
          echo "TEST_EXIT_CODE=$TEST_EXIT_CODE" >> $GITHUB_ENV
          echo "test-exit-code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT
          echo "output-mode=$MODE" >> $GITHUB_OUTPUT

          if [[ $TEST_EXIT_CODE -eq 0 ]]; then
            echo ""
            echo "üéâ All tests completed successfully!"
            echo "   ‚Ä¢ Total time: ${MINUTES}m${SECONDS}s"
            echo "   ‚Ä¢ Tests executed: $TEST_COUNT"
            if [[ $TOTAL_DURATION -gt 0 ]]; then
              AVERAGE_SPEED=$(( (TEST_COUNT * 60) / TOTAL_DURATION ))
              echo "   ‚Ä¢ Average speed: $AVERAGE_SPEED tests/minute"
            fi
          else
            echo ""
            echo "‚ùå Tests failed with exit code $TEST_EXIT_CODE"
            echo "   ‚Ä¢ Total time: ${MINUTES}m${SECONDS}s"
            echo "   ‚Ä¢ Tests executed: $TEST_COUNT"
            if [[ -f test-failures.txt ]]; then
              FAILURE_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "   ‚Ä¢ Failed tests: $FAILURE_COUNT"
              if [[ $TEST_COUNT -gt 0 ]]; then
                SUCCESS_RATE=$(( (TEST_COUNT - FAILURE_COUNT) * 100 / TEST_COUNT ))
                echo "   ‚Ä¢ Success rate: $SUCCESS_RATE%"
              fi
            fi
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Fix coverage file naming (normalize to coverage.txt for downstream processing)
      # Handles magex commands (coverage_0.txt output)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîÑ Normalize coverage file name
        if: inputs.code-coverage-enabled == 'true'
        run: |
          echo "üîç Looking for coverage files..."
          ls -la coverage*.txt 2>/dev/null || true

          if [ -f coverage_0.txt ]; then
            cp coverage_0.txt coverage.txt
            echo "‚úÖ Copied coverage_0.txt to coverage.txt"
            echo "üìä Coverage file size: $(wc -c < coverage.txt) bytes"
          elif [ -f coverage.txt ]; then
            echo "‚úÖ Coverage file already exists as coverage.txt"
            echo "üìä Coverage file size: $(wc -c < coverage.txt) bytes"
          else
            echo "‚ùå No coverage file found!"
            echo "üìã Files in current directory:"
            ls -la *.txt *.out 2>/dev/null | head -10 || true
            echo "üìã Searching for any coverage-related files:"
            find . -maxdepth 1 -name "*cover*" -type f 2>/dev/null || true
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Enhanced test failure analysis and reporting
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üö® Create Test Failure Summary
        if: failure()
        run: |
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode || 'FULL' }}"
          TEST_COUNT="${{ steps.detect-mode.outputs.test-count || '0' }}"

          echo "## üö® Test Failures - ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ matrix.go-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Race Detection**: ${{ inputs.race-detection-enabled }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Coverage Enabled**: ${{ inputs.code-coverage-enabled }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Tests**: $TEST_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Output Mode**: $OUTPUT_MODE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Choose appropriate analysis based on output mode with robust detection
          # Source failure detection functions
          source test-failure-functions.sh 2>/dev/null || true

          if [[ "$OUTPUT_MODE" == "FULL" ]]; then
            # Enhanced analysis for FULL mode using robust detection
            OUTPUT_FILE="test-output.log"
            if [ -f "$OUTPUT_FILE" ]; then
              # Use robust failure counting from existing failure file or detect from output
              if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
                FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
                echo "üîç Using robust failure count: $FAIL_COUNT"
              else
                # Fallback: detect from output file
                detect_failures_from_text "$OUTPUT_FILE" "temp-failures.txt" || true
                FAIL_COUNT=$(wc -l < temp-failures.txt 2>/dev/null || echo "0")
                rm -f temp-failures.txt
                echo "‚ö†Ô∏è Fallback failure detection used: $FAIL_COUNT"
              fi

              # Enhanced panic detection with numeric validation
              PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" "$OUTPUT_FILE" 2>/dev/null || echo "0")
              PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
              [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

              PASS_COUNT=$(grep -c -E "^(PASS|ok[[:space:]]|---[[:space:]]*PASS)" "$OUTPUT_FILE" 2>/dev/null || echo "0")
              PASS_COUNT=$(echo "$PASS_COUNT" | tr -d '\n\r' | xargs)
              [[ "$PASS_COUNT" =~ ^[0-9]+$ ]] || PASS_COUNT=0

              echo "- **Passed Tests**: $PASS_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Failed Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              if [[ "$FAIL_COUNT" -gt 0 ]] && [[ -f test-failures.txt ]]; then
                echo "### üîç Failed Tests" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi

              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                echo "### üö® Panic/Error Summary" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                # Enhanced panic/error detection patterns
                grep -A 2 -B 1 -E "panic:|fatal error:|runtime error:" "$OUTPUT_FILE" | head -20 >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è Test output log not found" >> $GITHUB_STEP_SUMMARY
            fi

          else
            # Enhanced analysis for FAILURES_ONLY mode
            if [[ -f test-failures-summary.json ]] && [[ -s test-failures-summary.json ]]; then
              # Extract detailed failure information
              TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
              AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

              echo "- **Failed Tests**: $TOTAL_FAILURES" >> $GITHUB_STEP_SUMMARY
              echo "- **Affected Packages**: $AFFECTED_PACKAGES" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              # Show package-level summary
              if [[ "$AFFECTED_PACKAGES" -gt 0 ]]; then
                echo "### üì¶ Package-Level Failure Summary" >> $GITHUB_STEP_SUMMARY
                jq -r '.[] | "- **\(.package | split("/") | .[-1] // .[-2] // .)**: \(.failures | length) failure(s)"' \
                  test-failures-summary.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
                echo "" >> $GITHUB_STEP_SUMMARY

                # Show detailed failed tests (limited)
                echo "### üîç Failed Tests Details" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                jq -r '.[] | .failures[] | "\(.test) (package: \(.package | split("/") | .[-1] // .[-2] // .), duration: \(.elapsed // "unknown")s)"' \
                  test-failures-summary.json 2>/dev/null | head -${TEST_FAILURE_DETAIL_COUNT:-50} >> $GITHUB_STEP_SUMMARY || true
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY

                # Show error outputs if available
                ERROR_OUTPUTS=$(jq -r '.[] | select(.outputs != "") | .outputs' test-failures-summary.json 2>/dev/null | head -c 2000)
                if [[ -n "$ERROR_OUTPUTS" ]]; then
                  echo "### üìù Error Details (First 2000 characters)" >> $GITHUB_STEP_SUMMARY
                  echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                  echo "$ERROR_OUTPUTS" >> $GITHUB_STEP_SUMMARY
                  echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                fi
              fi

            elif [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
              # Fallback to simple text analysis
              FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "- **Failed Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              if [[ "$FAIL_COUNT" -gt 0 ]]; then
                echo "### üîç Failed Tests" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi

            else
              echo "‚ö†Ô∏è No failure details available - check artifacts for complete logs" >> $GITHUB_STEP_SUMMARY
            fi

            # Check for panics in tail log if available
            if [[ -f test-output-tail.log ]]; then
              PANIC_COUNT=$(grep -c "panic:" test-output-tail.log 2>/dev/null || echo "0")
              PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
              [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0
              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                echo "### üö® Recent Panics ($PANIC_COUNT found)" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                grep -A 2 -B 1 "panic:" test-output-tail.log | head -10 >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi

      - name: üìã Annotate Key Test Failures
        if: failure()
        run: |
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode || 'FULL' }}"
          TEST_COUNT="${{ steps.detect-mode.outputs.test-count || '0' }}"
          ANNOTATION_LIMIT="${TEST_FAILURE_ANNOTATION_COUNT:-10}"

          echo "::group::üìã Test Failure Analysis ($OUTPUT_MODE mode)"

          # Source failure detection functions for robust annotation
          source test-failure-functions.sh 2>/dev/null || true

          if [[ "$OUTPUT_MODE" == "FULL" ]] && [[ -f test-output.log ]]; then
            # Enhanced annotation approach for FULL mode with robust detection

            # Use robust failure counting from existing failure file
            if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
              FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "üîç Using robust failure count for annotation: $FAIL_COUNT"
            else
              # Fallback: detect from output file
              detect_failures_from_text "test-output.log" "temp-annotation-failures.txt" || true
              FAIL_COUNT=$(wc -l < temp-annotation-failures.txt 2>/dev/null || echo "0")
              echo "‚ö†Ô∏è Fallback failure detection for annotation: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" test-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "::error title=Test Suite Failed::$FAIL_COUNT tests failed, $PANIC_COUNT panics/errors detected on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

            # Annotate top failed tests using robust detection
            if [[ "$FAIL_COUNT" -gt 0 ]]; then
              if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
                head -$ANNOTATION_LIMIT test-failures.txt | while IFS= read -r line; do
                  echo "::error title=Failed Test::$line"
                done
              else
                # Fallback: use enhanced patterns
                grep -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" test-output.log | head -$ANNOTATION_LIMIT | while IFS= read -r line; do
                  echo "::error title=Failed Test::$line"
                done
              fi
            fi

            # Annotate panics/errors with enhanced patterns
            if [[ "$PANIC_COUNT" -gt 0 ]]; then
              grep -B 1 -E "panic:|fatal error:|runtime error:" test-output.log | head -3 | while IFS= read -r line; do
                echo "::error title=Test Panic/Error::$line"
              done
            fi

            # Cleanup temporary files
            rm -f temp-annotation-failures.txt

          else
            # Enhanced annotation for FAILURES_ONLY mode
            if [[ -f test-failures-summary.json ]] && [[ -s test-failures-summary.json ]]; then
              TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
              AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

              echo "::error title=Test Suite Failed::$TOTAL_FAILURES tests failed across $AFFECTED_PACKAGES packages on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

              # Annotate specific failed tests with package context
              jq -r '.[] | .failures[] | "\(.test) in \(.package | split("/") | .[-1] // .[-2] // .)"' \
                test-failures-summary.json 2>/dev/null | head -$ANNOTATION_LIMIT | while IFS= read -r line; do
                echo "::error title=Failed Test::$line"
              done

            elif [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
              # Fallback annotation
              FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "::error title=Test Suite Failed::$FAIL_COUNT tests failed on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

              head -$ANNOTATION_LIMIT test-failures.txt | while IFS= read -r line; do
                echo "::error title=Failed Test::$line"
              done

            else
              echo "::error title=Test Suite Failed::Tests failed on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests) - check artifacts for details"
            fi

            # Check for panics in tail log
            if [[ -f test-output-tail.log ]]; then
              PANIC_COUNT=$(grep -c "panic:" test-output-tail.log 2>/dev/null || echo "0")
              PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
              [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0
              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                grep -B 1 "panic:" test-output-tail.log | head -3 | while IFS= read -r line; do
                  echo "::error title=Test Panic::$line"
                done
              fi
            fi
          fi

          echo "::endgroup::"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # All test results are always captured
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìä Calculate test statistics
        id: test-summary
        if: always()
        run: |
          # Get the test exit code from the test step output
          TEST_EXIT_CODE="${{ steps.run-tests.outputs.test-exit-code || '0' }}"
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode || 'FULL' }}"
          DETECTED_TEST_COUNT="${{ steps.detect-mode.outputs.test-count || '0' }}"
          TEST_END=$(date +%s)
          TEST_DURATION=$((TEST_END - ${{ steps.test-timer.outputs.test-start || '0' }}))

          # Recount for verification (should match detected count)
          TEST_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Test[A-Z0-9_]' {} + | wc -l | xargs)
          TEST_COUNT=${TEST_COUNT:-0}

          # Count examples and benchmarks
          EXAMPLE_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -exec grep -h '^func Example' {} + | wc -l | xargs)
          EXAMPLE_COUNT=${EXAMPLE_COUNT:-0}

          BENCHMARK_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -exec grep -h '^func Benchmark' {} + | wc -l | xargs)
          BENCHMARK_COUNT=${BENCHMARK_COUNT:-0}

          STATS_FILE="test-stats-${{ matrix.os }}-${{ matrix.go-version }}.json"

          # Capture the output of "magex metrics:loc" and extract key information
          # Remove all ANSI codes and non-ASCII characters like emoji
          LOC_OUTPUT_RAW=$(magex metrics:loc 2>/dev/null | \
            sed -E 's/\x1b\[[0-9;]*[a-zA-Z]//g' | \
            iconv -c -f utf-8 -t ascii//IGNORE)

          # Extract LOC metrics
          TEST_FILES_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Test Files" | grep -oE '[0-9]+' | head -1)
          GO_FILES_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Go Files" | grep -oE '[0-9]+' | head -1)
          TOTAL_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Total lines of code:" | grep -oE '[0-9]+')
          CURRENT_DATE=$(date +"%Y-%m-%d")

          # Analyze failure details based on output mode with robust detection
          FAILURE_DETAILS="null"
          TOTAL_FAILURES=0
          AFFECTED_PACKAGES=0

          # Source failure detection functions
          source test-failure-functions.sh 2>/dev/null || true

          if [[ "$OUTPUT_MODE" == "FULL" ]] && [[ -f test-output.log ]]; then
            # Analyze output with robust failure detection
            if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
              # Use robust failure counting from existing failure file or detect from output
              if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
                TOTAL_FAILURES=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
                echo "üîç Using robust failure count for statistics: $TOTAL_FAILURES"
              else
                # Fallback: detect from output file with robust patterns
                detect_failures_from_text "test-output.log" "temp-stats-failures.txt" || true
                TOTAL_FAILURES=$(wc -l < temp-stats-failures.txt 2>/dev/null || echo "0")
                cp temp-stats-failures.txt test-failures.txt 2>/dev/null || touch test-failures.txt
                rm -f temp-stats-failures.txt
                echo "‚ö†Ô∏è Fallback failure detection for statistics: $TOTAL_FAILURES"
              fi

              if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
                # Create failure details from text file with proper JSON escaping
                FAILURE_LIST=$(head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt | \
                  sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g; s/\r/\\r/g' | \
                  awk '{print "    {\"test\": \"" $0 "\", \"package\": \"unknown\", \"duration\": null}"}' | \
                  paste -sd ',' - 2>/dev/null)
                if [[ -n "$FAILURE_LIST" ]]; then
                  FAILURE_DETAILS="[$FAILURE_LIST]"
                else
                  FAILURE_DETAILS="null"
                fi
              fi
            fi

          elif [[ "$OUTPUT_MODE" == "FAILURES_ONLY" ]] && [[ -f test-failures-summary.json ]]; then
            # Use enhanced failure analysis
            TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
            AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

            # Extract first N failure details for stats
            FAILURE_DETAILS=$(jq --argjson limit "${TEST_FAILURE_DETAIL_COUNT:-20}" \
              '[.[] as $pkg | $pkg.failures[] | {
                test: .test,
                package: $pkg.package,
                duration: .elapsed,
                error_snippet: ($pkg.outputs | split("\n")[0] | .[0:200])
              }] | .[0:$limit]' test-failures-summary.json 2>/dev/null || echo "null")

          elif [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]] && [[ -f test-failures.txt ]]; then
            # Fallback analysis
            TOTAL_FAILURES=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
          fi

          # Calculate output metrics
          OUTPUT_SIZE=0
          if [[ -f test-output.log ]]; then
            OUTPUT_SIZE=$(wc -c < test-output.log 2>/dev/null || echo "0")
          elif [[ -f test-output-tail.log ]]; then
            OUTPUT_SIZE=$(wc -c < test-output-tail.log 2>/dev/null || echo "0")
          fi

          # Build enhanced statistics JSON
          # Ensure FAILURE_DETAILS is safely escaped for JSON
          if [[ -z "$FAILURE_DETAILS" ]] || [[ "$FAILURE_DETAILS" == "" ]]; then
            FAILURE_DETAILS="null"
          fi

          # Pre-compute all dynamic values to avoid heredoc syntax issues
          TEST_PASSED_VALUE=$([ "${TEST_EXIT_CODE:-0}" -eq 0 ] && echo "true" || echo "false")
          RACE_ENABLED_VALUE=$([[ "${{ inputs.race-detection-enabled }}" == "true" ]] && echo "true" || echo "false")
          COVERAGE_ENABLED_VALUE=$([[ "${{ inputs.code-coverage-enabled }}" == "true" ]] && echo "true" || echo "false")
          TIMESTAMP_VALUE=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build JSON with pre-computed values to ensure heredoc stability
          cat > "$STATS_FILE" << EOF
          {
            "name": "${{ matrix.name }}",
            "os": "${{ matrix.os }}",
            "go_version": "${{ matrix.go-version }}",
            "test_mode": "$OUTPUT_MODE",
            "output_mode_used": "$OUTPUT_MODE",
            "duration_seconds": $TEST_DURATION,
            "test_count": $TEST_COUNT,
            "example_count": $EXAMPLE_COUNT,
            "benchmark_count": $BENCHMARK_COUNT,
            "status": "${{ job.status }}",
            "test_exit_code": ${TEST_EXIT_CODE:-0},
            "test_passed": $TEST_PASSED_VALUE,
            "total_failures": $TOTAL_FAILURES,
            "affected_packages": $AFFECTED_PACKAGES,
            "failure_details": $FAILURE_DETAILS,
            "output_size_bytes": $OUTPUT_SIZE,
            "race_enabled": $RACE_ENABLED_VALUE,
            "coverage_enabled": $COVERAGE_ENABLED_VALUE,
            "fuzz_run": false,
            "timestamp": "$TIMESTAMP_VALUE",
            "loc_test_files": ${TEST_FILES_COUNT:-0},
            "loc_go_files": ${GO_FILES_COUNT:-0},
            "loc_total": ${TOTAL_COUNT:-0},
            "loc_date": "$CURRENT_DATE"
          }
          EOF

          # Validate JSON before parsing to prevent parse errors
          echo "üìä Test statistics ($OUTPUT_MODE mode):"
          if ! jq empty "$STATS_FILE" 2>/dev/null; then
            echo "‚ùå ERROR: Generated JSON is malformed. Attempting to fix..."
            echo "üìã Raw JSON content:"
            cat "$STATS_FILE"
            echo ""
            echo "üìã JSON validation error:"
            jq empty "$STATS_FILE" 2>&1 || true

            # Create fallback minimal JSON - compute values safely first
            if [ "${TEST_EXIT_CODE:-0}" -eq 0 ]; then
              TEST_PASSED="true"
            else
              TEST_PASSED="false"
            fi

            # Use environment variables instead of template syntax
            MATRIX_NAME="${{ matrix.name || 'unknown' }}"
            MATRIX_OS="${{ matrix.os || 'unknown' }}"
            MATRIX_GO_VERSION="${{ matrix.go-version || 'unknown' }}"
            RACE_ENABLED="${{ inputs.race-detection-enabled || 'false' }}"
            COVERAGE_ENABLED="${{ inputs.code-coverage-enabled || 'false' }}"
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

            cat > "$STATS_FILE" << 'FALLBACK_EOF'
            {
              "name": "MATRIX_NAME_PLACEHOLDER",
              "os": "MATRIX_OS_PLACEHOLDER",
              "go_version": "MATRIX_GO_VERSION_PLACEHOLDER",
              "test_mode": "OUTPUT_MODE_PLACEHOLDER",
              "duration_seconds": "TEST_DURATION_PLACEHOLDER",
              "test_count": "TEST_COUNT_PLACEHOLDER",
              "status": "error",
              "test_exit_code": "TEST_EXIT_CODE_PLACEHOLDER",
              "test_passed": "TEST_PASSED_PLACEHOLDER",
              "total_failures": "TOTAL_FAILURES_PLACEHOLDER",
              "affected_packages": "AFFECTED_PACKAGES_PLACEHOLDER",
              "failure_details": null,
              "race_enabled": "RACE_ENABLED_PLACEHOLDER",
              "coverage_enabled": "COVERAGE_ENABLED_PLACEHOLDER",
              "timestamp": "TIMESTAMP_PLACEHOLDER",
              "json_generation_error": true
            }
            FALLBACK_EOF

            # Replace placeholders with actual values using safe delimiters
            sed -i.bak \
              -e "s/MATRIX_NAME_PLACEHOLDER/$MATRIX_NAME/g" \
              -e "s/MATRIX_OS_PLACEHOLDER/$MATRIX_OS/g" \
              -e "s/MATRIX_GO_VERSION_PLACEHOLDER/$MATRIX_GO_VERSION/g" \
              -e "s/OUTPUT_MODE_PLACEHOLDER/$OUTPUT_MODE/g" \
              -e "s/TEST_DURATION_PLACEHOLDER/$TEST_DURATION/g" \
              -e "s/TEST_COUNT_PLACEHOLDER/$TEST_COUNT/g" \
              -e "s/TEST_EXIT_CODE_PLACEHOLDER/${TEST_EXIT_CODE:-0}/g" \
              -e "s/TEST_PASSED_PLACEHOLDER/$TEST_PASSED/g" \
              -e "s/TOTAL_FAILURES_PLACEHOLDER/$TOTAL_FAILURES/g" \
              -e "s/AFFECTED_PACKAGES_PLACEHOLDER/$AFFECTED_PACKAGES/g" \
              -e "s/RACE_ENABLED_PLACEHOLDER/$RACE_ENABLED/g" \
              -e "s/COVERAGE_ENABLED_PLACEHOLDER/$COVERAGE_ENABLED/g" \
              -e "s|TIMESTAMP_PLACEHOLDER|$TIMESTAMP|g" \
              "$STATS_FILE"
            rm -f "$STATS_FILE.bak"
            echo "‚úÖ Created fallback JSON with essential statistics"
          fi

          jq . "$STATS_FILE"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload test artifacts
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload test outputs and statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.go-version }}
          path: |
            test-stats-*.json
            test-failures*.json
            test-failures*.jsonl
            test-failures.txt
            test-output*.log
            test-raw-output.log
            test-json-output.log
            test-stderr.log
          retention-days: ${{ env.TEST_OUTPUT_ARTIFACT_RETENTION_DAYS || 7 }}
          compression-level: ${{ env.TEST_OUTPUT_COMPRESS_ARTIFACTS == 'true' && '9' || '0' }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload test statistics (backward compatibility)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload test statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: test-stats-${{ matrix.os }}-${{ matrix.go-version }}
          path: test-stats-*.json
          retention-days: 1

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Verify coverage file before upload
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîç Verify coverage file
        if: inputs.code-coverage-enabled == 'true'
        run: |
          if [ -f coverage.txt ]; then
            echo "‚úÖ Coverage file exists"
            echo "üìä Coverage file size: $(wc -c < coverage.txt) bytes"
            echo "üìä Coverage file lines: $(wc -l < coverage.txt)"
            echo "üìä First line: $(head -1 coverage.txt)"
            echo "üìä Last line: $(tail -1 coverage.txt)"

            # Ensure the coverage file starts with valid coverage data
            FIRST_LINE=$(head -1 coverage.txt)
            if [[ "$FIRST_LINE" == "mode: atomic" ]] || [[ "$FIRST_LINE" == "mode: count" ]] || [[ "$FIRST_LINE" == "mode: set" ]]; then
              echo "‚úÖ Coverage file format looks valid"

              # Additional debugging info
              echo "üìã Sample coverage lines (lines 2-5):"
              sed -n '2,5p' coverage.txt

              # Check for any non-ASCII characters
              if file coverage.txt | grep -q "ASCII text"; then
                echo "‚úÖ File is pure ASCII text"
              else
                echo "‚ö†Ô∏è File may contain non-ASCII characters"
                file coverage.txt
              fi

              # Check file permissions
              echo "üìã File permissions: $(ls -la coverage.txt)"

              # List all coverage files in directory
              echo "üìã All coverage files in current directory:"
              ls -la *.txt *.out 2>/dev/null | grep -E "(coverage|cover)" || echo "No other coverage files found"

            else
              echo "‚ùå Coverage file may be corrupted. First line should be 'mode: atomic' or 'mode: count' but got: $FIRST_LINE"
              echo "üìã First 10 lines of coverage file:"
              head -10 coverage.txt
              exit 1
            fi
          else
            echo "‚ùå Coverage file not found!"
            echo "üìã Current directory: $(pwd)"
            echo "üìã Files in current directory:"
            ls -la
            exit 1
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload coverage data for processing
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload coverage data
        if: inputs.code-coverage-enabled == 'true' && matrix.os == inputs.primary-runner && matrix.go-version == inputs.go-primary-version
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: coverage-data
          path: coverage.txt
          retention-days: 1

  # ----------------------------------------------------------------------------------
  # Fuzz Tests (Parallel)
  # ----------------------------------------------------------------------------------
  fuzz-tests:
    name: üéØ Fuzz Tests
    if: inputs.fuzz-testing-enabled == 'true'
    timeout-minutes: 15 # Fuzz tests have shorter timeout
    permissions:
      contents: read # Read repository content for testing
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Parse environment variables
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "üìã Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Checkout code and set up Go environment
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì• Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup Go with caching and version management (primary version only)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üèóÔ∏è Setup Go with Cache
        id: setup-go-fuzz
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ inputs.go-primary-version }}
          matrix-os: ${{ inputs.primary-runner }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup MAGE-X (required for magex test commands)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ inputs.primary-runner }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Start fuzz test timer
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: ‚è±Ô∏è Start fuzz test timer
        id: fuzz-timer
        run: |
          echo "fuzz-start=$(date +%s)" >> $GITHUB_OUTPUT

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Run fuzz tests
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üéØ Run fuzz tests
        id: run-fuzz-tests
        continue-on-error: true
        run: |
          echo "üéØ Running fuzz tests in parallel..."
          FUZZ_TIMEOUT="${TEST_TIMEOUT_FUZZ:-5m}"
          magex test:fuzz time=5s -timeout $FUZZ_TIMEOUT 2>&1 | tee fuzz-output.log
          FUZZ_EXIT_CODE=${PIPESTATUS[0]}
          echo "üîß Fuzz tests completed with timeout: $FUZZ_TIMEOUT"

          # Store the exit code for later steps
          echo "FUZZ_EXIT_CODE=$FUZZ_EXIT_CODE" >> $GITHUB_ENV
          echo "fuzz-exit-code=$FUZZ_EXIT_CODE" >> $GITHUB_OUTPUT

          if [[ $FUZZ_EXIT_CODE -eq 0 ]]; then
            echo "‚úÖ Fuzz tests completed successfully"
          else
            echo "‚ùå Fuzz tests failed with exit code $FUZZ_EXIT_CODE"
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Fuzz test failure analysis and reporting
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üö® Create Fuzz Test Failure Summary
        if: failure()
        run: |
          echo "## üö® Fuzz Test Failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ inputs.primary-runner }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ inputs.go-primary-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f fuzz-output.log ]; then
            # Use robust failure detection for fuzz tests
            if command -v detect_failures_from_text >/dev/null 2>&1; then
              # Use robust detection if functions are available
              detect_failures_from_text "fuzz-output.log" "fuzz-failures.txt" || true
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "üîç Using robust fuzz failure detection: $FAIL_COUNT"
            else
              # Fallback: use enhanced patterns with numeric validation
              FAIL_COUNT=$(grep -c -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "‚ö†Ô∏è Using enhanced patterns for fuzz failure detection: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "- **Failed Fuzz Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAIL_COUNT" -gt 0 ]; then
              echo "### üîç Failed Fuzz Test Summary (First 5)" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -5 fuzz-failures.txt >> $GITHUB_STEP_SUMMARY
              else
                # Fallback: use enhanced patterns
                grep -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log | head -5 >> $GITHUB_STEP_SUMMARY
              fi
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$PANIC_COUNT" -gt 0 ]; then
              echo "### üö® Fuzz Test Panic/Error Summary" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              # Enhanced panic/error detection patterns
              grep -A 2 -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -20 >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è Fuzz test output log not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üìã Annotate Key Fuzz Test Failures
        if: failure()
        run: |
          if [ -f fuzz-output.log ]; then
            echo "::group::üìã Fuzz Test Failure Analysis (Enhanced)"

            # Count and report overall statistics using robust detection
            if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "üîç Using robust fuzz failure count for annotation: $FAIL_COUNT"
            else
              # Fallback: use enhanced patterns with numeric validation
              FAIL_COUNT=$(grep -c -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "‚ö†Ô∏è Using enhanced patterns for fuzz annotation: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "::error title=Fuzz Test Suite Failed::$FAIL_COUNT fuzz tests failed, $PANIC_COUNT panics/errors detected on ${{ inputs.primary-runner }} Go ${{ inputs.go-primary-version }}"

            # Annotate first 3 failed fuzz tests using robust detection
            if [[ "$FAIL_COUNT" -gt 0 ]]; then
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -3 fuzz-failures.txt | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              else
                # Fallback: use enhanced patterns
                grep -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log | head -3 | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              fi
            fi

            # Annotate panics/errors with enhanced patterns
            if [ "$PANIC_COUNT" -gt 0 ]; then
              grep -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -2 | while IFS= read -r line; do
                echo "::error title=Fuzz Test Panic/Error::$line"
              done
            fi

            echo "::endgroup::"
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Calculate fuzz test statistics
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìä Calculate fuzz test statistics
        id: fuzz-summary
        if: always()
        run: |
          # Get the fuzz test exit code from the fuzz test step output
          FUZZ_EXIT_CODE="${{ steps.run-fuzz-tests.outputs.fuzz-exit-code || '0' }}"
          FUZZ_END=$(date +%s)
          FUZZ_DURATION=$((FUZZ_END - ${{ steps.fuzz-timer.outputs.fuzz-start || '0' }}))
          FUZZ_TEST_COUNT=0

          # Count fuzz tests
          FUZZ_TEST_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Fuzz[A-Z0-9_]' {} + | wc -l | xargs)
          FUZZ_TEST_COUNT=${FUZZ_TEST_COUNT:-0}

          FUZZ_STATS_FILE="fuzz-stats-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}.json"

          # Pre-compute fuzz values to ensure heredoc stability
          FUZZ_PASSED_VALUE=$([ "${FUZZ_EXIT_CODE:-0}" -eq 0 ] && echo "true" || echo "false")
          FUZZ_TIMESTAMP_VALUE=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build fuzz JSON with pre-computed values
          cat > "$FUZZ_STATS_FILE" << EOF
          {
            "name": "Fuzz Tests (${{ inputs.primary-runner }})",
            "os": "${{ inputs.primary-runner }}",
            "go_version": "${{ inputs.go-primary-version }}",
            "duration_seconds": $FUZZ_DURATION,
            "fuzz_test_count": $FUZZ_TEST_COUNT,
            "status": "${{ job.status }}",
            "fuzz_exit_code": ${FUZZ_EXIT_CODE:-0},
            "fuzz_passed": $FUZZ_PASSED_VALUE,
            "fuzz_enabled": true,
            "timestamp": "$FUZZ_TIMESTAMP_VALUE"
          }
          EOF

          echo "üìä Fuzz test statistics:"
          if ! jq empty "$FUZZ_STATS_FILE" 2>/dev/null; then
            echo "‚ùå ERROR: Generated fuzz stats JSON is malformed"
            echo "üìã Raw JSON content:"
            cat "$FUZZ_STATS_FILE"
            echo "üìã JSON validation error:"
            jq empty "$FUZZ_STATS_FILE" 2>&1 || true
          else
            jq . "$FUZZ_STATS_FILE"
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload fuzz test statistics
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload fuzz test statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: fuzz-stats-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          path: fuzz-stats-*.json
          retention-days: 1

  # ----------------------------------------------------------------------------------
  # Validate Test Results
  # ----------------------------------------------------------------------------------
  validate-test-results:
    name: üîç Validate Test Results
    needs: [test-go, fuzz-tests]
    if: always() # Always run to check results even if jobs continued on error
    permissions:
      contents: read # Read repository content for validation
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Parse environment variables
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "üìã Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Download test statistics artifacts
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì• Download test statistics
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          pattern: "*-stats-*"
          path: test-results/
          merge-multiple: true

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Enhanced test results validation with failure details
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîç Validate test results
        run: |
          echo "üîç Validating test results from enhanced statistics..."
          VALIDATION_FAILED=false
          TOTAL_FAILURES=0
          TOTAL_TESTS=0

          # Check regular test results
          if compgen -G "test-results/test-stats-*.json" >/dev/null 2>&1; then
            echo "üìã Found test statistics files:"
            ls -la test-results/test-stats-*.json

            for stats_file in test-results/test-stats-*.json; do
              echo "üìä Checking $stats_file..."

              # Extract enhanced test results
              TEST_PASSED=$(jq -r '.test_passed // empty' "$stats_file")
              TEST_EXIT_CODE=$(jq -r '.test_exit_code // empty' "$stats_file")
              TEST_NAME=$(jq -r '.name // empty' "$stats_file")
              TEST_MODE=$(jq -r '.test_mode // "unknown"' "$stats_file")
              SUITE_FAILURES=$(jq -r '.total_failures // 0' "$stats_file")
              AFFECTED_PACKAGES=$(jq -r '.affected_packages // 0' "$stats_file")
              TEST_COUNT=$(jq -r '.test_count // 0' "$stats_file")

              echo "  ‚Ä¢ Test Suite: $TEST_NAME"
              echo "  ‚Ä¢ Mode: $TEST_MODE"
              echo "  ‚Ä¢ Tests: $TEST_COUNT"
              echo "  ‚Ä¢ Exit Code: $TEST_EXIT_CODE"
              echo "  ‚Ä¢ Passed: $TEST_PASSED"

              if [[ "$TEST_PASSED" == "false" ]] || [[ "$TEST_EXIT_CODE" != "0" ]]; then
                echo "  ‚Ä¢ Failed Tests: $SUITE_FAILURES"
                echo "  ‚Ä¢ Affected Packages: $AFFECTED_PACKAGES"

                # Show specific failure details if available
                FAILURE_DETAILS=$(jq -r '.failure_details // null' "$stats_file")
                if [[ "$FAILURE_DETAILS" != "null" ]] && [[ "$FAILURE_DETAILS" != "[]" ]]; then
                  echo "  ‚Ä¢ Failed Test Names:"
                  echo "$FAILURE_DETAILS" | jq -r '.[] | "    - \(.test) (\(.package | split("/") | .[-1] // .[-2] // .))"' 2>/dev/null | head -5 || true
                fi

                echo "‚ùå Test suite '$TEST_NAME' failed with exit code $TEST_EXIT_CODE ($SUITE_FAILURES failures)"
                VALIDATION_FAILED=true
                TOTAL_FAILURES=$((TOTAL_FAILURES + SUITE_FAILURES))
              else
                echo "‚úÖ Test suite '$TEST_NAME' passed"
              fi

              TOTAL_TESTS=$((TOTAL_TESTS + TEST_COUNT))
            done
          else
            echo "‚ö†Ô∏è No regular test statistics found"
          fi

          # Check fuzz test results if enabled
          if [[ "${{ inputs.fuzz-testing-enabled }}" == "true" ]]; then
            if compgen -G "test-results/fuzz-stats-*.json" >/dev/null 2>&1; then
              echo "üìã Found fuzz test statistics files:"
              ls -la test-results/fuzz-stats-*.json

              for stats_file in test-results/fuzz-stats-*.json; do
                echo "üìä Checking $stats_file..."

                # Extract fuzz test results
                FUZZ_PASSED=$(jq -r '.fuzz_passed // empty' "$stats_file")
                FUZZ_EXIT_CODE=$(jq -r '.fuzz_exit_code // empty' "$stats_file")
                FUZZ_NAME=$(jq -r '.name // empty' "$stats_file")

                echo "  ‚Ä¢ Fuzz Test: $FUZZ_NAME"
                echo "  ‚Ä¢ Exit Code: $FUZZ_EXIT_CODE"
                echo "  ‚Ä¢ Passed: $FUZZ_PASSED"

                if [[ "$FUZZ_PASSED" == "false" ]] || [[ "$FUZZ_EXIT_CODE" != "0" ]]; then
                  echo "‚ùå Fuzz test suite '$FUZZ_NAME' failed with exit code $FUZZ_EXIT_CODE"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Fuzz test suite '$FUZZ_NAME' passed"
                fi
              done
            else
              echo "‚ö†Ô∏è No fuzz test statistics found (fuzz testing was enabled)"
            fi
          fi

          # Enhanced validation summary
          echo ""
          echo "üèÅ Validation Summary:"
          echo "  ‚Ä¢ Total Tests: $TOTAL_TESTS"
          echo "  ‚Ä¢ Total Failures: $TOTAL_FAILURES"

          if [[ "$VALIDATION_FAILED" == "true" ]]; then
            echo "‚ùå Test validation failed - $TOTAL_FAILURES test(s) failed across all suites"
            echo "::error title=Test Validation Failed::$TOTAL_FAILURES test(s) failed across all test suites. Check enhanced failure details above."
            exit 1
          else
            echo "‚úÖ All $TOTAL_TESTS tests passed validation"
          fi

  # ----------------------------------------------------------------------------------
  # Process Coverage
  # ----------------------------------------------------------------------------------
  process-coverage:
    name: üìä Process Coverage
    needs: [test-go, validate-test-results]
    if: inputs.code-coverage-enabled == 'true' && !startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write # Write repository content and push to gh-pages branch for coverage processing
      pull-requests: write # Required: Coverage workflow needs to create PR comments
      pages: write # Required: Coverage workflow needs to deploy to GitHub Pages
      id-token: write # Required: Coverage workflow needs GitHub Pages authentication
      statuses: write # Required: Coverage workflow needs to create commit status checks
    uses: ./.github/workflows/fortress-coverage.yml
    with:
      coverage-file: coverage.txt
      branch-name: ${{ github.head_ref || github.ref_name }}
      commit-sha: ${{ github.sha }}
      env-json: ${{ inputs.env-json }}
      primary-runner: ${{ inputs.primary-runner }}
      event-name: ${{ github.event_name }}
      pr-number: ${{ github.event.pull_request.number }}
    secrets:
      github-token: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
