# ------------------------------------------------------------------------------------
#  Test Suite (Reusable Workflow) (GoFortress)
#
#  Purpose: Run the main Go test suite across multiple Go versions and operating
#  systems, including unit tests, race detection, coverage, and fuzz tests.
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Go Test Suite)

on:
  workflow_call:
    inputs:
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
      test-matrix:
        description: "Test matrix JSON"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
      go-primary-version:
        description: "Primary Go version"
        required: true
        type: string
      go-secondary-version:
        description: "Secondary Go version"
        required: true
        type: string
      code-coverage-enabled:
        description: "Whether code coverage is enabled"
        required: true
        type: string
      coverage-provider:
        description: "Coverage service provider (internal or codecov)"
        required: false
        type: string
        default: "internal"
      race-detection-enabled:
        description: "Whether race detection is enabled"
        required: true
        type: string
      fuzz-testing-enabled:
        description: "Whether fuzz testing is enabled"
        required: true
        type: string
    secrets:
      github-token:
        description: "GitHub token for API access"
        required: true
      CODECOV_TOKEN:
        description: "Codecov token for uploading coverage (required when coverage-provider is codecov)"
        required: false

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read

jobs:
  # ----------------------------------------------------------------------------------
  # Testing Matrix for Go (Parallel)
  # ----------------------------------------------------------------------------------
  test-go:
    name: ğŸ§ª Test (${{ matrix.name }})
    timeout-minutes: 30 # Prevent hung tests
    permissions:
      contents: write # Read repository content for testing
    strategy:
      fail-fast: true
      matrix: ${{ fromJSON(inputs.test-matrix) }}
    runs-on: ${{ matrix.os }}

    steps:
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Parse environment variables
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”§ Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "ğŸ“‹ Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Checkout code and set up Go environment
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Setup Go with caching and version management
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ—ï¸ Setup Go with Cache
        id: setup-go-test
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ matrix.go-version }}
          matrix-os: ${{ matrix.os }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Setup MAGE-X (required for magex test commands)
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”§ Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ matrix.os }}

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Start test timer
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: â±ï¸ Start test timer
        id: test-timer
        run: |
          echo "test-start=$(date +%s)" >> $GITHUB_OUTPUT

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Detect test output mode
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ” Detect test output mode
        id: detect-mode
        run: |
          # Count tests to determine appropriate output mode
          TEST_COUNT=$(find . -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Test[A-Z0-9_]' {} + | wc -l)

          OUTPUT_MODE="${TEST_OUTPUT_MODE:-SMART}"
          THRESHOLD="${TEST_OUTPUT_SMART_THRESHOLD:-500}"

          echo "ğŸ“Š Found $TEST_COUNT tests"
          echo "ğŸ›ï¸ Configured mode: $OUTPUT_MODE"
          echo "ğŸ¯ Smart threshold: $THRESHOLD tests"

          if [[ "$OUTPUT_MODE" == "SMART" ]]; then
            if [[ $TEST_COUNT -gt $THRESHOLD ]]; then
              DETECTED_MODE="FAILURES_ONLY"
              echo "ğŸ¯ Using FAILURES_ONLY mode for $TEST_COUNT tests"
            else
              DETECTED_MODE="FULL"
              echo "ğŸ“ Using FULL mode for $TEST_COUNT tests"
            fi
          else
            DETECTED_MODE="$OUTPUT_MODE"
            echo "ğŸ”§ Using configured mode: $DETECTED_MODE"
          fi

          echo "detected-mode=$DETECTED_MODE" >> $GITHUB_OUTPUT
          echo "test-count=$TEST_COUNT" >> $GITHUB_OUTPUT
          echo "DETECTED_OUTPUT_MODE=$DETECTED_MODE" >> $GITHUB_ENV
          echo "TEST_COUNT=$TEST_COUNT" >> $GITHUB_ENV

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Run tests and coverage
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ§ª Run tests
        id: run-tests
        continue-on-error: true
        run: |
          # Safely assign values to shell vars
          RACE="${{ inputs.race-detection-enabled }}"
          COVER="${{ inputs.code-coverage-enabled }}"
          MODE="${{ steps.detect-mode.outputs.detected-mode }}"

          echo "ğŸ” Race Detection Enabled: $RACE"
          echo "ğŸ” Code Coverage Enabled: $COVER"
          echo "ğŸ›ï¸ Output Mode: $MODE"

          # Initialize test exit code
          TEST_EXIT_CODE=0

          # Build unified magex command with timeout and appropriate test type
          if [[ "$RACE" == "true" && "$COVER" == "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT_RACE_COVER:-30m}"
            TEST_TYPE="coverrace"
            echo "ğŸ Running tests with race detection and coverage analysis (timeout: $TEST_TIMEOUT)..."
          elif [[ "$RACE" != "true" && "$COVER" == "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT_RACE_COVER:-30m}"
            TEST_TYPE="cover"
            echo "ğŸ Running tests with coverage analysis (timeout: $TEST_TIMEOUT)..."
          elif [[ "$RACE" == "true" && "$COVER" != "true" ]]; then
            TEST_TIMEOUT="${TEST_TIMEOUT:-30m}"
            TEST_TYPE="race"
            echo "ğŸ Running tests with race detection (timeout: $TEST_TIMEOUT)..."
          else
            TEST_TIMEOUT="${TEST_TIMEOUT_UNIT:-20m}"
            TEST_TYPE="unit"
            echo "ğŸ Running tests without coverage or race detection (timeout: $TEST_TIMEOUT)..."
          fi

          # Build command with JSON flag for FAILURES_ONLY mode
          MAGEX_CMD="magex test:${TEST_TYPE} -timeout $TEST_TIMEOUT"
          if [[ "$MODE" == "FAILURES_ONLY" ]]; then
            MAGEX_CMD="$MAGEX_CMD -json"
          fi

          echo "ğŸ”§ Running: $MAGEX_CMD (timeout: $TEST_TIMEOUT)"

          # Pre-execution diagnostic info for better visibility
          PACKAGE_COUNT=$(find . -name '*.go' -not -path './vendor/*' -not -path './third_party/*' | xargs dirname | sort -u | wc -l)
          echo "ğŸš€ Starting test execution:"
          echo "   â€¢ Total tests: $TEST_COUNT"
          echo "   â€¢ Test packages: $PACKAGE_COUNT"
          echo "   â€¢ Test mode: $TEST_TYPE"
          echo "   â€¢ Output mode: $MODE"
          echo "   â€¢ Estimated time: $(( ($TEST_COUNT + 49) / 50 )) minutes (based on ~50 tests/minute)"
          echo "   â€¢ Timeout: $TEST_TIMEOUT"
          echo ""

          START_TIME=$(date +%s)

          # Execute based on detected mode with simplified processing
          set +e  # Don't exit on error to capture exit code properly
          if [[ "$MODE" == "FULL" ]]; then
            echo "ğŸ“ Using FULL output mode - showing all test output"
            $MAGEX_CMD 2>&1 | tee test-output.log
            TEST_EXIT_CODE=${PIPESTATUS[0]}

            # Extract failures for summary (even in full mode)
            if [[ $TEST_EXIT_CODE -ne 0 ]]; then
              grep -E "^FAIL|--- FAIL" test-output.log > test-failures.txt 2>/dev/null || true
            fi

          else
            echo "ğŸ¯ Using FAILURES_ONLY mode with optimized JSON processing and progress monitoring"

            # Start background progress monitor
            (
              MONITOR_PID=$$
              PACKAGES_PROCESSED=0
              while sleep 30; do
                if ! kill -0 $MONITOR_PID 2>/dev/null; then break; fi
                ELAPSED=$(($(date +%s) - START_TIME))
                MINUTES=$((ELAPSED / 60))
                SECONDS=$((ELAPSED % 60))

                # Count completed tests by checking for individual test passes
                if [[ -f test-raw-output.log ]]; then
                  CURRENT_TESTS=$(grep -c '"Action":"pass".*"Test":"Test' test-raw-output.log 2>/dev/null || echo "0")
                  if [[ $CURRENT_TESTS -gt $PACKAGES_PROCESSED ]]; then
                    PACKAGES_PROCESSED=$CURRENT_TESTS
                    echo "â³ Progress update: ${MINUTES}m${SECONDS}s elapsed, ~${PACKAGES_PROCESSED}/${TEST_COUNT} tests completed"
                  else
                    echo "â³ Still running: ${MINUTES}m${SECONDS}s elapsed, processing tests..."
                  fi
                fi
              done
            ) &
            MONITOR_PID=$!

            # Optimized single-pass JSON processing with real-time progress
            $MAGEX_CMD 2> >(tee test-stderr.log >&2) | tee test-raw-output.log |
              tee test-json-output.log | jq -r --unbuffered '
              # Efficiently process each JSON line with progress indicators
              if .Action == "run" then
                # Package started - show progress
                "ğŸ“¦ Testing: \(.Package | split("/") | .[-1] // .[-2] // .)"
              elif .Action == "output" and .Test == null then
                # Package-level output (build messages, etc.)
                .Output // ""
              elif .Action == "fail" then
                # Failed test - immediate visibility
                "âŒ FAIL: \(.Test) (\(.Package | split("/") | .[-1] // .[-2] // .))"
              elif .Action == "pass" and (.Test | test("^Test")) then
                # Only show individual test passes occasionally to avoid spam
                if (now | floor) % 5 == 0 then
                  "âœ… PASS: \(.Test)"
                else
                  empty
                end
              else
                # Skip other JSON events for cleaner output
                empty
              end
            ' 2>/dev/null | tee test-output.log > test-output-tail.log

            # Kill the progress monitor
            kill $MONITOR_PID 2>/dev/null || true

            TEST_EXIT_CODE=${PIPESTATUS[0]}

            # Extract failures with simple approach
            if [[ $TEST_EXIT_CODE -ne 0 ]]; then
              echo "ğŸ” Extracting failure information..."
              # Create failures from the processed output
              grep "^--- FAIL:" test-output.log | sed 's/^--- FAIL: //' > test-failures.txt 2>/dev/null || true

              # For enhanced failure analysis, re-process raw JSON for detailed info
              jq -c --unbuffered 'select(.Action == "fail")' test-raw-output.log 2>/dev/null | \
                jq -s 'group_by(.Package) | map({
                  package: .[0].Package,
                  failures: map({test: .Test, elapsed: .Elapsed}),
                  outputs: []
                }) | map(select(.failures | length > 0))' > test-failures-summary.json 2>/dev/null || echo "[]" > test-failures-summary.json
            else
              echo "â„¹ï¸ No test failures detected"
            fi
          fi
          set -e  # Re-enable exit on error

          # Final execution summary with timing
          END_TIME=$(date +%s)
          TOTAL_DURATION=$((END_TIME - START_TIME))
          MINUTES=$((TOTAL_DURATION / 60))
          SECONDS=$((TOTAL_DURATION % 60))

          # Store the exit code and mode for later steps
          echo "TEST_EXIT_CODE=$TEST_EXIT_CODE" >> $GITHUB_ENV
          echo "test-exit-code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT
          echo "output-mode=$MODE" >> $GITHUB_OUTPUT

          if [[ $TEST_EXIT_CODE -eq 0 ]]; then
            echo ""
            echo "ğŸ‰ All tests completed successfully!"
            echo "   â€¢ Total time: ${MINUTES}m${SECONDS}s"
            echo "   â€¢ Tests executed: $TEST_COUNT"
            echo "   â€¢ Average speed: $(( (TEST_COUNT * 60) / TOTAL_DURATION )) tests/minute"
          else
            echo ""
            echo "âŒ Tests failed with exit code $TEST_EXIT_CODE"
            echo "   â€¢ Total time: ${MINUTES}m${SECONDS}s"
            echo "   â€¢ Tests executed: $TEST_COUNT"
            if [[ -f test-failures.txt ]]; then
              FAILURE_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "   â€¢ Failed tests: $FAILURE_COUNT"
              echo "   â€¢ Success rate: $(( (TEST_COUNT - FAILURE_COUNT) * 100 / TEST_COUNT ))%"
            fi
          fi

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Fix coverage file naming (normalize to coverage.txt for downstream processing)
      # Handles magex commands (coverage_0.txt output)
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”„ Normalize coverage file name
        if: inputs.code-coverage-enabled == 'true'
        run: |
          echo "ğŸ” Looking for coverage files..."
          ls -la coverage*.txt 2>/dev/null || true

          if [ -f coverage_0.txt ]; then
            cp coverage_0.txt coverage.txt
            echo "âœ… Copied coverage_0.txt to coverage.txt"
            echo "ğŸ“Š Coverage file size: $(wc -c < coverage.txt) bytes"
          elif [ -f coverage.txt ]; then
            echo "âœ… Coverage file already exists as coverage.txt"
            echo "ğŸ“Š Coverage file size: $(wc -c < coverage.txt) bytes"
          else
            echo "âŒ No coverage file found!"
            echo "ğŸ“‹ Files in current directory:"
            ls -la *.txt *.out 2>/dev/null | head -10 || true
            echo "ğŸ“‹ Searching for any coverage-related files:"
            find . -maxdepth 1 -name "*cover*" -type f 2>/dev/null || true
          fi

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Enhanced test failure analysis and reporting
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸš¨ Create Test Failure Summary
        if: failure()
        run: |
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode }}"
          TEST_COUNT="${{ steps.detect-mode.outputs.test-count }}"

          echo "## ğŸš¨ Test Failures - ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ matrix.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ matrix.go-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Race Detection**: ${{ inputs.race-detection-enabled }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Coverage Enabled**: ${{ inputs.code-coverage-enabled }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Tests**: $TEST_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Output Mode**: $OUTPUT_MODE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Choose appropriate analysis based on output mode
          if [[ "$OUTPUT_MODE" == "FULL" ]]; then
            # Traditional analysis for FULL mode
            OUTPUT_FILE="test-output.log"
            if [ -f "$OUTPUT_FILE" ]; then
              FAIL_COUNT=$(grep -c "^FAIL\|--- FAIL" "$OUTPUT_FILE" 2>/dev/null || echo "0")
              PANIC_COUNT=$(grep -c "panic:" "$OUTPUT_FILE" 2>/dev/null || echo "0")
              PASS_COUNT=$(grep -c "^PASS\|--- PASS" "$OUTPUT_FILE" 2>/dev/null || echo "0")

              echo "- **Passed Tests**: $PASS_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Failed Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              if [[ "$FAIL_COUNT" -gt 0 ]] && [[ -f test-failures.txt ]]; then
                echo "### ğŸ” Failed Tests" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi

              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                echo "### ğŸš¨ Panic Summary" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                grep -A 2 -B 1 "panic:" "$OUTPUT_FILE" | head -20 >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "âš ï¸ Test output log not found" >> $GITHUB_STEP_SUMMARY
            fi

          else
            # Enhanced analysis for FAILURES_ONLY mode
            if [[ -f test-failures-summary.json ]] && [[ -s test-failures-summary.json ]]; then
              # Extract detailed failure information
              TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
              AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

              echo "- **Failed Tests**: $TOTAL_FAILURES" >> $GITHUB_STEP_SUMMARY
              echo "- **Affected Packages**: $AFFECTED_PACKAGES" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              # Show package-level summary
              if [[ "$AFFECTED_PACKAGES" -gt 0 ]]; then
                echo "### ğŸ“¦ Package-Level Failure Summary" >> $GITHUB_STEP_SUMMARY
                jq -r '.[] | "- **\(.package | split("/") | .[-1] // .[-2] // .)**: \(.failures | length) failure(s)"' \
                  test-failures-summary.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
                echo "" >> $GITHUB_STEP_SUMMARY

                # Show detailed failed tests (limited)
                echo "### ğŸ” Failed Tests Details" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                jq -r '.[] | .failures[] | "\(.test) (package: \(.package | split("/") | .[-1] // .[-2] // .), duration: \(.elapsed // "unknown")s)"' \
                  test-failures-summary.json 2>/dev/null | head -${TEST_FAILURE_DETAIL_COUNT:-50} >> $GITHUB_STEP_SUMMARY || true
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY

                # Show error outputs if available
                ERROR_OUTPUTS=$(jq -r '.[] | select(.outputs != "") | .outputs' test-failures-summary.json 2>/dev/null | head -c 2000)
                if [[ -n "$ERROR_OUTPUTS" ]]; then
                  echo "### ğŸ“ Error Details (First 2000 characters)" >> $GITHUB_STEP_SUMMARY
                  echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                  echo "$ERROR_OUTPUTS" >> $GITHUB_STEP_SUMMARY
                  echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                fi
              fi

            elif [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
              # Fallback to simple text analysis
              FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "- **Failed Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              if [[ "$FAIL_COUNT" -gt 0 ]]; then
                echo "### ğŸ” Failed Tests" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi

            else
              echo "âš ï¸ No failure details available - check artifacts for complete logs" >> $GITHUB_STEP_SUMMARY
            fi

            # Check for panics in tail log if available
            if [[ -f test-output-tail.log ]]; then
              PANIC_COUNT=$(grep -c "panic:" test-output-tail.log 2>/dev/null || echo "0")
              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                echo "### ğŸš¨ Recent Panics ($PANIC_COUNT found)" >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                grep -A 2 -B 1 "panic:" test-output-tail.log | head -10 >> $GITHUB_STEP_SUMMARY
                echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi

      - name: ğŸ“‹ Annotate Key Test Failures
        if: failure()
        run: |
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode }}"
          TEST_COUNT="${{ steps.detect-mode.outputs.test-count }}"
          ANNOTATION_LIMIT="${TEST_FAILURE_ANNOTATION_COUNT:-10}"

          echo "::group::ğŸ“‹ Test Failure Analysis ($OUTPUT_MODE mode)"

          if [[ "$OUTPUT_MODE" == "FULL" ]] && [[ -f test-output.log ]]; then
            # Traditional annotation approach for FULL mode
            FAIL_COUNT=$(grep -c "^FAIL\|--- FAIL" test-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(grep -c "panic:" test-output.log 2>/dev/null || echo "0")

            echo "::error title=Test Suite Failed::$FAIL_COUNT tests failed, $PANIC_COUNT panics detected on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

            # Annotate top failed tests
            if [[ "$FAIL_COUNT" -gt 0 ]]; then
              grep -E "^FAIL\|--- FAIL" test-output.log | head -$ANNOTATION_LIMIT | while IFS= read -r line; do
                echo "::error title=Failed Test::$line"
              done
            fi

            # Annotate panics
            if [[ "$PANIC_COUNT" -gt 0 ]]; then
              grep -B 1 "panic:" test-output.log | head -3 | while IFS= read -r line; do
                echo "::error title=Test Panic::$line"
              done
            fi

          else
            # Enhanced annotation for FAILURES_ONLY mode
            if [[ -f test-failures-summary.json ]] && [[ -s test-failures-summary.json ]]; then
              TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
              AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

              echo "::error title=Test Suite Failed::$TOTAL_FAILURES tests failed across $AFFECTED_PACKAGES packages on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

              # Annotate specific failed tests with package context
              jq -r '.[] | .failures[] | "\(.test) in \(.package | split("/") | .[-1] // .[-2] // .)"' \
                test-failures-summary.json 2>/dev/null | head -$ANNOTATION_LIMIT | while IFS= read -r line; do
                echo "::error title=Failed Test::$line"
              done

            elif [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
              # Fallback annotation
              FAIL_COUNT=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
              echo "::error title=Test Suite Failed::$FAIL_COUNT tests failed on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests)"

              head -$ANNOTATION_LIMIT test-failures.txt | while IFS= read -r line; do
                echo "::error title=Failed Test::$line"
              done

            else
              echo "::error title=Test Suite Failed::Tests failed on ${{ matrix.os }} Go ${{ matrix.go-version }} ($TEST_COUNT total tests) - check artifacts for details"
            fi

            # Check for panics in tail log
            if [[ -f test-output-tail.log ]]; then
              PANIC_COUNT=$(grep -c "panic:" test-output-tail.log 2>/dev/null || echo "0")
              if [[ "$PANIC_COUNT" -gt 0 ]]; then
                grep -B 1 "panic:" test-output-tail.log | head -3 | while IFS= read -r line; do
                  echo "::error title=Test Panic::$line"
                done
              fi
            fi
          fi

          echo "::endgroup::"

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # All test results are always captured
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“Š Calculate test statistics
        id: test-summary
        if: always()
        run: |
          # Get the test exit code from the test step output
          TEST_EXIT_CODE="${{ steps.run-tests.outputs.test-exit-code }}"
          OUTPUT_MODE="${{ steps.run-tests.outputs.output-mode }}"
          DETECTED_TEST_COUNT="${{ steps.detect-mode.outputs.test-count }}"
          TEST_END=$(date +%s)
          TEST_DURATION=$((TEST_END - ${{ steps.test-timer.outputs.test-start }}))

          # Recount for verification (should match detected count)
          TEST_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Test[A-Z0-9_]' {} + | wc -l)

          # Count examples and benchmarks
          EXAMPLE_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -exec grep -h '^func Example' {} + | wc -l)

          BENCHMARK_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -exec grep -h '^func Benchmark' {} + | wc -l)

          STATS_FILE="test-stats-${{ matrix.os }}-${{ matrix.go-version }}.json"

          # Capture the output of "magex metrics:loc" and extract key information
          # Remove all ANSI codes and non-ASCII characters like emoji
          LOC_OUTPUT_RAW=$(magex metrics:loc 2>/dev/null | \
            sed -E 's/\x1b\[[0-9;]*[a-zA-Z]//g' | \
            iconv -c -f utf-8 -t ascii//IGNORE)

          # Extract LOC metrics
          TEST_FILES_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Test Files" | grep -oE '[0-9]+' | head -1)
          GO_FILES_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Go Files" | grep -oE '[0-9]+' | head -1)
          TOTAL_COUNT=$(echo "$LOC_OUTPUT_RAW" | grep "Total lines of code:" | grep -oE '[0-9]+')
          CURRENT_DATE=$(date +"%Y-%m-%d")

          # Analyze failure details based on output mode
          FAILURE_DETAILS="null"
          TOTAL_FAILURES=0
          AFFECTED_PACKAGES=0

          if [[ "$OUTPUT_MODE" == "FULL" ]] && [[ -f test-output.log ]]; then
            # Analyze traditional output
            if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
              TOTAL_FAILURES=$(grep -c "^FAIL\|--- FAIL" test-output.log 2>/dev/null || echo "0")
              if [[ -f test-failures.txt ]] && [[ -s test-failures.txt ]]; then
                # Create failure details from text file with proper JSON escaping
                FAILURE_LIST=$(head -${TEST_FAILURE_DETAIL_COUNT:-20} test-failures.txt | \
                  sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g; s/\r/\\r/g' | \
                  awk '{print "    {\"test\": \"" $0 "\", \"package\": \"unknown\", \"duration\": null}"}' | \
                  paste -sd ',' - 2>/dev/null)
                if [[ -n "$FAILURE_LIST" ]]; then
                  FAILURE_DETAILS="[$FAILURE_LIST]"
                else
                  FAILURE_DETAILS="null"
                fi
              fi
            fi

          elif [[ "$OUTPUT_MODE" == "FAILURES_ONLY" ]] && [[ -f test-failures-summary.json ]]; then
            # Use enhanced failure analysis
            TOTAL_FAILURES=$(jq '[.[] | .failures | length] | add // 0' test-failures-summary.json 2>/dev/null || echo "0")
            AFFECTED_PACKAGES=$(jq 'length' test-failures-summary.json 2>/dev/null || echo "0")

            # Extract first N failure details for stats
            FAILURE_DETAILS=$(jq --argjson limit "${TEST_FAILURE_DETAIL_COUNT:-20}" \
              '[.[] as $pkg | $pkg.failures[] | {
                test: .test,
                package: $pkg.package,
                duration: .elapsed,
                error_snippet: ($pkg.outputs | split("\n")[0] | .[0:200])
              }] | .[0:$limit]' test-failures-summary.json 2>/dev/null || echo "null")

          elif [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]] && [[ -f test-failures.txt ]]; then
            # Fallback analysis
            TOTAL_FAILURES=$(wc -l < test-failures.txt 2>/dev/null || echo "0")
          fi

          # Calculate output metrics
          OUTPUT_SIZE=0
          if [[ -f test-output.log ]]; then
            OUTPUT_SIZE=$(wc -c < test-output.log 2>/dev/null || echo "0")
          elif [[ -f test-output-tail.log ]]; then
            OUTPUT_SIZE=$(wc -c < test-output-tail.log 2>/dev/null || echo "0")
          fi

          # Build enhanced statistics JSON
          cat > "$STATS_FILE" << EOF
          {
            "name": "${{ matrix.name }}",
            "os": "${{ matrix.os }}",
            "go_version": "${{ matrix.go-version }}",
            "test_mode": "$OUTPUT_MODE",
            "output_mode_used": "$OUTPUT_MODE",
            "duration_seconds": $TEST_DURATION,
            "test_count": $TEST_COUNT,
            "example_count": $EXAMPLE_COUNT,
            "benchmark_count": $BENCHMARK_COUNT,
            "status": "${{ job.status }}",
            "test_exit_code": ${TEST_EXIT_CODE:-0},
            "test_passed": $([ "${TEST_EXIT_CODE:-0}" -eq 0 ] && echo "true" || echo "false"),
            "total_failures": $TOTAL_FAILURES,
            "affected_packages": $AFFECTED_PACKAGES,
            "failure_details": $FAILURE_DETAILS,
            "output_size_bytes": $OUTPUT_SIZE,
            "race_enabled": $([[ "${{ inputs.race-detection-enabled }}" == "true" ]] && echo "true" || echo "false"),
            "coverage_enabled": $([[ "${{ inputs.code-coverage-enabled }}" == "true" ]] && echo "true" || echo "false"),
            "fuzz_run": false,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "loc_test_files": ${TEST_FILES_COUNT:-0},
            "loc_go_files": ${GO_FILES_COUNT:-0},
            "loc_total": ${TOTAL_COUNT:-0},
            "loc_date": "$CURRENT_DATE"
          }
          EOF

          # Validate JSON before parsing to prevent parse errors
          echo "ğŸ“Š Test statistics ($OUTPUT_MODE mode):"
          if ! jq empty "$STATS_FILE" 2>/dev/null; then
            echo "âŒ ERROR: Generated JSON is malformed. Attempting to fix..."
            echo "ğŸ“‹ Raw JSON content:"
            cat "$STATS_FILE"
            echo ""
            echo "ğŸ“‹ JSON validation error:"
            jq empty "$STATS_FILE" 2>&1 || true

            # Create fallback minimal JSON
            cat > "$STATS_FILE" << FALLBACK_EOF
{
  "name": "${{ matrix.name }}",
  "os": "${{ matrix.os }}",
  "go_version": "${{ matrix.go-version }}",
  "test_mode": "$OUTPUT_MODE",
  "duration_seconds": $TEST_DURATION,
  "test_count": $TEST_COUNT,
  "status": "error",
  "test_exit_code": ${TEST_EXIT_CODE:-0},
  "test_passed": $([ "${TEST_EXIT_CODE:-0}" -eq 0 ] && echo "true" || echo "false"),
  "total_failures": $TOTAL_FAILURES,
  "affected_packages": $AFFECTED_PACKAGES,
  "failure_details": null,
  "race_enabled": $([[ "${{ inputs.race-detection-enabled }}" == "true" ]] && echo "true" || echo "false"),
  "coverage_enabled": $([[ "${{ inputs.code-coverage-enabled }}" == "true" ]] && echo "true" || echo "false"),
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "json_generation_error": true
}
FALLBACK_EOF
            echo "âœ… Created fallback JSON with essential statistics"
          fi

          jq . "$STATS_FILE"

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Upload test artifacts
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¤ Upload test outputs and statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.go-version }}
          path: |
            test-stats-*.json
            test-failures*.json
            test-failures*.jsonl
            test-failures.txt
            test-output*.log
            test-raw-output.log
            test-json-output.log
            test-stderr.log
          retention-days: ${{ env.TEST_OUTPUT_ARTIFACT_RETENTION_DAYS || 7 }}
          compression-level: ${{ env.TEST_OUTPUT_COMPRESS_ARTIFACTS == 'true' && '9' || '0' }}

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Upload test statistics (backward compatibility)
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¤ Upload test statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: test-stats-${{ matrix.os }}-${{ matrix.go-version }}
          path: test-stats-*.json
          retention-days: 1

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Verify coverage file before upload
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ” Verify coverage file
        if: inputs.code-coverage-enabled == 'true'
        run: |
          if [ -f coverage.txt ]; then
            echo "âœ… Coverage file exists"
            echo "ğŸ“Š Coverage file size: $(wc -c < coverage.txt) bytes"
            echo "ğŸ“Š Coverage file lines: $(wc -l < coverage.txt)"
            echo "ğŸ“Š First line: $(head -1 coverage.txt)"
            echo "ğŸ“Š Last line: $(tail -1 coverage.txt)"

            # Ensure the coverage file starts with valid coverage data
            FIRST_LINE=$(head -1 coverage.txt)
            if [[ "$FIRST_LINE" == "mode: atomic" ]] || [[ "$FIRST_LINE" == "mode: count" ]] || [[ "$FIRST_LINE" == "mode: set" ]]; then
              echo "âœ… Coverage file format looks valid"

              # Additional debugging info
              echo "ğŸ“‹ Sample coverage lines (lines 2-5):"
              sed -n '2,5p' coverage.txt

              # Check for any non-ASCII characters
              if file coverage.txt | grep -q "ASCII text"; then
                echo "âœ… File is pure ASCII text"
              else
                echo "âš ï¸ File may contain non-ASCII characters"
                file coverage.txt
              fi

              # Check file permissions
              echo "ğŸ“‹ File permissions: $(ls -la coverage.txt)"

              # List all coverage files in directory
              echo "ğŸ“‹ All coverage files in current directory:"
              ls -la *.txt *.out 2>/dev/null | grep -E "(coverage|cover)" || echo "No other coverage files found"

            else
              echo "âŒ Coverage file may be corrupted. First line should be 'mode: atomic' or 'mode: count' but got: $FIRST_LINE"
              echo "ğŸ“‹ First 10 lines of coverage file:"
              head -10 coverage.txt
              exit 1
            fi
          else
            echo "âŒ Coverage file not found!"
            echo "ğŸ“‹ Current directory: $(pwd)"
            echo "ğŸ“‹ Files in current directory:"
            ls -la
            exit 1
          fi

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Upload coverage data for processing
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¤ Upload coverage data
        if: inputs.code-coverage-enabled == 'true' && matrix.os == inputs.primary-runner && matrix.go-version == inputs.go-primary-version
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: coverage-data
          path: coverage.txt
          retention-days: 1

  # ----------------------------------------------------------------------------------
  # Fuzz Tests (Parallel)
  # ----------------------------------------------------------------------------------
  fuzz-tests:
    name: ğŸ¯ Fuzz Tests
    if: inputs.fuzz-testing-enabled == 'true'
    timeout-minutes: 15 # Fuzz tests have shorter timeout
    permissions:
      contents: read # Read repository content for testing
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Parse environment variables
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”§ Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "ğŸ“‹ Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Checkout code and set up Go environment
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Setup Go with caching and version management (primary version only)
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ—ï¸ Setup Go with Cache
        id: setup-go-fuzz
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ inputs.go-primary-version }}
          matrix-os: ${{ inputs.primary-runner }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Setup MAGE-X (required for magex test commands)
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”§ Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ inputs.primary-runner }}

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Start fuzz test timer
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: â±ï¸ Start fuzz test timer
        id: fuzz-timer
        run: |
          echo "fuzz-start=$(date +%s)" >> $GITHUB_OUTPUT

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Run fuzz tests
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ¯ Run fuzz tests
        id: run-fuzz-tests
        continue-on-error: true
        run: |
          echo "ğŸ¯ Running fuzz tests in parallel..."
          FUZZ_TIMEOUT="${TEST_TIMEOUT_FUZZ:-5m}"
          magex test:fuzz time=5s -timeout $FUZZ_TIMEOUT 2>&1 | tee fuzz-output.log
          FUZZ_EXIT_CODE=${PIPESTATUS[0]}
          echo "ğŸ”§ Fuzz tests completed with timeout: $FUZZ_TIMEOUT"

          # Store the exit code for later steps
          echo "FUZZ_EXIT_CODE=$FUZZ_EXIT_CODE" >> $GITHUB_ENV
          echo "fuzz-exit-code=$FUZZ_EXIT_CODE" >> $GITHUB_OUTPUT

          if [[ $FUZZ_EXIT_CODE -eq 0 ]]; then
            echo "âœ… Fuzz tests completed successfully"
          else
            echo "âŒ Fuzz tests failed with exit code $FUZZ_EXIT_CODE"
          fi

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Fuzz test failure analysis and reporting
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸš¨ Create Fuzz Test Failure Summary
        if: failure()
        run: |
          echo "## ğŸš¨ Fuzz Test Failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ inputs.primary-runner }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ inputs.go-primary-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f fuzz-output.log ]; then
            FAIL_COUNT=$(grep -c "^FAIL\|--- FAIL" fuzz-output.log || echo "0")
            PANIC_COUNT=$(grep -c "panic:" fuzz-output.log || echo "0")
            echo "- **Failed Fuzz Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAIL_COUNT" -gt 0 ]; then
              echo "### ğŸ” Failed Fuzz Test Summary (First 5)" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              grep -E "^FAIL\|--- FAIL" fuzz-output.log | head -5 >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$PANIC_COUNT" -gt 0 ]; then
              echo "### ğŸš¨ Fuzz Test Panic Summary" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              grep -A 2 -B 1 "panic:" fuzz-output.log | head -20 >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Fuzz test output log not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ğŸ“‹ Annotate Key Fuzz Test Failures
        if: failure()
        run: |
          if [ -f fuzz-output.log ]; then
            echo "::group::ğŸ“‹ Fuzz Test Failure Analysis"

            # Count and report overall statistics
            FAIL_COUNT=$(grep -c "^FAIL\|--- FAIL" fuzz-output.log || echo "0")
            PANIC_COUNT=$(grep -c "panic:" fuzz-output.log || echo "0")

            echo "::error title=Fuzz Test Suite Failed::$FAIL_COUNT fuzz tests failed, $PANIC_COUNT panics detected on ${{ inputs.primary-runner }} Go ${{ inputs.go-primary-version }}"

            # Annotate first 3 failed fuzz tests
            grep -E "^FAIL\|--- FAIL" fuzz-output.log | head -3 | while IFS= read -r line; do
              echo "::error title=Failed Fuzz Test::$line"
            done

            # Annotate panics
            if [ "$PANIC_COUNT" -gt 0 ]; then
              grep -B 1 "panic:" fuzz-output.log | head -2 | while IFS= read -r line; do
                echo "::error title=Fuzz Test Panic::$line"
              done
            fi

            echo "::endgroup::"
          fi

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Calculate fuzz test statistics
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“Š Calculate fuzz test statistics
        id: fuzz-summary
        if: always()
        run: |
          # Get the fuzz test exit code from the fuzz test step output
          FUZZ_EXIT_CODE="${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }}"
          FUZZ_END=$(date +%s)
          FUZZ_DURATION=$((FUZZ_END - ${{ steps.fuzz-timer.outputs.fuzz-start }}))
          FUZZ_TEST_COUNT=0

          # Count fuzz tests
          FUZZ_TEST_COUNT=$(find . -type f -name '*_test.go' \
            -not -path './vendor/*' \
            -not -path './third_party/*' \
            -not -path './testdata/*' \
            -exec grep -hE '^\s*func (\([^)]+\) )?Fuzz[A-Z0-9_]' {} + | wc -l)

          FUZZ_STATS_FILE="fuzz-stats-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}.json"

          cat > "$FUZZ_STATS_FILE" << EOF
          {
            "name": "Fuzz Tests (${{ inputs.primary-runner }})",
            "os": "${{ inputs.primary-runner }}",
            "go_version": "${{ inputs.go-primary-version }}",
            "duration_seconds": $FUZZ_DURATION,
            "fuzz_test_count": $FUZZ_TEST_COUNT,
            "status": "${{ job.status }}",
            "fuzz_exit_code": ${FUZZ_EXIT_CODE:-0},
            "fuzz_passed": $([ "${FUZZ_EXIT_CODE:-0}" -eq 0 ] && echo "true" || echo "false"),
            "fuzz_enabled": true,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          echo "ğŸ“Š Fuzz test statistics:"
          jq . "$FUZZ_STATS_FILE"

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Upload fuzz test statistics
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¤ Upload fuzz test statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: fuzz-stats-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          path: fuzz-stats-*.json
          retention-days: 1

  # ----------------------------------------------------------------------------------
  # Validate Test Results
  # ----------------------------------------------------------------------------------
  validate-test-results:
    name: ğŸ” Validate Test Results
    needs: [test-go, fuzz-tests]
    if: always() # Always run to check results even if jobs continued on error
    permissions:
      contents: read # Read repository content for validation
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Parse environment variables
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ”§ Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "ğŸ“‹ Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Download test statistics artifacts
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ“¥ Download test statistics
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          pattern: "*-stats-*"
          path: test-results/
          merge-multiple: true

      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      # Enhanced test results validation with failure details
      # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      - name: ğŸ” Validate test results
        run: |
          echo "ğŸ” Validating test results from enhanced statistics..."
          VALIDATION_FAILED=false
          TOTAL_FAILURES=0
          TOTAL_TESTS=0

          # Check regular test results
          if compgen -G "test-results/test-stats-*.json" >/dev/null 2>&1; then
            echo "ğŸ“‹ Found test statistics files:"
            ls -la test-results/test-stats-*.json

            for stats_file in test-results/test-stats-*.json; do
              echo "ğŸ“Š Checking $stats_file..."

              # Extract enhanced test results
              TEST_PASSED=$(jq -r '.test_passed // empty' "$stats_file")
              TEST_EXIT_CODE=$(jq -r '.test_exit_code // empty' "$stats_file")
              TEST_NAME=$(jq -r '.name // empty' "$stats_file")
              TEST_MODE=$(jq -r '.test_mode // "unknown"' "$stats_file")
              SUITE_FAILURES=$(jq -r '.total_failures // 0' "$stats_file")
              AFFECTED_PACKAGES=$(jq -r '.affected_packages // 0' "$stats_file")
              TEST_COUNT=$(jq -r '.test_count // 0' "$stats_file")

              echo "  â€¢ Test Suite: $TEST_NAME"
              echo "  â€¢ Mode: $TEST_MODE"
              echo "  â€¢ Tests: $TEST_COUNT"
              echo "  â€¢ Exit Code: $TEST_EXIT_CODE"
              echo "  â€¢ Passed: $TEST_PASSED"

              if [[ "$TEST_PASSED" == "false" ]] || [[ "$TEST_EXIT_CODE" != "0" ]]; then
                echo "  â€¢ Failed Tests: $SUITE_FAILURES"
                echo "  â€¢ Affected Packages: $AFFECTED_PACKAGES"

                # Show specific failure details if available
                FAILURE_DETAILS=$(jq -r '.failure_details // null' "$stats_file")
                if [[ "$FAILURE_DETAILS" != "null" ]] && [[ "$FAILURE_DETAILS" != "[]" ]]; then
                  echo "  â€¢ Failed Test Names:"
                  echo "$FAILURE_DETAILS" | jq -r '.[] | "    - \(.test) (\(.package | split("/") | .[-1] // .[-2] // .))"' 2>/dev/null | head -5 || true
                fi

                echo "âŒ Test suite '$TEST_NAME' failed with exit code $TEST_EXIT_CODE ($SUITE_FAILURES failures)"
                VALIDATION_FAILED=true
                TOTAL_FAILURES=$((TOTAL_FAILURES + SUITE_FAILURES))
              else
                echo "âœ… Test suite '$TEST_NAME' passed"
              fi

              TOTAL_TESTS=$((TOTAL_TESTS + TEST_COUNT))
            done
          else
            echo "âš ï¸ No regular test statistics found"
          fi

          # Check fuzz test results if enabled
          if [[ "${{ inputs.fuzz-testing-enabled }}" == "true" ]]; then
            if compgen -G "test-results/fuzz-stats-*.json" >/dev/null 2>&1; then
              echo "ğŸ“‹ Found fuzz test statistics files:"
              ls -la test-results/fuzz-stats-*.json

              for stats_file in test-results/fuzz-stats-*.json; do
                echo "ğŸ“Š Checking $stats_file..."

                # Extract fuzz test results
                FUZZ_PASSED=$(jq -r '.fuzz_passed // empty' "$stats_file")
                FUZZ_EXIT_CODE=$(jq -r '.fuzz_exit_code // empty' "$stats_file")
                FUZZ_NAME=$(jq -r '.name // empty' "$stats_file")

                echo "  â€¢ Fuzz Test: $FUZZ_NAME"
                echo "  â€¢ Exit Code: $FUZZ_EXIT_CODE"
                echo "  â€¢ Passed: $FUZZ_PASSED"

                if [[ "$FUZZ_PASSED" == "false" ]] || [[ "$FUZZ_EXIT_CODE" != "0" ]]; then
                  echo "âŒ Fuzz test suite '$FUZZ_NAME' failed with exit code $FUZZ_EXIT_CODE"
                  VALIDATION_FAILED=true
                else
                  echo "âœ… Fuzz test suite '$FUZZ_NAME' passed"
                fi
              done
            else
              echo "âš ï¸ No fuzz test statistics found (fuzz testing was enabled)"
            fi
          fi

          # Enhanced validation summary
          echo ""
          echo "ğŸ Validation Summary:"
          echo "  â€¢ Total Tests: $TOTAL_TESTS"
          echo "  â€¢ Total Failures: $TOTAL_FAILURES"

          if [[ "$VALIDATION_FAILED" == "true" ]]; then
            echo "âŒ Test validation failed - $TOTAL_FAILURES test(s) failed across all suites"
            echo "::error title=Test Validation Failed::$TOTAL_FAILURES test(s) failed across all test suites. Check enhanced failure details above."
            exit 1
          else
            echo "âœ… All $TOTAL_TESTS tests passed validation"
          fi

  # ----------------------------------------------------------------------------------
  # Process Coverage
  # ----------------------------------------------------------------------------------
  process-coverage:
    name: ğŸ“Š Process Coverage
    needs: [test-go, validate-test-results]
    if: inputs.code-coverage-enabled == 'true' && !startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write # Write repository content and push to gh-pages branch for coverage processing
      pull-requests: write # Required: Coverage workflow needs to create PR comments
      pages: write # Required: Coverage workflow needs to deploy to GitHub Pages
      id-token: write # Required: Coverage workflow needs GitHub Pages authentication
      statuses: write # Required: Coverage workflow needs to create commit status checks
    uses: ./.github/workflows/fortress-coverage.yml
    with:
      coverage-file: coverage.txt
      branch-name: ${{ github.head_ref || github.ref_name }}
      commit-sha: ${{ github.sha }}
      env-json: ${{ inputs.env-json }}
      primary-runner: ${{ inputs.primary-runner }}
      event-name: ${{ github.event_name }}
      pr-number: ${{ github.event.pull_request.number }}
    secrets:
      github-token: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
