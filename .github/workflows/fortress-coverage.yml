# ------------------------------------------------------------------------------------
#  GoFortress Coverage System (Streamlined)
#
#  Purpose: Process Go coverage data, generate reports and badges, deploy to GitHub Pages
#  with trend/history tracking via artifacts.
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Coverage System)

on:
  workflow_call:
    inputs:
      coverage-file:
        description: "Path to coverage profile"
        required: true
        type: string
      branch-name:
        description: "Current branch name"
        required: true
        type: string
      commit-sha:
        description: "Commit SHA"
        required: true
        type: string
      env-json:
        description: "Environment configuration"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
    secrets:
      github-token:
        description: "GitHub token for API access"
        required: true

# Security: Restrictive default permissions with job-level overrides
permissions:
  contents: read

jobs:
  # ----------------------------------------------------------------------------------
  # Process Coverage and Deploy to GitHub Pages
  # ----------------------------------------------------------------------------------
  process-coverage:
    name: 📊 Process Coverage & Deploy
    runs-on: ${{ inputs.primary-runner }}
    timeout-minutes: 10
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      contents: write
      pages: write
      id-token: write
      pull-requests: write # Required for creating PR comments
      statuses: write

    steps:
      # ————————————————————————————————————————————————————————————————
      # Setup and environment
      # ————————————————————————————————————————————————————————————————
      - name: 🔧 Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      - name: 📥 Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0 # Fetch all history including tags for version display

      # ————————————————————————————————————————————————————————————————
      # Set up Go cache paths and restore caches
      # ————————————————————————————————————————————————————————————————
      - name: 🔧 Set Go cache paths (cross-platform)
        run: |
          echo "🔧 Setting up Go cache paths..."
          echo "GOCACHE=$HOME/.cache/go-build"        >> $GITHUB_ENV
          echo "GOMODCACHE=$HOME/go/pkg/mod"          >> $GITHUB_ENV
          echo "GOLANGCI_LINT_CACHE=$HOME/.cache/golangci-lint" >> $GITHUB_ENV

      - name: 💾 Restore Go module cache
        id: restore-gomod
        uses: actions/cache/restore@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
        with:
          path: ~/go/pkg/mod
          key: ${{ inputs.primary-runner }}-gomod-${{ hashFiles('**/go.sum', '.github/coverage/go.sum', '.github/pre-commit/go.sum') }}
          restore-keys: |
            ${{ inputs.primary-runner }}-gomod-

      - name: 💾 Restore Go build cache
        id: restore-gobuild
        uses: actions/cache/restore@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
        with:
          path: |
            ~/.cache/go-build
            ~/.cache/go-build/test
          key: ${{ inputs.primary-runner }}-gobuild-${{ env.GO_PRIMARY_VERSION }}-${{ hashFiles('**/go.sum', '.github/coverage/go.sum', '.github/pre-commit/go.sum') }}
          restore-keys: |
            ${{ inputs.primary-runner }}-gobuild-${{ env.GO_PRIMARY_VERSION }}-

      - name: 🔧 Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: ${{ env.GO_PRIMARY_VERSION }}
          cache: false # we handle caches ourselves

      - name: 🔨 Build coverage tool
        working-directory: .github/coverage/cmd/gofortress-coverage
        run: |
          go build -v -o gofortress-coverage .
          chmod +x gofortress-coverage
          # Store the full path for later use
          echo "GOFORTRESS_BINARY=$(pwd)/gofortress-coverage" >> $GITHUB_ENV

      # ————————————————————————————————————————————————————————————————
      # Download and restore coverage history (WORKING SYSTEM - PRESERVED)
      # ————————————————————————————————————————————————————————————————
      - name: 📥 Download previous coverage history
        # Download history for all branches to enable trend analysis
        if: github.event_name == 'push'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "📥 Downloading previous coverage history using GitHub API..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Create history artifacts directory
          mkdir -p .github/coverage/history-artifacts/
          echo "📁 Created history artifacts directory"

          # Check GitHub CLI availability and authentication
          if ! command -v gh &> /dev/null; then
            echo "❌ GitHub CLI (gh) is not available"
            echo "ℹ️ Skipping history download - this will not affect coverage processing"
            exit 0
          fi

          if ! gh auth status &> /dev/null; then
            echo "❌ GitHub CLI is not authenticated"
            echo "ℹ️ Skipping history download - this will not affect coverage processing"
            exit 0
          fi

          echo "✅ GitHub CLI is available and authenticated"

          # Get recent successful workflow runs (prioritize current branch, then master)
          echo "🔍 Fetching recent successful workflow runs..."
          CURRENT_BRANCH="${{ inputs.branch-name }}"
          echo "📌 Current branch: $CURRENT_BRANCH"

          # First try to get runs from current branch
          WORKFLOW_RUNS=$(gh api repos/${{ github.repository }}/actions/runs \
            --jq ".workflow_runs[] | select(.status == \"completed\" and .conclusion == \"success\" and .head_branch == \"$CURRENT_BRANCH\") | .id" \
            --paginate 2>/dev/null | head -5 || echo "")

          # If no runs found for current branch and it's not master, also get master branch history
          if [[ -z "$WORKFLOW_RUNS" ]] && [[ "$CURRENT_BRANCH" != "master" ]]; then
            echo "ℹ️ No history found for branch '$CURRENT_BRANCH', checking master branch..."
            WORKFLOW_RUNS=$(gh api repos/${{ github.repository }}/actions/runs \
              --jq '.workflow_runs[] | select(.status == "completed" and .conclusion == "success" and .head_branch == "master") | .id' \
              --paginate 2>/dev/null | head -3 || echo "")
          fi

          if [[ -z "$WORKFLOW_RUNS" ]]; then
            echo "ℹ️ No recent successful workflow runs found"
            echo "📝 This is normal for:"
            echo "  - First run on this repository"
            echo "  - First successful run after setup"
            echo "  - GitHub API rate limiting or connectivity issues"
            exit 0
          fi

          echo "📊 Found $(echo "$WORKFLOW_RUNS" | wc -l) recent successful runs"
          echo "📋 Workflow run IDs: $(echo "$WORKFLOW_RUNS" | tr '\n' ' ')"

          # Download coverage history artifacts from recent runs
          DOWNLOADED_COUNT=0
          MAX_ARTIFACTS=3

          for run_id in $WORKFLOW_RUNS; do
            if [[ $DOWNLOADED_COUNT -ge $MAX_ARTIFACTS ]]; then
              echo "📊 Reached maximum artifact limit ($MAX_ARTIFACTS), stopping download"
              break
            fi

            echo ""
            echo "🔍 Checking run $run_id for coverage history artifacts..."

            ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$run_id/artifacts \
              --jq '.artifacts[] | select(.name | startswith("coverage-history-")) | .archive_download_url' \
              2>/dev/null || echo "")

            if [[ -n "$ARTIFACTS" ]]; then
              echo "✅ Found coverage history artifacts in run $run_id"

              echo "$ARTIFACTS" | while read -r download_url; do
                if [[ -n "$download_url" ]]; then
                  echo "📥 Downloading artifact from: $download_url"
                  cd .github/coverage/history-artifacts/

                  # Download with detailed logging
                  DOWNLOAD_SUCCESS=false
                  for attempt in 1 2 3; do
                    echo "    📥 Download attempt $attempt/3..."
                    if curl -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                            -H "Accept: application/vnd.github+json" \
                            --max-time 30 --connect-timeout 10 \
                            "$download_url" -o "history-$run_id.zip" 2>/dev/null; then
                      if [[ -s "history-$run_id.zip" ]]; then
                        echo "    ✅ Download successful ($(wc -c < "history-$run_id.zip") bytes)"
                        DOWNLOAD_SUCCESS=true
                        break
                      else
                        echo "    ⚠️ Downloaded file is empty"
                        rm -f "history-$run_id.zip"
                      fi
                    else
                      echo "    ⚠️ Download attempt $attempt failed"
                      rm -f "history-$run_id.zip"
                    fi

                    if [[ $attempt -lt 3 ]]; then
                      echo "    ⏳ Waiting 2 seconds before retry..."
                      sleep 2
                    fi
                  done

                  if [[ "$DOWNLOAD_SUCCESS" == "true" ]]; then
                    if unzip -q "history-$run_id.zip" 2>/dev/null; then
                      rm -f "history-$run_id.zip"
                      echo "    ✅ Extracted history from run $run_id"

                      # Show what was extracted
                      EXTRACTED_FILES=$(find . -name "*.json" -newer "history-$run_id.zip" 2>/dev/null | wc -l || echo "0")
                      echo "    📄 Extracted $EXTRACTED_FILES JSON files"
                    else
                      echo "    ⚠️ Failed to extract history-$run_id.zip (possibly corrupted)"
                      rm -f "history-$run_id.zip"
                    fi
                  else
                    echo "    ❌ Failed to download after 3 attempts"
                  fi

                  cd - > /dev/null
                fi
              done
              DOWNLOADED_COUNT=$((DOWNLOADED_COUNT + 1))
            else
              echo "ℹ️ No coverage history artifacts found in run $run_id"
            fi
          done

          if [[ $DOWNLOADED_COUNT -gt 0 ]]; then
            echo ""
            echo "✅ Successfully downloaded $DOWNLOADED_COUNT coverage history artifacts"

            # Show summary of downloaded files
            TOTAL_JSON_FILES=$(find .github/coverage/history-artifacts -name "*.json" -type f 2>/dev/null | wc -l || echo "0")
            echo "📊 Total JSON files downloaded: $TOTAL_JSON_FILES"

            if [[ $TOTAL_JSON_FILES -gt 0 ]]; then
              echo "📋 Downloaded files:"
              find .github/coverage/history-artifacts -name "*.json" -type f -exec basename {} \; | head -10
            fi
          else
            echo "ℹ️ No coverage history artifacts available from previous runs"
            echo "📝 This is normal for the first few runs of the coverage system"
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        continue-on-error: true

      - name: 🔄 Restore history from artifacts
        # Restore history for all branches to enable trend analysis
        if: github.event_name == 'push'
        run: |
          echo "🔄 Restoring coverage history from artifacts..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Create history directory
          HISTORY_DIR=".github/coverage/history"
          mkdir -p "$HISTORY_DIR"
          echo "📁 Created history directory: $HISTORY_DIR"

          # Check if artifacts were downloaded
          ARTIFACTS_DIR=".github/coverage/history-artifacts"
          if [[ -d "$ARTIFACTS_DIR" ]]; then
            echo "✅ Artifacts directory found: $ARTIFACTS_DIR"

            # Show available artifacts
            echo "📋 Contents of artifacts directory:"
            ls -la "$ARTIFACTS_DIR" || echo "Unable to list directory"

            # Count available JSON files
            ARTIFACT_FILES=$(find "$ARTIFACTS_DIR" -name "*.json" -type f 2>/dev/null | wc -l || echo "0")
            echo "📦 Found $ARTIFACT_FILES JSON files in artifacts"

            if [[ $ARTIFACT_FILES -gt 0 ]]; then
              echo ""
              echo "🔄 Starting file restoration process..."

              # List all JSON files found
              echo "📋 JSON files to be restored:"
              find "$ARTIFACTS_DIR" -name "*.json" -type f -exec echo "  - {}" \; 2>/dev/null

              # Copy files with detailed logging
              COPY_SUCCESS=0
              COPY_FAILED=0

              find "$ARTIFACTS_DIR" -name "*.json" -type f | while read -r file; do
                filename=$(basename "$file")
                destination="$HISTORY_DIR/$filename"

                if cp "$file" "$destination" 2>/dev/null; then
                  echo "  ✅ Copied: $filename"
                  COPY_SUCCESS=$((COPY_SUCCESS + 1))
                else
                  echo "  ❌ Failed to copy: $filename"
                  COPY_FAILED=$((COPY_FAILED + 1))
                fi
              done

              echo ""
              echo "✅ File restoration completed"
            else
              echo "ℹ️ No JSON files found in artifacts directory"
            fi
          else
            echo "ℹ️ No artifacts directory found - this is normal for first run"
          fi

          # Verify restoration results
          HISTORY_COUNT=$(find "$HISTORY_DIR" -name "*.json" -type f 2>/dev/null | wc -l || echo "0")
          echo ""
          echo "📊 History restoration summary:"
          echo "  - History directory: $HISTORY_DIR"
          echo "  - Total history files: $HISTORY_COUNT"

          if [[ $HISTORY_COUNT -gt 0 ]]; then
            echo "  - History files available for trend analysis: ✅"
            echo "📋 Restored history files (newest first):"
            find "$HISTORY_DIR" -name "*.json" -type f -exec basename {} \; | sort -r | head -5

            # Show disk usage
            HISTORY_SIZE=$(du -sh "$HISTORY_DIR" 2>/dev/null | cut -f1 || echo "unknown")
            echo "  - Total history size: $HISTORY_SIZE"
          else
            echo "  - History files available: ❌ (first run or no previous data)"
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Download coverage artifact and process
      # ————————————————————————————————————————————————————————————————
      - name: 📥 Download coverage artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: coverage-data
          path: ./coverage-artifacts/
        continue-on-error: true

      - name: 📊 Process coverage data
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ inputs.commit-sha }}
          GITHUB_REF_NAME: ${{ inputs.branch-name }}
          COVERAGE_HISTORY_PATH: ${{ github.workspace }}/.github/coverage/history
        working-directory: .github/coverage/cmd/gofortress-coverage
        run: |
          echo "📊 Processing coverage data with complete pipeline..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Debug: Show current working directory and paths
          echo "🔍 Environment information:"
          echo "  - Current working directory: $(pwd)"
          echo "  - Repository root should be: $(realpath ../../../../)"
          echo "  - History path from env: $COVERAGE_HISTORY_PATH"
          echo "  - GitHub repository: $GITHUB_REPOSITORY"
          echo "  - Branch: $GITHUB_REF_NAME"
          echo "  - Commit SHA: $GITHUB_SHA"

          # Find coverage file with detailed logging
          REPO_ROOT="$(realpath ../../../../)"
          echo ""
          echo "🔍 Locating coverage input file..."
          echo "  - Repository root: $REPO_ROOT"
          echo "  - Looking for: ${{ inputs.coverage-file }}"

          COVERAGE_FILE=""
          COVERAGE_LOCATIONS=(
            "$REPO_ROOT/coverage-artifacts/${{ inputs.coverage-file }}"
            "$REPO_ROOT/${{ inputs.coverage-file }}"
          )

          for location in "${COVERAGE_LOCATIONS[@]}"; do
            echo "  - Checking: $location"
            if [[ -f "$location" ]]; then
              COVERAGE_FILE="$location"
              FILE_SIZE=$(wc -c < "$COVERAGE_FILE" 2>/dev/null || echo "unknown")
              echo "    ✅ Found ($FILE_SIZE bytes)"
              break
            else
              echo "    ❌ Not found"
            fi
          done

          if [[ -z "$COVERAGE_FILE" ]]; then
            echo ""
            echo "❌ Coverage file not found: ${{ inputs.coverage-file }}"
            echo "🔍 Available files in coverage-artifacts:"
            ls -la "$REPO_ROOT/coverage-artifacts/" 2>/dev/null || echo "No coverage-artifacts directory"
            echo "🔍 Available files in repository root:"
            ls -la "$REPO_ROOT"/*.out "$REPO_ROOT"/*.txt 2>/dev/null || echo "No .out or .txt files in root"
            exit 1
          fi

          echo "✅ Using coverage file: $COVERAGE_FILE"

          # Create clean output directory with branch-specific structure
          OUTPUT_DIR="$REPO_ROOT/pages-deploy"
          BRANCH_NAME="${{ inputs.branch-name }}"
          BRANCH_OUTPUT_DIR="$OUTPUT_DIR/coverage/branch/$BRANCH_NAME"

          echo ""
          echo "🔧 Preparing output directory with branch-specific structure..."
          echo "  - Main output directory: $OUTPUT_DIR"
          echo "  - Branch-specific directory: $BRANCH_OUTPUT_DIR"
          echo "  - Branch name: $BRANCH_NAME"

          # Create branch-specific directory structure
          mkdir -p "$BRANCH_OUTPUT_DIR/data"
          mkdir -p "$OUTPUT_DIR/data"

          echo "  - Created branch-specific directory structure"
          echo "  - Created main and branch data subdirectories"

          # Show history availability for trend analysis
          HISTORY_DIR="$REPO_ROOT/.github/coverage/history"
          HISTORY_COUNT=$(find "$HISTORY_DIR" -name "*.json" -type f 2>/dev/null | wc -l || echo "0")
          echo ""
          echo "📈 History availability for trend analysis:"
          echo "  - History directory: $HISTORY_DIR"
          echo "  - Available history files: $HISTORY_COUNT"
          if [[ $HISTORY_COUNT -gt 0 ]]; then
            echo "  - Trend analysis: ✅ Enabled"
            echo "  - Recent history files:"
            find "$HISTORY_DIR" -name "*.json" -type f -exec basename {} \; | sort -r | head -3 | sed 's/^/    - /'
          else
            echo "  - Trend analysis: ⚠️ No history available (first run)"
          fi

          # Process coverage with complete command for main output
          echo ""
          echo "🚀 Running GoFortress coverage complete command for main output..."
          echo "  Command: ./gofortress-coverage complete --input \"$COVERAGE_FILE\" --output \"$OUTPUT_DIR\""

          if "$GOFORTRESS_BINARY" complete \
            --input "$COVERAGE_FILE" \
            --output "$OUTPUT_DIR"; then
            echo "✅ Main coverage processing completed successfully"
          else
            echo "❌ Main coverage processing failed"
            exit 1
          fi

          # Process coverage for branch-specific output
          echo ""
          echo "🚀 Running GoFortress coverage complete command for branch-specific output..."
          echo "  Command: ./gofortress-coverage complete --input \"$COVERAGE_FILE\" --output \"$BRANCH_OUTPUT_DIR\""

          if "$GOFORTRESS_BINARY" complete \
            --input "$COVERAGE_FILE" \
            --output "$BRANCH_OUTPUT_DIR"; then
            echo "✅ Branch-specific coverage processing completed successfully"
          else
            echo "❌ Branch-specific coverage processing failed"
            exit 1
          fi

          # Verify outputs were created
          echo ""
          echo "🔍 Verifying generated outputs..."
          EXPECTED_FILES=("index.html" "coverage.html" "coverage.svg")

          echo ""
          echo "📋 Checking main output files:"
          MAIN_ALL_GENERATED=true
          for file in "${EXPECTED_FILES[@]}"; do
            if [[ -f "$OUTPUT_DIR/$file" ]]; then
              FILE_SIZE=$(wc -c < "$OUTPUT_DIR/$file" 2>/dev/null || echo "unknown")
              echo "  ✅ Main: $file ($FILE_SIZE bytes)"
            else
              echo "  ❌ MISSING Main: $file"
              MAIN_ALL_GENERATED=false
            fi
          done

          echo ""
          echo "📋 Checking branch-specific output files:"
          BRANCH_ALL_GENERATED=true
          for file in "${EXPECTED_FILES[@]}"; do
            if [[ -f "$BRANCH_OUTPUT_DIR/$file" ]]; then
              FILE_SIZE=$(wc -c < "$BRANCH_OUTPUT_DIR/$file" 2>/dev/null || echo "unknown")
              echo "  ✅ Branch ($BRANCH_NAME): $file ($FILE_SIZE bytes)"
            else
              echo "  ❌ MISSING Branch ($BRANCH_NAME): $file"
              BRANCH_ALL_GENERATED=false
            fi
          done

          if [[ "$MAIN_ALL_GENERATED" != "true" ]] || [[ "$BRANCH_ALL_GENERATED" != "true" ]]; then
            echo ""
            echo "❌ Some expected files were not generated"
            echo "🔍 All files in output directory:"
            find "$OUTPUT_DIR" -type f -exec echo "  - {}" \;
            exit 1
          fi

          # Show processing summary
          TOTAL_FILES=$(find "$OUTPUT_DIR" -type f | wc -l)
          OUTPUT_SIZE=$(du -sh "$OUTPUT_DIR" 2>/dev/null | cut -f1 || echo "unknown")

          echo ""
          echo "📊 Processing summary:"
          echo "  - Total files generated: $TOTAL_FILES"
          echo "  - Total output size: $OUTPUT_SIZE"
          echo "  - Output directory: $OUTPUT_DIR"

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: 📈 Record coverage history
        # Record history for all branches to enable trend tracking
        if: github.event_name == 'push'
        env:
          COVERAGE_HISTORY_PATH: ${{ github.workspace }}/.github/coverage/history
        working-directory: .github/coverage/cmd/gofortress-coverage
        run: |
          echo "📈 Recording coverage history..."

          # Find coverage file
          REPO_ROOT="$(realpath ../../../../)"
          if [[ -f "$REPO_ROOT/coverage-artifacts/${{ inputs.coverage-file }}" ]]; then
            COVERAGE_FILE="$REPO_ROOT/coverage-artifacts/${{ inputs.coverage-file }}"
          elif [[ -f "$REPO_ROOT/${{ inputs.coverage-file }}" ]]; then
            COVERAGE_FILE="$REPO_ROOT/${{ inputs.coverage-file }}"
          else
            echo "⚠️ Coverage file not found for history recording"
            exit 0
          fi

          # Record coverage in history
          "$GOFORTRESS_BINARY" history \
            --add "$COVERAGE_FILE" \
            --branch "${{ inputs.branch-name }}" \
            --commit "${{ inputs.commit-sha }}" \
            --format text

          echo "✅ History recording completed"

      # ————————————————————————————————————————————————————————————————
      # Create PR comment (if in PR context)
      # ————————————————————————————————————————————————————————————————
      - name: 💬 Create or update PR coverage comment
        if: github.event_name == 'pull_request' && env.COVERAGE_PR_COMMENT_ENABLED == 'true'
        working-directory: .github/coverage/cmd/gofortress-coverage
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          echo "💬 Creating or updating PR coverage comment..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📋 PR Information:"
          echo "  - PR Number: $GITHUB_PR_NUMBER"
          echo "  - Head SHA: $GITHUB_SHA"
          echo "  - Repository: $GITHUB_REPOSITORY"
          echo "  - Comment behavior: ${{ env.COVERAGE_PR_COMMENT_BEHAVIOR }}"
          echo ""

          # Get the coverage file path
          REPO_ROOT="$(realpath ../../../../)"
          COVERAGE_FILE="$REPO_ROOT/coverage-artifacts/${{ inputs.coverage-file }}"

          if [[ ! -f "$COVERAGE_FILE" ]]; then
            # Try alternate path
            COVERAGE_FILE="$REPO_ROOT/${{ inputs.coverage-file }}"
          fi

          if [[ ! -f "$COVERAGE_FILE" ]]; then
            echo "❌ Coverage file not found: ${{ inputs.coverage-file }}"
            echo "🔍 Searched in:"
            echo "  - $REPO_ROOT/coverage-artifacts/"
            echo "  - $REPO_ROOT/"
            exit 1
          fi

          echo "✅ Found coverage file: $COVERAGE_FILE"

          # Check if we have a base coverage file for comparison (in PR context)
          BASE_COVERAGE_ARG=""
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "📊 Attempting to fetch base branch coverage for comparison..."
            
            BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            echo "📋 Base branch: $BASE_BRANCH (SHA: $BASE_SHA)"
            
            # Define repository root for consistent path handling
            REPO_ROOT="$(realpath ../../../../)"
            echo "📁 Repository root: $REPO_ROOT"
            
            # Try to fetch base coverage profile from recent workflow artifacts
            echo "🔍 Searching for base coverage in recent workflow artifacts..."
            
            BASE_COVERAGE_FILE=""
            # Look for recent successful workflow runs on the base branch
            if command -v gh &> /dev/null && gh auth status &> /dev/null; then
              echo "📋 Searching for recent artifacts with base coverage..."
              
              # Get recent successful runs on base branch
              RECENT_RUNS=$(gh api repos/${{ github.repository }}/actions/runs \
                --jq ".workflow_runs[] | select(.status == \"completed\" and .conclusion == \"success\" and .head_branch == \"$BASE_BRANCH\") | .id" \
                --paginate 2>/dev/null | head -3 || echo "")
              
              if [[ -n "$RECENT_RUNS" ]]; then
                for run_id in $RECENT_RUNS; do
                  echo "🔍 Checking run $run_id for coverage artifacts..."
                  
                  # Look for coverage-data artifact
                  COVERAGE_ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$run_id/artifacts \
                    --jq '.artifacts[] | select(.name == "coverage-data") | .archive_download_url' \
                    2>/dev/null || echo "")
                  
                  if [[ -n "$COVERAGE_ARTIFACTS" ]]; then
                    echo "✅ Found coverage-data artifact in run $run_id"
                    
                    # Create temporary directory for extraction
                    TEMP_EXTRACT_DIR="/tmp/base-coverage-extract-$$"
                    mkdir -p "$TEMP_EXTRACT_DIR"
                    cd "$TEMP_EXTRACT_DIR"
                    
                    # Download the artifact
                    if curl -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                            -H "Accept: application/vnd.github+json" \
                            --connect-timeout 10 --max-time 30 \
                            "$COVERAGE_ARTIFACTS" -o "base-coverage-artifact.zip" 2>/dev/null; then
                      
                      if [[ -s "base-coverage-artifact.zip" ]]; then
                        echo "✅ Downloaded base coverage artifact ($(wc -c < base-coverage-artifact.zip) bytes)"
                        
                        # Extract and find coverage file
                        if unzip -q "base-coverage-artifact.zip" 2>/dev/null; then
                          # Look for coverage files with common extensions
                          BASE_PROFILE=$(find . -name "*.out" -o -name "*.txt" -o -name "coverage.*" | grep -E '\.(out|txt)$' | head -1)
                          if [[ -n "$BASE_PROFILE" ]] && [[ -f "$BASE_PROFILE" ]]; then
                            echo "✅ Extracted base coverage profile: $BASE_PROFILE"
                            
                            # Copy to working directory
                            cp "$BASE_PROFILE" "$REPO_ROOT/base-coverage.out"
                            BASE_COVERAGE_FILE="$REPO_ROOT/base-coverage.out"
                            
                            # Verify the file has content
                            if [[ -s "$BASE_COVERAGE_FILE" ]]; then
                              echo "✅ Base coverage file ready: $(wc -c < "$BASE_COVERAGE_FILE") bytes"
                              break
                            else
                              echo "⚠️ Base coverage file is empty"
                              rm -f "$BASE_COVERAGE_FILE"
                              BASE_COVERAGE_FILE=""
                            fi
                          else
                            echo "⚠️ No coverage profile found in artifact"
                            echo "📋 Available files in artifact:"
                            find . -type f | head -10
                          fi
                        else
                          echo "⚠️ Failed to extract artifact (may be corrupted)"
                        fi
                      else
                        echo "⚠️ Downloaded artifact is empty"
                      fi
                    else
                      echo "⚠️ Failed to download artifact from: $COVERAGE_ARTIFACTS"
                    fi
                    
                    # Cleanup temp directory
                    cd "$REPO_ROOT"
                    rm -rf "$TEMP_EXTRACT_DIR"
                    
                    # If we found a valid base coverage file, break out of the loop
                    if [[ -n "$BASE_COVERAGE_FILE" ]]; then
                      break
                    fi
                  else
                    echo "ℹ️ No coverage-data artifact found in run $run_id"
                  fi
                done
              else
                echo "ℹ️ No recent successful runs found on base branch: $BASE_BRANCH"
              fi
            else
              echo "⚠️ GitHub CLI not available or not authenticated - skipping artifact search"
            fi
            
            # Set BASE_COVERAGE_ARG if we have base coverage
            if [[ -n "$BASE_COVERAGE_FILE" ]] && [[ -f "$BASE_COVERAGE_FILE" ]]; then
              echo "✅ Base coverage available for comparison: $BASE_COVERAGE_FILE"
              BASE_COVERAGE_ARG="--base-coverage \"$BASE_COVERAGE_FILE\""
            else
              echo "ℹ️ No base coverage available - PR comment will show as initial coverage report"
              echo "📝 This is normal for:"
              echo "  - First PR on this repository"
              echo "  - PRs where base branch has no recent successful coverage runs"
              echo "  - Temporary GitHub API issues"
            fi
          fi


          # Get URLs for the comment
          BADGE_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/coverage.svg"
          REPORT_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/coverage/"

          # Create PR comment
          "$GOFORTRESS_BINARY" comment \
            --pr "$GITHUB_PR_NUMBER" \
            --coverage "$COVERAGE_FILE" \
            $BASE_COVERAGE_ARG \
            --badge-url "$BADGE_URL" \
            --report-url "$REPORT_URL" \
            --enable-analysis \
            --anti-spam \
            --generate-badges

          if [[ $? -eq 0 ]]; then
            echo "✅ PR comment created/updated successfully"

            # Debug: Search for generated badges in current working directory
            echo ""
            echo "🔍 Debug: Searching for generated PR badges..."
            echo "  - Current working directory: $(pwd)"
            echo "  - Repository root: $REPO_ROOT"

            # Search for any SVG files that might be badges
            echo "  - Searching for *.svg files in current directory tree:"
            find . -name "*.svg" -type f 2>/dev/null | head -10 | while read svg_file; do
              echo "    Found: $svg_file"
            done

            # Check specific badge directories
            BADGE_SEARCH_DIRS=(
              "./coverage-badges"
              "$HOME/.gofortress/badges"
              "/tmp/pr-badges"
            )

            for search_dir in "${BADGE_SEARCH_DIRS[@]}"; do
              if [[ -d "$search_dir" ]]; then
                echo "  - Contents of $search_dir:"
                find "$search_dir" -type f -name "*.svg" 2>/dev/null | head -5 | while read badge_file; do
                  echo "    Badge: $badge_file"
                done
              else
                echo "  - Directory not found: $search_dir"
              fi
            done

          else
            echo "⚠️ Failed to create PR comment (non-fatal)"
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Deploy PR badges to make them accessible via GitHub Pages
      # ————————————————————————————————————————————————————————————————
      - name: 🏷️ Deploy PR badges to GitHub Pages
        if: github.event_name == 'pull_request' && env.COVERAGE_PR_COMMENT_ENABLED == 'true'
        working-directory: .github/coverage/cmd/gofortress-coverage
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          echo "🏷️ Deploying PR badges to GitHub Pages..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          REPO_ROOT="$(realpath ../../../../)"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          echo "🔍 Debug Information:"
          echo "  - Current working directory: $(pwd)"
          echo "  - Repository root: $REPO_ROOT"
          echo "  - PR Number: $PR_NUMBER"

          # Check if badges were generated by the comment command
          BADGE_SOURCE_DIR="/tmp/pr-badges/pr/$PR_NUMBER"
          if [[ ! -d "$BADGE_SOURCE_DIR" ]]; then
            echo "ℹ️ No PR badges found at $BADGE_SOURCE_DIR - checking alternative paths"

            # Try alternative paths where badges might be generated
            ALT_PATHS=(
              "$HOME/.gofortress/badges/pr/$PR_NUMBER"
              "./badges/pr/$PR_NUMBER"
              "$REPO_ROOT/badges/pr/$PR_NUMBER"
              "./coverage-badges/pr/$PR_NUMBER"
              "$REPO_ROOT/coverage-badges/pr/$PR_NUMBER"
              "$REPO_ROOT/.github/coverage/cmd/gofortress-coverage/coverage-badges/pr/$PR_NUMBER"
              "$GOFORTRESS_DIR/coverage-badges/pr/$PR_NUMBER"
            )

            for alt_path in "${ALT_PATHS[@]}"; do
              echo "  - Checking: $alt_path"
              if [[ -d "$alt_path" ]]; then
                BADGE_COUNT=$(find "$alt_path" -name "*.svg" -type f 2>/dev/null | wc -l)
                echo "    ✅ Directory exists with $BADGE_COUNT SVG files"
                if [[ $BADGE_COUNT -gt 0 ]]; then
                  BADGE_SOURCE_DIR="$alt_path"
                  echo "    ✅ Using as badge source directory"
                  break
                else
                  echo "    ⚠️ Directory exists but contains no SVG files"
                fi
              else
                echo "    ❌ Directory does not exist"
              fi
            done

            if [[ ! -d "$BADGE_SOURCE_DIR" ]]; then
              echo "⚠️ No PR badges found to deploy - this is expected if badge generation failed"
              echo "📝 Badge URLs in PR comment will show 404 until badges are generated"
              exit 0
            fi
          else
            echo "✅ Found PR badges at: $BADGE_SOURCE_DIR"
          fi

          # Create deployment directory structure for PR badges
          DEPLOY_DIR="$REPO_ROOT/pages-deploy"
          PR_BADGE_DEPLOY_DIR="$DEPLOY_DIR/coverage/pr/$PR_NUMBER"

          echo "📁 Creating PR badge deployment directory: $PR_BADGE_DEPLOY_DIR"
          mkdir -p "$PR_BADGE_DEPLOY_DIR"

          # Copy PR badges to deployment directory
          echo "📋 Copying PR badges to deployment directory..."
          if cp -r "$BADGE_SOURCE_DIR"/* "$PR_BADGE_DEPLOY_DIR/" 2>/dev/null; then
            echo "✅ PR badges copied successfully"

            # List deployed badges
            echo "🏷️ Deployed PR badges:"
            find "$PR_BADGE_DEPLOY_DIR" -name "*.svg" -exec echo "  - {}" \;
            
            # Create a simple badge.svg symlink to the main coverage badge
            if [[ -f "$PR_BADGE_DEPLOY_DIR/badge-coverage-flat.svg" ]]; then
              ln -sf "badge-coverage-flat.svg" "$PR_BADGE_DEPLOY_DIR/badge.svg"
              echo "✅ Created badge.svg symlink"
            fi

            # Show expected URLs
            echo "🌐 PR badges will be available at:"
            find "$PR_BADGE_DEPLOY_DIR" -name "*.svg" -exec basename {} \; | while read badge_file; do
              echo "  - https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/coverage/pr/$PR_NUMBER/$badge_file"
            done

          else
            echo "⚠️ Failed to copy PR badges - source directory may be empty"
            echo "🔍 Contents of source directory:"
            ls -la "$BADGE_SOURCE_DIR" 2>/dev/null || echo "Directory not accessible"
            exit 0
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Deploy PR badges directly to GitHub Pages (immediate availability)
      # ————————————————————————————————————————————————————————————————
      - name: 🚀 Deploy PR badges to live GitHub Pages
        if: github.event_name == 'pull_request' && env.COVERAGE_PR_COMMENT_ENABLED == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          echo "🚀 Deploying PR badges directly to GitHub Pages..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          REPO_ROOT="$(pwd)"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_BADGE_DIR="$REPO_ROOT/pages-deploy/coverage/pr/$PR_NUMBER"

          # Check if we have badges to deploy
          if [[ ! -d "$PR_BADGE_DIR" ]] || [[ -z "$(find "$PR_BADGE_DIR" -name "*.svg" 2>/dev/null)" ]]; then
            echo "⚠️ No PR badges found to deploy - skipping GitHub Pages deployment"
            exit 0
          fi

          echo "✅ Found PR badges to deploy:"
          find "$PR_BADGE_DIR" -name "*.svg" -exec echo "  - {}" \;

          # Clone the gh-pages branch to a temporary directory
          TEMP_PAGES_DIR="/tmp/gh-pages-$$"
          echo "📥 Cloning gh-pages branch to: $TEMP_PAGES_DIR"

          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          if git clone --depth 1 --branch gh-pages "https://x-access-token:$GITHUB_TOKEN@github.com/${{ github.repository }}.git" "$TEMP_PAGES_DIR" 2>/dev/null; then
            echo "✅ Successfully cloned gh-pages branch"

            # Create PR badge directory in gh-pages
            GH_PAGES_PR_DIR="$TEMP_PAGES_DIR/coverage/pr/$PR_NUMBER"
            mkdir -p "$GH_PAGES_PR_DIR"
            echo "📁 Created directory: $GH_PAGES_PR_DIR"

            # Copy badges to gh-pages
            if cp "$PR_BADGE_DIR"/*.svg "$GH_PAGES_PR_DIR/" 2>/dev/null; then
              echo "✅ Copied PR badges to gh-pages branch"

              # Commit and push changes
              cd "$TEMP_PAGES_DIR"
              git add coverage/pr/$PR_NUMBER/*.svg

              if git diff --staged --quiet; then
                echo "ℹ️ No changes to commit - badges are already up to date"
              else
                git commit -m "Add PR #$PR_NUMBER coverage badges"$'\n\n🏷️ Generated with GoFortress'

                if git push origin gh-pages; then
                  echo "✅ Successfully pushed PR badges to GitHub Pages"
                  echo "🌐 Badges will be available within 1-2 minutes at:"
                  find "$GH_PAGES_PR_DIR" -name "*.svg" -exec basename {} \; | while read badge_file; do
                    echo "  - https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/coverage/pr/$PR_NUMBER/$badge_file"
                  done
                else
                  echo "❌ Failed to push PR badges to GitHub Pages"
                fi
              fi
            else
              echo "❌ Failed to copy badges to gh-pages directory"
            fi

            # Cleanup
            cd "$REPO_ROOT"
            rm -rf "$TEMP_PAGES_DIR"

          else
            echo "⚠️ Could not clone gh-pages branch - it may not exist yet"
            echo "📝 PR badges will be available after the first main branch deployment"
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Upload PR badge deployment as artifact for backup availability
      # ————————————————————————————————————————————————————————————————
      - name: 📤 Upload PR badges as artifact
        if: github.event_name == 'pull_request' && env.COVERAGE_PR_COMMENT_ENABLED == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: pr-badges-${{ github.event.pull_request.number }}
          path: pages-deploy/coverage/pr/${{ github.event.pull_request.number }}/*.svg
          retention-days: 30
        continue-on-error: true

      # ————————————————————————————————————————————————————————————————
      # Prepare for GitHub Pages deployment
      # ————————————————————————————————————————————————————————————————
      - name: 🔧 Prepare GitHub Pages deployment
        run: |
          echo "🔧 Preparing GitHub Pages deployment..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          DEPLOY_DIR="pages-deploy"
          echo "📁 Deployment directory: $DEPLOY_DIR"

          # Verify deployment directory exists
          if [[ ! -d "$DEPLOY_DIR" ]]; then
            echo "❌ Deployment directory does not exist: $DEPLOY_DIR"
            echo "🔍 This suggests coverage processing failed"
            exit 1
          fi

          echo "✅ Deployment directory found"

          # Add .nojekyll to disable Jekyll processing (CRITICAL FIX)
          echo ""
          echo "🔧 Adding .nojekyll file to disable Jekyll processing..."
          touch "$DEPLOY_DIR/.nojekyll"

          if [[ -f "$DEPLOY_DIR/.nojekyll" ]]; then
            echo "✅ .nojekyll file created successfully"
            echo "📝 This disables Jekyll processing that was filtering out coverage files"
          else
            echo "❌ Failed to create .nojekyll file"
            exit 1
          fi

          # Show complete directory structure before deployment
          echo ""
          echo "🌳 Complete deployment directory structure:"
          find "$DEPLOY_DIR" -type f -exec ls -la {} \; | sort
          echo ""

          # Verify critical files exist with detailed reporting
          CRITICAL_FILES=("index.html" "coverage.html" "coverage.svg" ".nojekyll")
          echo "🎯 Verifying critical files for GitHub Pages:"

          ALL_EXIST=true
          for file in "${CRITICAL_FILES[@]}"; do
            if [[ -f "$DEPLOY_DIR/$file" ]]; then
              FILE_SIZE=$(wc -c < "$DEPLOY_DIR/$file" 2>/dev/null || echo "unknown")
              echo "  ✅ $file ($FILE_SIZE bytes)"

              # Show content preview for important files
              if [[ "$file" == "data/build-status.json" ]]; then
                echo "    📋 Content preview:"
                head -3 "$DEPLOY_DIR/$file" | sed 's/^/      /'
              fi
            else
              echo "  ❌ MISSING: $file"
              ALL_EXIST=false
            fi
          done

          if [[ "$ALL_EXIST" != "true" ]]; then
            echo ""
            echo "❌ Missing critical files for deployment"
            echo "🔍 This will cause 404 errors on the deployed site"
            echo "🚨 Available files in deployment directory:"
            find "$DEPLOY_DIR" -type f -exec echo "  - {}" \;
            exit 1
          fi

          # File analysis by type
          echo ""
          echo "📋 File analysis by type:"
          echo "  HTML files:"
          find "$DEPLOY_DIR" -name "*.html" -exec echo "    - {}" \;
          echo "  JSON files:"
          find "$DEPLOY_DIR" -name "*.json" -exec echo "    - {}" \;
          echo "  SVG files:"
          find "$DEPLOY_DIR" -name "*.svg" -exec echo "    - {}" \;
          echo "  Jekyll control files:"
          find "$DEPLOY_DIR" -name ".nojekyll" -exec echo "    - {}" \;

          # Deployment summary
          TOTAL_FILES=$(find "$DEPLOY_DIR" -type f | wc -l)
          TOTAL_SIZE=$(du -sh "$DEPLOY_DIR" 2>/dev/null | cut -f1 || echo "unknown")

          echo ""
          echo "📊 Deployment summary:"
          echo "  - Total files to deploy: $TOTAL_FILES"
          echo "  - Total deployment size: $TOTAL_SIZE"
          echo "  - Jekyll processing: ❌ DISABLED (.nojekyll present)"
          echo "  - Expected URLs after deployment:"
          echo "    - https://mrz1836.github.io/go-broadcast/ (dashboard)"
          echo "    - https://mrz1836.github.io/go-broadcast/coverage.html (detailed report)"
          echo "    - https://mrz1836.github.io/go-broadcast/data/build-status.json (build status)"
          echo "    - https://mrz1836.github.io/go-broadcast/coverage.svg (coverage badge)"

          echo ""
          echo "✅ Deployment directory prepared and verified"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Deploy to GitHub Pages (Incremental, Non-Destructive)
      # ————————————————————————————————————————————————————————————————
      - name: 🚀 Deploy to GitHub Pages (Incremental)
        if: github.event_name == 'push'
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          echo "🚀 Starting incremental GitHub Pages deployment..."
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          REPO_ROOT="$(pwd)"
          DEPLOY_DIR="$REPO_ROOT/pages-deploy"
          BRANCH_NAME="${{ inputs.branch-name }}"
          TEMP_PAGES_DIR="/tmp/gh-pages-deploy-$$"

          # Verify deployment directory
          if [[ ! -d "$DEPLOY_DIR" ]]; then
            echo "❌ Deployment directory does not exist: $DEPLOY_DIR"
            exit 1
          fi

          echo "📁 Deployment source: $DEPLOY_DIR"
          echo "🌿 Current branch: $BRANCH_NAME"

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Clone existing gh-pages branch (or create new)
          echo "📥 Cloning gh-pages branch..."
          if git clone --depth 1 --branch gh-pages "https://x-access-token:$GITHUB_TOKEN@github.com/${{ github.repository }}.git" "$TEMP_PAGES_DIR" 2>/dev/null; then
            echo "✅ Successfully cloned existing gh-pages branch"
            cd "$TEMP_PAGES_DIR"

            # Show current content summary
            echo "📊 Current gh-pages content:"
            echo "  - Total files: $(find . -type f -not -path './.git/*' | wc -l)"
            echo "  - Coverage branches: $(find coverage/branch -maxdepth 1 -type d 2>/dev/null | wc -l || echo "0")"
            echo "  - PR badges: $(find coverage/pr -name "*.svg" 2>/dev/null | wc -l || echo "0")"
          else
            echo "📝 Creating new gh-pages branch..."
            mkdir -p "$TEMP_PAGES_DIR"
            cd "$TEMP_PAGES_DIR"
            git init
            git checkout -b gh-pages
            echo "✅ Created new gh-pages branch"
          fi

          # Install GitHub Pages .gitignore filter to prevent pushing unwanted files
          echo ""
          echo "🔧 Installing GitHub Pages .gitignore filter..."
          GH_PAGES_GITIGNORE="$REPO_ROOT/.github/coverage/gh-pages.gitignore"
          if [[ -f "$GH_PAGES_GITIGNORE" ]]; then
            cp "$GH_PAGES_GITIGNORE" .gitignore
            echo "✅ Copied GitHub Pages .gitignore filter"
            echo "📝 This ensures only coverage files are tracked in gh-pages branch"
          else
            echo "⚠️ GitHub Pages .gitignore not found at: $GH_PAGES_GITIGNORE"
            echo "📝 Will proceed without filter - consider creating the file for cleaner deployments"
          fi

          # Preserve existing content structure
          echo ""
          echo "🔄 Merging new content..."

          # Update root files (main branch deployments)
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            echo "📋 Updating root coverage files for main branch..."
            # Copy root files but preserve existing branch/pr directories
            for file in index.html coverage.html coverage.svg .nojekyll data; do
              if [[ -e "$DEPLOY_DIR/$file" ]]; then
                cp -r "$DEPLOY_DIR/$file" .
                echo "  ✅ Updated: $file"
              fi
            done
          fi

          # Update branch-specific content
          BRANCH_DIR="coverage/branch/$BRANCH_NAME"
          echo "📋 Updating branch-specific content: $BRANCH_DIR"
          mkdir -p "$BRANCH_DIR"

          # Copy branch-specific files from deployment directory
          if [[ -d "$DEPLOY_DIR/coverage/branch/$BRANCH_NAME" ]]; then
            cp -r "$DEPLOY_DIR/coverage/branch/$BRANCH_NAME"/* "$BRANCH_DIR/" 2>/dev/null || true
            echo "  ✅ Updated branch coverage: $BRANCH_NAME"
          else
            # If no branch-specific dir, copy from root (backwards compatibility)
            for file in index.html coverage.html coverage.svg; do
              if [[ -f "$DEPLOY_DIR/$file" ]]; then
                cp "$DEPLOY_DIR/$file" "$BRANCH_DIR/"
              fi
            done
            if [[ -d "$DEPLOY_DIR/data" ]]; then
              cp -r "$DEPLOY_DIR/data" "$BRANCH_DIR/"
            fi
          fi

          # Ensure .nojekyll exists
          touch .nojekyll

          # Create index.html with branch/PR listing if on main branch
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            echo "📝 Generating branch/PR index..."

            # Create the HTML file using echo commands to avoid heredoc indentation issues
            echo '<!DOCTYPE html>' > branches.html
            echo '<html lang="en">' >> branches.html
            echo '<head>' >> branches.html
            echo '    <meta charset="UTF-8">' >> branches.html
            echo '    <meta name="viewport" content="width=device-width, initial-scale=1.0">' >> branches.html
            echo '    <title>Coverage Reports - All Branches</title>' >> branches.html
            echo '    <style>' >> branches.html
            echo '        body { font-family: -apple-system, BlinkMacSystemFont, '"'"'Segoe UI'"'"', Roboto, sans-serif; margin: 40px; background: #f6f8fa; }' >> branches.html
            echo '        .container { max-width: 900px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }' >> branches.html
            echo '        h1 { color: #24292e; border-bottom: 1px solid #e1e4e8; padding-bottom: 10px; }' >> branches.html
            echo '        h2 { color: #586069; margin-top: 30px; }' >> branches.html
            echo '        .branch-list, .pr-list { list-style: none; padding: 0; }' >> branches.html
            echo '        .branch-list li, .pr-list li { padding: 10px; margin: 5px 0; background: #f6f8fa; border-radius: 6px; }' >> branches.html
            echo '        .branch-list a, .pr-list a { color: #0366d6; text-decoration: none; font-weight: 500; }' >> branches.html
            echo '        .branch-list a:hover, .pr-list a:hover { text-decoration: underline; }' >> branches.html
            echo '        .badge { display: inline-block; margin-left: 10px; }' >> branches.html
            echo '        .main-link { display: inline-block; margin: 20px 0; padding: 10px 20px; background: #0366d6; color: white; border-radius: 6px; text-decoration: none; }' >> branches.html
            echo '        .main-link:hover { background: #0256c7; }' >> branches.html
            echo '    </style>' >> branches.html
            echo '</head>' >> branches.html
            echo '<body>' >> branches.html
            echo '    <div class="container">' >> branches.html
            echo '        <h1>📊 Coverage Reports</h1>' >> branches.html
            echo '        <a href="/" class="main-link">View Main Coverage Dashboard</a>' >> branches.html
            echo '' >> branches.html
            echo '        <h2>🌿 Branch Coverage</h2>' >> branches.html
            echo '        <ul class="branch-list">' >> branches.html

            # List all branch coverage reports
            if [[ -d coverage/branch ]]; then
              for branch_dir in coverage/branch/*/; do
                if [[ -d "$branch_dir" ]]; then
                  branch=$(basename "$branch_dir")
                  echo "            <li>📁 <a href=\"/coverage/branch/$branch/\">$branch</a> <img src=\"/coverage/branch/$branch/coverage.svg\" alt=\"Coverage\" class=\"badge\"></li>" >> branches.html
                fi
              done
            fi

            echo '        </ul>' >> branches.html
            echo '' >> branches.html
            echo '        <h2>🔀 Pull Request Coverage</h2>' >> branches.html
            echo '        <ul class="pr-list">' >> branches.html

            # List all PR coverage badges
            if [[ -d coverage/pr ]]; then
              for pr_dir in coverage/pr/*/; do
                if [[ -d "$pr_dir" ]]; then
                  pr_num=$(basename "$pr_dir")
                  echo "            <li>PR #$pr_num: <img src=\"/coverage/pr/$pr_num/coverage.svg\" alt=\"PR Coverage\" class=\"badge\"></li>" >> branches.html
                fi
              done
            fi

            echo '        </ul>' >> branches.html
            echo '    </div>' >> branches.html
            echo '</body>' >> branches.html
            echo '</html>' >> branches.html

            echo "  ✅ Generated branch/PR index"
          fi

          # Show deployment summary
          echo ""
          echo "📊 Deployment content summary:"
          echo "  - Total files: $(find . -type f -not -path './.git/*' | wc -l)"
          echo "  - Branch coverage reports: $(find coverage/branch -maxdepth 1 -type d 2>/dev/null | tail -n +2 | wc -l || echo "0")"
          echo "  - PR badges: $(find coverage/pr -name "*.svg" 2>/dev/null | wc -l || echo "0")"

          # Stage all changes
          git add .

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "ℹ️ No changes to deploy"
            cd "$REPO_ROOT"
            rm -rf "$TEMP_PAGES_DIR"
            exit 0
          fi

          # Commit changes
          COMMIT_MSG="Deploy coverage for branch '$BRANCH_NAME' (commit ${{ inputs.commit-sha }})"
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            COMMIT_MSG="Deploy main coverage dashboard (commit ${{ inputs.commit-sha }})"
          fi

          git commit -m "$COMMIT_MSG"$'\n\n🏷️ Generated with GoFortress'

          # Push to GitHub Pages
          if git push origin gh-pages --force; then
            echo "✅ Successfully deployed to GitHub Pages"
            echo ""
            echo "🌐 Deployment URLs:"
            echo "  - Main dashboard: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/"
            echo "  - Branch coverage: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/coverage/branch/$BRANCH_NAME/"
            if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
              echo "  - All branches: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/branches.html"
            fi
          else
            echo "❌ Failed to push to GitHub Pages"
            cd "$REPO_ROOT"
            rm -rf "$TEMP_PAGES_DIR"
            exit 1
          fi

          # Cleanup
          cd "$REPO_ROOT"
          rm -rf "$TEMP_PAGES_DIR"

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      # ————————————————————————————————————————————————————————————————
      # Test deployed URLs (30 second timeout max)
      # ————————————————————————————————————————————————————————————————
      - name: 🔍 Test deployed URLs
        if: github.event_name == 'push'
        run: |
          echo "🔍 Testing deployed URLs..."

          BASE_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          BRANCH_NAME="${{ inputs.branch-name }}"

          # First, check if this is likely a first deployment
          echo "🔍 Checking deployment status..."
          IS_FIRST_RUN=false
          MAIN_SITE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "$BASE_URL/" 2>/dev/null || echo "000")

          if [[ "$MAIN_SITE_STATUS" == "404" ]] || [[ "$MAIN_SITE_STATUS" == "000" ]]; then
            echo "📝 This appears to be a first deployment (main site returned $MAIN_SITE_STATUS)"
            IS_FIRST_RUN=true

            # For first run, wait longer for GitHub Pages to initialize
            echo "⏳ First deployment detected - waiting 60 seconds for GitHub Pages initialization..."
            sleep 60
          else
            echo "✅ Existing deployment detected (main site returned $MAIN_SITE_STATUS)"
            echo "⏳ Waiting 30 seconds for deployment to propagate..."
            sleep 30
          fi

          # Define URLs to test based on branch and deployment status
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            # Main branch deployment - test root URLs
            CRITICAL_URLS=(
              "$BASE_URL/"
              "$BASE_URL/index.html"
              "$BASE_URL/coverage.html"
              "$BASE_URL/coverage.svg"
            )
            OPTIONAL_URLS=(
              "$BASE_URL/coverage/branch/$BRANCH_NAME/"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/index.html"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/coverage.html"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/coverage.svg"
            )
          else
            # Feature branch deployment - only branch URLs are critical
            CRITICAL_URLS=(
              "$BASE_URL/coverage/branch/$BRANCH_NAME/"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/index.html"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/coverage.html"
              "$BASE_URL/coverage/branch/$BRANCH_NAME/coverage.svg"
            )
            OPTIONAL_URLS=(
              "$BASE_URL/"
              "$BASE_URL/index.html"
              "$BASE_URL/coverage.html"
              "$BASE_URL/coverage.svg"
            )
          fi

          echo "🌐 Base URL: $BASE_URL"
          echo "🌿 Branch: $BRANCH_NAME"
          echo "🚀 First run: $IS_FIRST_RUN"

          # Test critical URLs (must pass)
          CRITICAL_SUCCESS=0
          CRITICAL_TOTAL=${#CRITICAL_URLS[@]}

          echo ""
          echo "📋 Testing critical URLs..."
          for url in "${CRITICAL_URLS[@]}"; do
            echo ""
            echo "🔗 Testing: $url"

            # Test with 3 attempts, with longer waits for first run
            HTTP_STATUS=""
            for attempt in 1 2 3; do
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "$url" 2>/dev/null || echo "000")

              if [[ "$HTTP_STATUS" == "200" ]]; then
                echo "  ✅ SUCCESS ($HTTP_STATUS)"
                CRITICAL_SUCCESS=$((CRITICAL_SUCCESS + 1))
                break
              else
                echo "  ❌ FAILED ($HTTP_STATUS)"
                if [[ $attempt -lt 3 ]]; then
                  if [[ "$IS_FIRST_RUN" == "true" ]]; then
                    echo "  ⏳ First run - retrying in 20 seconds..."
                    sleep 20
                  else
                    echo "  ⏳ Retrying in 5 seconds..."
                    sleep 5
                  fi
                fi
              fi
            done
          done

          # Test optional URLs (failures are warnings only)
          OPTIONAL_SUCCESS=0
          OPTIONAL_TOTAL=${#OPTIONAL_URLS[@]}

          if [[ $OPTIONAL_TOTAL -gt 0 ]]; then
            echo ""
            echo "📋 Testing optional URLs..."
            for url in "${OPTIONAL_URLS[@]}"; do
              echo ""
              echo "🔗 Testing: $url"

              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "$url" 2>/dev/null || echo "000")

              if [[ "$HTTP_STATUS" == "200" ]]; then
                echo "  ✅ SUCCESS ($HTTP_STATUS)"
                OPTIONAL_SUCCESS=$((OPTIONAL_SUCCESS + 1))
              else
                echo "  ⚠️ NOT AVAILABLE ($HTTP_STATUS) - This is expected for feature branches"
              fi
            done
          fi

          # Summary
          echo ""
          echo "📊 RESULTS:"
          echo "  - Critical URLs: $CRITICAL_SUCCESS/$CRITICAL_TOTAL (must be 100%)"
          echo "  - Optional URLs: $OPTIONAL_SUCCESS/$OPTIONAL_TOTAL (informational)"

          if [[ "$IS_FIRST_RUN" == "true" ]]; then
            echo "  - First deployment: Some URLs may take time to propagate"
          fi

          # Determine success based on critical URLs only
          if [[ $CRITICAL_SUCCESS -eq $CRITICAL_TOTAL ]]; then
            echo ""
            echo "🎉 DEPLOYMENT SUCCESSFUL! All critical URLs are accessible."
            echo ""
            if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
              echo "🌐 Main Coverage Dashboard: $BASE_URL/"
              echo "📊 Main Coverage Report: $BASE_URL/coverage.html"
              echo "🏷️ Main Coverage Badge: $BASE_URL/coverage.svg"
              echo "📑 All Branches Index: $BASE_URL/branches.html"
            fi
            echo ""
            echo "🌲 Branch Coverage Dashboard: $BASE_URL/coverage/branch/$BRANCH_NAME/"
            echo "📈 Branch Coverage Report: $BASE_URL/coverage/branch/$BRANCH_NAME/coverage.html"
            echo "🏷️ Branch Coverage Badge: $BASE_URL/coverage/branch/$BRANCH_NAME/coverage.svg"
          else
            echo ""
            echo "❌ DEPLOYMENT VERIFICATION FAILED"
            echo "🚨 Critical URLs are not accessible after multiple retries"

            # Provide helpful debugging information
            echo ""
            echo "🔍 Debugging information:"
            echo "  - Is this a first deployment? $IS_FIRST_RUN"
            echo "  - Branch being deployed: $BRANCH_NAME"
            echo "  - Failed critical URLs: $((CRITICAL_TOTAL - CRITICAL_SUCCESS))"
            echo ""
            echo "💡 Common causes:"
            echo "  - GitHub Pages not enabled for the repository"
            echo "  - Deployment still propagating (can take up to 10 minutes)"
            echo "  - Branch protection rules blocking deployment"
            echo "  - Previous deployment failed"

            exit 1
          fi

      # ————————————————————————————————————————————————————————————————
      # Collect cache statistics
      # ————————————————————————————————————————————————————————————————
      - name: 📊 Collect cache statistics
        id: cache-stats
        if: always()
        run: |
          echo "📊 Collecting cache statistics..."

          # Get cache hit information
          GOMOD_HIT="${{ steps.restore-gomod.outputs.cache-hit }}"
          GOBUILD_HIT="${{ steps.restore-gobuild.outputs.cache-hit }}"

          # Get cache sizes
          GOMOD_SIZE="0B"
          GOBUILD_SIZE="0B"

          if [ -d "$HOME/go/pkg/mod" ]; then
            GOMOD_SIZE=$(du -sh "$HOME/go/pkg/mod" 2>/dev/null | cut -f1 || echo "0B")
          fi

          if [ -d "$HOME/.cache/go-build" ]; then
            GOBUILD_SIZE=$(du -sh "$HOME/.cache/go-build" 2>/dev/null | cut -f1 || echo "0B")
          fi

          # Create cache statistics JSON
          echo '{' > "cache-stats-coverage.json"
          echo '  "os": "${{ inputs.primary-runner }}",' >> "cache-stats-coverage.json"
          echo '  "go_version": "${{ env.GO_PRIMARY_VERSION }}",' >> "cache-stats-coverage.json"
          echo "  \"gomod_cache_hit\": \"$GOMOD_HIT\"," >> "cache-stats-coverage.json"
          echo "  \"gobuild_cache_hit\": \"$GOBUILD_HIT\"," >> "cache-stats-coverage.json"
          echo "  \"cache_size_gomod\": \"$GOMOD_SIZE\"," >> "cache-stats-coverage.json"
          echo "  \"cache_size_gobuild\": \"$GOBUILD_SIZE\"," >> "cache-stats-coverage.json"
          echo '  "workflow": "coverage",' >> "cache-stats-coverage.json"
          echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" >> "cache-stats-coverage.json"
          echo '}' >> "cache-stats-coverage.json"

          echo "📊 Cache statistics collected"

      # ————————————————————————————————————————————————————————————————
      # Upload cache statistics
      # ————————————————————————————————————————————————————————————————
      - name: 📤 Upload cache statistics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: cache-stats-coverage
          path: cache-stats-coverage.json
          retention-days: 1

      # ————————————————————————————————————————————————————————————————
      # Upload coverage history for future runs (WORKING SYSTEM - PRESERVED)
      # ————————————————————————————————————————————————————————————————
      - name: 📤 Upload coverage history artifacts
        # Upload history for all branches to preserve trend data
        if: github.event_name == 'push'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: coverage-history-${{ inputs.commit-sha }}
          path: .github/coverage/history/*.json
          retention-days: 90
          compression-level: 9
        continue-on-error: true
